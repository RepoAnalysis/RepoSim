name1,name2,docs1,docs2,code1,code2,docs_score,code_score
gcd,euclidean_gcd,"gcd Euclid's Algorithm.
gcd{ð‘Ž,ð‘}=gcd{âˆ’ð‘Ž,ð‘}=gcd{ð‘Ž,âˆ’ð‘}=gcd{âˆ’ð‘Ž,âˆ’ð‘}
See proof: https://proofwiki.org/wiki/GCD_for_Negative_Integers","euclidean_gcd >>> euclidean_gcd(3, 5)
1

>>> euclidean_gcd(6, 3)
3","def gcd(a, b):
    """"""Computes the greatest common divisor of integers a and b using
    Euclid's Algorithm.
    gcd{ð‘Ž,ð‘}=gcd{âˆ’ð‘Ž,ð‘}=gcd{ð‘Ž,âˆ’ð‘}=gcd{âˆ’ð‘Ž,âˆ’ð‘}
    See proof: https://proofwiki.org/wiki/GCD_for_Negative_Integers
    """"""
    a_int = isinstance(a, int)
    b_int = isinstance(b, int)
    a = abs(a)
    b = abs(b)
    if not (a_int or b_int):
        raise ValueError('Input arguments are not integers')
    if a == 0 or b == 0:
        raise ValueError('One or more input arguments equals zero')
    while b != 0:
        (a, b) = (b, a % b)
    return a","def euclidean_gcd(a: int, b: int) -> int:
    """"""
    Examples:
    >>> euclidean_gcd(3, 5)
    1

    >>> euclidean_gcd(6, 3)
    3
    """"""
    while b:
        (a, b) = (b, a % b)
    return a",0.6016261,0.9977596
num_perfect_squares,perfect_square,num_perfect_squares Returns the smallest number of perfect squares that sum to the specified number.,perfect_square Check if a number is perfect square number or not,"def num_perfect_squares(number):
    """"""
    Returns the smallest number of perfect squares that sum to the specified number.
    :return: int between 1 - 4
    """"""
    if int(math.sqrt(number)) ** 2 == number:
        return 1
    while number > 0 and number % 4 == 0:
        number /= 4
    if number % 8 == 7:
        return 4
    for i in range(1, int(math.sqrt(number)) + 1):
        if int(math.sqrt(number - i ** 2)) ** 2 == number - i ** 2:
            return 2
    return 3","def perfect_square(num: int) -> bool:
    """"""
    Check if a number is perfect square number or not
    :param num: the number to be checked
    :return: True if number is square number, otherwise False

    >>> perfect_square(9)
    True
    >>> perfect_square(16)
    True
    >>> perfect_square(1)
    True
    >>> perfect_square(0)
    True
    >>> perfect_square(10)
    False
    """"""
    return math.sqrt(num) * math.sqrt(num) == num",0.7017091,0.99783957
_l2_distance,euclidean,_l2_distance Calculate l2 distance from two given vectors.,euclidean Calculates euclidean distance between two data.,"def _l2_distance(vec):
    """"""
    Calculate l2 distance from two given vectors.
    """"""
    norm = 0.0
    for element in vec:
        norm += element * element
    norm = math.sqrt(norm)
    return norm","def euclidean(input_a: np.ndarray, input_b: np.ndarray) -> float:
    """"""
    Calculates euclidean distance between two data.
    :param input_a: ndarray of first vector.
    :param input_b: ndarray of second vector.
    :return: Euclidean distance of input_a and input_b. By using math.sqrt(),
             result will be float.

    >>> euclidean(np.array([0]), np.array([1]))
    1.0
    >>> euclidean(np.array([0, 1]), np.array([1, 1]))
    1.0
    >>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1]))
    1.0
    """"""
    return math.sqrt(sum((pow(a - b, 2) for (a, b) in zip(input_a, input_b))))",0.74835193,0.9953994
cosine_similarity,cosine_similarity,cosine_similarity Calculate cosine similarity between given two vectors,cosine_similarity Calculates cosine similarity between two data.,"def cosine_similarity(vec1, vec2):
    """"""
    Calculate cosine similarity between given two vectors
    :type vec1: list
    :type vec2: list
    """"""
    if len(vec1) != len(vec2):
        raise ValueError('The two vectors must be the same length. Got shape ' + str(len(vec1)) + ' and ' + str(len(vec2)))
    norm_a = _l2_distance(vec1)
    norm_b = _l2_distance(vec2)
    similarity = 0.0
    for (vec1_element, vec2_element) in zip(vec1, vec2):
        similarity += vec1_element * vec2_element
    similarity /= norm_a * norm_b
    return similarity","def cosine_similarity(input_a: np.ndarray, input_b: np.ndarray) -> float:
    """"""
    Calculates cosine similarity between two data.
    :param input_a: ndarray of first vector.
    :param input_b: ndarray of second vector.
    :return: Cosine similarity of input_a and input_b. By using math.sqrt(),
             result will be float.

    >>> cosine_similarity(np.array([1]), np.array([1]))
    1.0
    >>> cosine_similarity(np.array([1, 2]), np.array([6, 32]))
    0.9615239476408232
    """"""
    return np.dot(input_a, input_b) / (norm(input_a) * norm(input_b))",0.92787814,0.9999505
magic_number,is_magic_gon,magic_number Checks if n is a magic number ,"is_magic_gon Check that the first number is the smallest number on the outer ring
Take a list, and check if the sum of each 3 numbers chunk is equal to the same total

>>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2])
True
>>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3])
True
>>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3])
True
>>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9])
False
>>> is_magic_gon([1])
Traceback (most recent call last):
ValueError: a gon ring should have a length that is a multiple of 3","def magic_number(n):
    """""" Checks if n is a magic number """"""
    total_sum = 0
    while n > 0 or total_sum > 9:
        if n == 0:
            n = total_sum
            total_sum = 0
        total_sum += n % 10
        n //= 10
    return total_sum == 1","def is_magic_gon(numbers: list[int]) -> bool:
    """"""
    Check if the solution set is a magic n-gon ring
    Check that the first number is the smallest number on the outer ring
    Take a list, and check if the sum of each 3 numbers chunk is equal to the same total

    >>> is_magic_gon([4, 2, 3, 5, 3, 1, 6, 1, 2])
    True
    >>> is_magic_gon([4, 3, 2, 6, 2, 1, 5, 1, 3])
    True
    >>> is_magic_gon([2, 3, 5, 4, 5, 1, 6, 1, 3])
    True
    >>> is_magic_gon([1, 2, 3, 4, 5, 6, 7, 8, 9])
    False
    >>> is_magic_gon([1])
    Traceback (most recent call last):
    ValueError: a gon ring should have a length that is a multiple of 3
    """"""
    if len(numbers) % 3 != 0:
        raise ValueError('a gon ring should have a length that is a multiple of 3')
    if min(numbers[::3]) != numbers[0]:
        return False
    total = sum(numbers[:3])
    return all((sum(numbers[i:i + 3]) == total for i in range(3, len(numbers), 3)))",0.6882748,0.35960293
solve_chinese_remainder,chinese_remainder_theorem2,"solve_chinese_remainder for a system of equations.
The system of equations has the form:
x % nums[0] = rems[0]
x % nums[1] = rems[1]
...
x % nums[k - 1] = rems[k - 1]
Where k is the number of elements in nums and rems, k > 0.
All numbers in nums needs to be pariwise coprime otherwise an exception is raised
returns x: the smallest value for x that satisfies the system of equations","chinese_remainder_theorem2 31

>>> chinese_remainder_theorem2(6,1,4,3)
14","def solve_chinese_remainder(nums: List[int], rems: List[int]):
    """"""
    Computes the smallest x that satisfies the chinese remainder theorem
    for a system of equations.
    The system of equations has the form:
    x % nums[0] = rems[0]
    x % nums[1] = rems[1]
    ...
    x % nums[k - 1] = rems[k - 1]
    Where k is the number of elements in nums and rems, k > 0.
    All numbers in nums needs to be pariwise coprime otherwise an exception is raised
    returns x: the smallest value for x that satisfies the system of equations
    """"""
    if not len(nums) == len(rems):
        raise Exception('nums and rems should have equal length')
    if not len(nums) > 0:
        raise Exception('Lists nums and rems need to contain at least one element')
    for num in nums:
        if not num > 1:
            raise Exception('All numbers in nums needs to be > 1')
    if not _check_coprime(nums):
        raise Exception('All pairs of numbers in nums are not coprime')
    k = len(nums)
    x = 1
    while True:
        i = 0
        while i < k:
            if x % nums[i] != rems[i]:
                break
            i += 1
        if i == k:
            return x
        x += 1","def chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:
    """"""
    >>> chinese_remainder_theorem2(5,1,7,3)
    31

    >>> chinese_remainder_theorem2(6,1,4,3)
    14

    """"""
    (x, y) = (invert_modulo(n1, n2), invert_modulo(n2, n1))
    m = n1 * n2
    n = r2 * x * n1 + r1 * y * n2
    return (n % m + m) % m",0.6668497,0.98138684
extended_gcd,extended_gcd,"extended_gcd Return s, t, g
such that num1 * s + num2 * t = GCD(num1, num2)
and s and t are co-prime.","extended_gcd and y, then d = gcd(a,b)
>>> extended_gcd(10, 6)
(2, -1, 2)

>>> extended_gcd(7, 5)
(1, -2, 3)

** extended_gcd function is used when d = gcd(a,b) is required in output","def extended_gcd(num1, num2):
    """"""Extended GCD algorithm.
    Return s, t, g
    such that num1 * s + num2 * t = GCD(num1, num2)
    and s and t are co-prime.
    """"""
    (old_s, s) = (1, 0)
    (old_t, t) = (0, 1)
    (old_r, r) = (num1, num2)
    while r != 0:
        quotient = old_r / r
        (old_r, r) = (r, old_r - quotient * r)
        (old_s, s) = (s, old_s - quotient * s)
        (old_t, t) = (t, old_t - quotient * t)
    return (old_s, old_t, old_r)","def extended_gcd(a: int, b: int) -> tuple[int, int, int]:
    """"""
    Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x
    and y, then d = gcd(a,b)
    >>> extended_gcd(10, 6)
    (2, -1, 2)

    >>> extended_gcd(7, 5)
    (1, -2, 3)

    ** extended_gcd function is used when d = gcd(a,b) is required in output

    """"""
    assert a >= 0 and b >= 0
    if b == 0:
        (d, x, y) = (a, 1, 0)
    else:
        (d, p, q) = extended_gcd(b, a % b)
        x = q
        y = p - q * (a // b)
    assert a % d == 0 and b % d == 0
    assert d == a * x + b * y
    return (d, x, y)",0.6347424,0.9998264
modular_inverse,modular_exponential,modular_inverse a and m must be coprime,"modular_exponential 1
>>> modular_exponential(2, 8, 7)
4
>>> modular_exponential(3, -2, 9)
-1","def modular_inverse(a: int, m: int) -> int:
    """"""
    Returns x such that a * x = 1 (mod m)
    a and m must be coprime
    """"""
    (s, _, g) = extended_gcd(a, m)
    if g != 1:
        raise ValueError('a and m must be coprime')
    return s % m","def modular_exponential(base: int, power: int, mod: int):
    """"""
    >>> modular_exponential(5, 0, 10)
    1
    >>> modular_exponential(2, 8, 7)
    4
    >>> modular_exponential(3, -2, 9)
    -1
    """"""
    if power < 0:
        return -1
    base %= mod
    result = 1
    while power > 0:
        if power & 1:
            result = result * base % mod
        power = power >> 1
        base = base * base % mod
    return result",0.6649908,0.58455765
decimal_to_binary_util,decimal_to_binary,decimal_to_binary_util Convert 8-bit decimal number to binary representation,"decimal_to_binary >>> decimal_to_binary(0)
'0b0'
>>> decimal_to_binary(2)
'0b10'
>>> decimal_to_binary(7)
'0b111'
>>> decimal_to_binary(35)
'0b100011'
>>> # negatives work too
>>> decimal_to_binary(-2)
'-0b10'
>>> # other floats will error
>>> decimal_to_binary(16.16) # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer
>>> # strings will error as well
>>> decimal_to_binary('0xfffff') # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: 'str' object cannot be interpreted as an integer","def decimal_to_binary_util(val):
    """"""
    Convert 8-bit decimal number to binary representation
    :type val: str
    :rtype: str
    """"""
    bits = [128, 64, 32, 16, 8, 4, 2, 1]
    val = int(val)
    binary_rep = ''
    for bit in bits:
        if val >= bit:
            binary_rep += str(1)
            val -= bit
        else:
            binary_rep += str(0)
    return binary_rep","def decimal_to_binary(num: int) -> str:
    """"""
    Convert an Integer Decimal Number to a Binary Number as str.
    >>> decimal_to_binary(0)
    '0b0'
    >>> decimal_to_binary(2)
    '0b10'
    >>> decimal_to_binary(7)
    '0b111'
    >>> decimal_to_binary(35)
    '0b100011'
    >>> # negatives work too
    >>> decimal_to_binary(-2)
    '-0b10'
    >>> # other floats will error
    >>> decimal_to_binary(16.16) # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> # strings will error as well
    >>> decimal_to_binary('0xfffff') # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: 'str' object cannot be interpreted as an integer
    """"""
    if isinstance(num, float):
        raise TypeError(""'float' object cannot be interpreted as an integer"")
    if isinstance(num, str):
        raise TypeError(""'str' object cannot be interpreted as an integer"")
    if num == 0:
        return '0b0'
    negative = False
    if num < 0:
        negative = True
        num = -num
    binary: list[int] = []
    while num > 0:
        binary.insert(0, num % 2)
        num >>= 1
    if negative:
        return '-0b' + ''.join((str(e) for e in binary))
    return '0b' + ''.join((str(e) for e in binary))",0.7411867,0.99344516
decimal_to_binary_ip,local_binary_value,decimal_to_binary_ip Convert dotted-decimal ip address to binary representation with help of decimal_to_binary_util,"local_binary_value decimal value of the local binary patternof the pixel
at that coordinate","def decimal_to_binary_ip(ip):
    """"""
    Convert dotted-decimal ip address to binary representation with help of decimal_to_binary_util
    """"""
    values = ip.split('.')
    binary_list = []
    for val in values:
        binary_list.append(decimal_to_binary_util(val))
    return '.'.join(binary_list)","def local_binary_value(image: np.ndarray, x_coordinate: int, y_coordinate: int) -> int:
    """"""
    It takes an image, an x and y coordinate, and returns the
    decimal value of the local binary patternof the pixel
    at that coordinate

    :param image: the image to be processed
    :param x_coordinate: x coordinate of the pixel
    :param y_coordinate: the y coordinate of the pixel
    :return: The decimal value of the binary value of the pixels
    around the center pixel.
    """"""
    center = image[x_coordinate][y_coordinate]
    powers = [1, 2, 4, 8, 16, 32, 64, 128]
    if center is None:
        return 0
    binary_values = [get_neighbors_pixel(image, x_coordinate - 1, y_coordinate + 1, center), get_neighbors_pixel(image, x_coordinate, y_coordinate + 1, center), get_neighbors_pixel(image, x_coordinate - 1, y_coordinate, center), get_neighbors_pixel(image, x_coordinate + 1, y_coordinate + 1, center), get_neighbors_pixel(image, x_coordinate + 1, y_coordinate, center), get_neighbors_pixel(image, x_coordinate + 1, y_coordinate - 1, center), get_neighbors_pixel(image, x_coordinate, y_coordinate - 1, center), get_neighbors_pixel(image, x_coordinate - 1, y_coordinate - 1, center)]
    return sum((binary_value * power for (binary_value, power) in zip(binary_values, powers)))",0.6267465,0.006977669
euler_totient,euler_modified,euler_totient Time Complexity: O(sqrt(n)).,"euler_modified The Euler Method is straightforward to implement, but can't give accurate solutions.
So, some changes were proposed to improve accuracy.

https://en.wikipedia.org/wiki/Euler_method

Arguments:
ode_func -- The ode as a function of x and y
y0 -- the initial value for y
x0 -- the initial value for x
stepsize -- the increment value for x
x_end -- the end value for x

>>> # the exact solution is math.exp(x)
>>> def f1(x, y):
...     return -2*x*(y**2)
>>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)
>>> y[-1]
0.503338255442106
>>> import math
>>> def f2(x, y):
...     return -2*y + (x**3)*math.exp(-2*x)
>>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)
>>> y[-1]
0.5525976431951775","def euler_totient(n):
    """"""Euler's totient function or Phi function.
    Time Complexity: O(sqrt(n)).""""""
    result = n
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            while n % i == 0:
                n //= i
            result -= result // i
    if n > 1:
        result -= result // n
    return result","def euler_modified(ode_func: Callable, y0: float, x0: float, step_size: float, x_end: float) -> np.array:
    """"""
    Calculate solution at each step to an ODE using Euler's Modified Method
    The Euler Method is straightforward to implement, but can't give accurate solutions.
    So, some changes were proposed to improve accuracy.

    https://en.wikipedia.org/wiki/Euler_method

    Arguments:
    ode_func -- The ode as a function of x and y
    y0 -- the initial value for y
    x0 -- the initial value for x
    stepsize -- the increment value for x
    x_end -- the end value for x

    >>> # the exact solution is math.exp(x)
    >>> def f1(x, y):
    ...     return -2*x*(y**2)
    >>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)
    >>> y[-1]
    0.503338255442106
    >>> import math
    >>> def f2(x, y):
    ...     return -2*y + (x**3)*math.exp(-2*x)
    >>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)
    >>> y[-1]
    0.5525976431951775
    """"""
    n = int(np.ceil((x_end - x0) / step_size))
    y = np.zeros((n + 1,))
    y[0] = y0
    x = x0
    for k in range(n):
        y_get = y[k] + step_size * ode_func(x, y[k])
        y[k + 1] = y[k] + step_size / 2 * (ode_func(x, y[k]) + ode_func(x + step_size, y_get))
        x += step_size
    return y",0.5877029,0.16665305
base_to_int,base85_encode,base_to_int Note : You can use int() built-in function instead of this.,"base85_encode b''
>>> base85_encode(""12345"")
b'0etOA2#'
>>> base85_encode(""base 85"")
b'@UX=h+?24'","def base_to_int(str_to_convert, base):
    """"""
        Note : You can use int() built-in function instead of this.
        :type str_to_convert: str
        :type base: int
        :rtype: int
    """"""
    digit = {}
    for (ind, char) in enumerate(string.digits + string.ascii_uppercase):
        digit[char] = ind
    multiplier = 1
    res = 0
    for char in str_to_convert[::-1]:
        res += digit[char] * multiplier
        multiplier *= base
    return res","def base85_encode(string: str) -> bytes:
    """"""
    >>> base85_encode("""")
    b''
    >>> base85_encode(""12345"")
    b'0etOA2#'
    >>> base85_encode(""base 85"")
    b'@UX=h+?24'
    """"""
    return base64.a85encode(string.encode('utf-8'))",0.43436337,0.9397639
modular_exponential,naive_cut_rod_recursive,"modular_exponential Time complexity - O(log n)
Use similar to Python in-built function pow.","naive_cut_rod_recursive programming. The results is the same sub-problems are solved several times
leading to an exponential runtime

Runtime: O(2^n)

Arguments
-------
n: int, the length of the rod
prices: list, the prices for each piece of rod. ``p[i-i]`` is the
price for a rod of length ``i``","def modular_exponential(base, exponent, mod):
    """"""Computes (base ^ exponent) % mod.
    Time complexity - O(log n)
    Use similar to Python in-built function pow.""""""
    if exponent < 0:
        raise ValueError('Exponent must be positive.')
    base %= mod
    result = 1
    while exponent > 0:
        if exponent & 1:
            result = result * base % mod
        exponent = exponent >> 1
        base = base * base % mod
    return result","def naive_cut_rod_recursive(n: int, prices: list):
    """"""
    Solves the rod-cutting problem via naively without using the benefit of dynamic
    programming. The results is the same sub-problems are solved several times
    leading to an exponential runtime

    Runtime: O(2^n)

    Arguments
    -------
    n: int, the length of the rod
    prices: list, the prices for each piece of rod. ``p[i-i]`` is the
    price for a rod of length ``i``

    Returns
    -------
    The maximum revenue obtainable for a rod of length n given the list of prices
    for each piece.

    Examples
    --------
    >>> naive_cut_rod_recursive(4, [1, 5, 8, 9])
    10
    >>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
    30
    """"""
    _enforce_args(n, prices)
    if n == 0:
        return 0
    max_revue = float('-inf')
    for i in range(1, n + 1):
        max_revue = max(max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i, prices))
    return max_revue",0.5780429,0.00026073024
get_primes,sieve_er,get_primes Using sieve of Eratosthenes.,"sieve_er returns a list of prime numbers from 2 up to N.

This function implements the algorithm called
sieve of erathostenes.","def get_primes(n):
    """"""Return list of all primes less than n,
    Using sieve of Eratosthenes.
    """"""
    if n <= 0:
        raise ValueError(""'n' must be a positive integer."")
    sieve_size = n // 2 - 1 if n % 2 == 0 else n // 2
    sieve = [True for _ in range(sieve_size)]
    primes = []
    if n >= 2:
        primes.append(2)
    for i in range(sieve_size):
        if sieve[i]:
            value_at_i = i * 2 + 3
            primes.append(value_at_i)
            for j in range(i, sieve_size, value_at_i):
                sieve[j] = False
    return primes","def sieve_er(n):
    """"""
    input: positive integer 'N' > 2
    returns a list of prime numbers from 2 up to N.

    This function implements the algorithm called
    sieve of erathostenes.

    """"""
    assert isinstance(n, int) and n > 2, ""'N' must been an int and > 2""
    begin_list = list(range(2, n + 1))
    ans = []
    for i in range(len(begin_list)):
        for j in range(i + 1, len(begin_list)):
            if begin_list[i] != 0 and begin_list[j] % begin_list[i] == 0:
                begin_list[j] = 0
    ans = [x for x in begin_list if x != 0]
    assert isinstance(ans, list), ""'ans' must been from type list""
    return ans",0.62937474,0.98973304
power,combination_sum_iv,"power Calculate a ^ n
if mod is specified, return the result modulo mod

Time Complexity :  O(log(n))
Space Complexity : O(1)","combination_sum_iv of possible combination in exponential Time Complexity.

>>> combination_sum_iv(3, [1,2,5], 5)
9","def power(a: int, n: int, mod: int=None):
    """"""
    Iterative version of binary exponentiation

    Calculate a ^ n
    if mod is specified, return the result modulo mod

    Time Complexity :  O(log(n))
    Space Complexity : O(1)
    """"""
    ans = 1
    while n:
        if n & 1:
            ans = ans * a
        a = a * a
        if mod:
            ans %= mod
            a %= mod
        n >>= 1
    return ans","def combination_sum_iv(n: int, array: list[int], target: int) -> int:
    """"""
    Function checks the all possible combinations, and returns the count
    of possible combination in exponential Time Complexity.

    >>> combination_sum_iv(3, [1,2,5], 5)
    9
    """"""

    def count_of_possible_combinations(target: int) -> int:
        if target < 0:
            return 0
        if target == 0:
            return 1
        return sum((count_of_possible_combinations(target - item) for item in array))
    return count_of_possible_combinations(target)",0.54858106,0.00064074097
power_recur,_modexpt,"power_recur Calculate a ^ n
if mod is specified, return the result modulo mod

Time Complexity :  O(log(n))
Space Complexity : O(log(n))","_modexpt of `base ** exponent % modulo_value`, without calculating
the actual number.
>>> _modexpt(2, 4, 10)
6
>>> _modexpt(2, 1024, 100)
16
>>> _modexpt(13, 65535, 7)
6","def power_recur(a: int, n: int, mod: int=None):
    """"""
    Recursive version of binary exponentiation

    Calculate a ^ n
    if mod is specified, return the result modulo mod

    Time Complexity :  O(log(n))
    Space Complexity : O(log(n))
    """"""
    if n == 0:
        ans = 1
    elif n == 1:
        ans = a
    else:
        ans = power_recur(a, n // 2, mod)
        ans = ans * ans
        if n % 2:
            ans = ans * a
    if mod:
        ans %= mod
    return ans","def _modexpt(base: int, exponent: int, modulo_value: int) -> int:
    """"""
    Returns the modular exponentiation, that is the value
    of `base ** exponent % modulo_value`, without calculating
    the actual number.
    >>> _modexpt(2, 4, 10)
    6
    >>> _modexpt(2, 1024, 100)
    16
    >>> _modexpt(13, 65535, 7)
    6
    """"""
    if exponent == 1:
        return base
    if exponent % 2 == 0:
        x = _modexpt(base, exponent // 2, modulo_value) % modulo_value
        return x * x % modulo_value
    else:
        return base * _modexpt(base, exponent - 1, modulo_value) % modulo_value",0.60453755,0.99979264
lcm,lcm,lcm Computes the lowest common multiple of integers a and b.,"lcm Using the property that lcm(a, b) * greatest_common_divisor(a, b) = a*b

>>> lcm(3, 15)
15
>>> lcm(1, 27)
27
>>> lcm(13, 27)
351
>>> lcm(64, 48)
192","def lcm(a, b):
    """"""Computes the lowest common multiple of integers a and b.""""""
    return abs(a) * abs(b) / gcd(a, b)","def lcm(x: int, y: int) -> int:
    """"""
    Least Common Multiple.

    Using the property that lcm(a, b) * greatest_common_divisor(a, b) = a*b

    >>> lcm(3, 15)
    15
    >>> lcm(1, 27)
    27
    >>> lcm(13, 27)
    351
    >>> lcm(64, 48)
    192
    """"""
    return x * y // greatest_common_divisor(x, y)",0.7591141,0.98999864
gcd_bit,get_bitcode,gcd_bit Similar to gcd but uses bitwise operators and less error handling.,get_bitcode Return bitcode of distinct_edge,"def gcd_bit(a, b):
    """""" Similar to gcd but uses bitwise operators and less error handling.""""""
    tza = trailing_zero(a)
    tzb = trailing_zero(b)
    a >>= tza
    b >>= tzb
    while b:
        if a < b:
            (a, b) = (b, a)
        a -= b
        a >>= trailing_zero(a)
    return a << min(tza, tzb)","def get_bitcode(edge_array, distinct_edge):
    """"""
    Return bitcode of distinct_edge
    """"""
    bitcode = ['0'] * len(edge_array)
    for (i, row) in enumerate(edge_array):
        for item in row:
            if distinct_edge in item[0]:
                bitcode[i] = '1'
                break
    return ''.join(bitcode)",0.5387185,0.17792445
find_next_square2,check1,"find_next_square2 Alternative method, works by evaluating anything non-zero as True (0.000001 --> True) ","check1 >>> check1(123456789987654321)
True

>>> check1(120000987654321)
True

>>> check1(12345678957656779870004321)
False","def find_next_square2(sq):
    """""" Alternative method, works by evaluating anything non-zero as True (0.000001 --> True) """"""
    root = sq ** 0.5
    return -1 if root % 1 else (root + 1) ** 2","def check1(number: int) -> bool:
    """"""
    Takes a number and checks if it is pandigital from END

    >>> check1(123456789987654321)
    True

    >>> check1(120000987654321)
    True

    >>> check1(12345678957656779870004321)
    False

    """"""
    check_last = [0] * 11
    for _ in range(9):
        check_last[int(number % 10)] = 1
        number = number // 10
    f = True
    for x in range(9):
        if not check_last[x + 1]:
            f = False
    return f",0.60009545,6.393112e-05
gen_strobogrammatic,line_length,"gen_strobogrammatic Given n, generate all strobogrammatic numbers of length n.",line_length sequence of linear lines and summing their lengths,"def gen_strobogrammatic(n):
    """"""
    Given n, generate all strobogrammatic numbers of length n.
    :type n: int
    :rtype: List[str]
    """"""
    return helper(n, n)","def line_length(fnc: Callable[[int | float], int | float], x_start: int | float, x_end: int | float, steps: int=100) -> float:
    """"""
    Approximates the arc length of a line segment by treating the curve as a
    sequence of linear lines and summing their lengths
    :param fnc: a function which defines a curve
    :param x_start: left end point to indicate the start of line segment
    :param x_end: right end point to indicate end of line segment
    :param steps: an accuracy gauge; more steps increases accuracy
    :return: a float representing the length of the curve

    >>> def f(x):
    ...    return x
    >>> f""{line_length(f, 0, 1, 10):.6f}""
    '1.414214'

    >>> def f(x):
    ...    return 1
    >>> f""{line_length(f, -5.5, 4.5):.6f}""
    '10.000000'

    >>> def f(x):
    ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10
    >>> f""{line_length(f, 0.0, 10.0, 10000):.6f}""
    '69.534930'
    """"""
    x1 = x_start
    fx1 = fnc(x_start)
    length = 0.0
    for _ in range(steps):
        x2 = (x_end - x_start) / steps + x1
        fx2 = fnc(x2)
        length += math.hypot(x2 - x1, fx2 - fx1)
        x1 = x2
        fx1 = fx2
    return length",0.57769495,0.20138626
recursive_binomial_coefficient,binomial_coefficient,"recursive_binomial_coefficient Time complexity is O(k), so can calculate fairly quickly for large values of k.

>>> recursive_binomial_coefficient(5,0)
1

>>> recursive_binomial_coefficient(8,2)
28

>>> recursive_binomial_coefficient(500,300)
5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640","binomial_coefficient https://en.wikipedia.org/wiki/Binomial_coefficient
C(n,k) = n! / k!(n-k)!","def recursive_binomial_coefficient(n, k):
    """"""Calculates the binomial coefficient, C(n,k), with n>=k using recursion
    Time complexity is O(k), so can calculate fairly quickly for large values of k.

    >>> recursive_binomial_coefficient(5,0)
    1

    >>> recursive_binomial_coefficient(8,2)
    28

    >>> recursive_binomial_coefficient(500,300)
    5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640

    """"""
    if k > n:
        raise ValueError('Invalid Inputs, ensure that n >= k')
    if k == 0 or n == k:
        return 1
    if k > n / 2:
        return recursive_binomial_coefficient(n, n - k)
    return int(n / k * recursive_binomial_coefficient(n - 1, k - 1))","def binomial_coefficient(n: int, k: int) -> int:
    """"""
    Since Here we Find the Binomial Coefficient:
    https://en.wikipedia.org/wiki/Binomial_coefficient
    C(n,k) = n! / k!(n-k)!
    :param n: 2 times of Number of nodes
    :param k: Number of nodes
    :return:  Integer Value

    >>> binomial_coefficient(4, 2)
    6
    """"""
    result = 1
    if k > n - k:
        k = n - k
    for i in range(k):
        result *= n - i
        result //= i + 1
    return result",0.6154336,0.99876773
generate_key,get_bit,generate_key k is the number of bits in n,"get_bit Details: perform bitwise and for the given number and X,
Where X is a number with all the bits â€“ zeroes and bit on given position â€“ one.
If the result is not equal to 0, then the bit on the given position is 1, else 0.

>>> get_bit(0b1010, 0)
0
>>> get_bit(0b1010, 1)
1
>>> get_bit(0b1010, 2)
0
>>> get_bit(0b1010, 3)
1","def generate_key(k, seed=None):
    """"""
    the RSA key generating algorithm
    k is the number of bits in n
    """"""

    def modinv(a, m):
        """"""calculate the inverse of a mod m
        that is, find b such that (a * b) % m == 1""""""
        b = 1
        while not a * b % m == 1:
            b += 1
        return b

    def gen_prime(k, seed=None):
        """"""generate a prime with k bits""""""

        def is_prime(num):
            if num == 2:
                return True
            for i in range(2, int(num ** 0.5) + 1):
                if num % i == 0:
                    return False
            return True
        random.seed(seed)
        while True:
            key = random.randrange(int(2 ** (k - 1)), int(2 ** k))
            if is_prime(key):
                return key
    p_size = k / 2
    q_size = k - p_size
    e = gen_prime(k, seed)
    while True:
        p = gen_prime(p_size, seed)
        if p % e != 1:
            break
    while True:
        q = gen_prime(q_size, seed)
        if q % e != 1:
            break
    n = p * q
    l = (p - 1) * (q - 1)
    d = modinv(e, l)
    return (int(n), int(e), int(d))","def get_bit(number: int, position: int) -> int:
    """"""
    Get the bit at the given position

    Details: perform bitwise and for the given number and X,
    Where X is a number with all the bits â€“ zeroes and bit on given position â€“ one.
    If the result is not equal to 0, then the bit on the given position is 1, else 0.

    >>> get_bit(0b1010, 0)
    0
    >>> get_bit(0b1010, 1)
    1
    >>> get_bit(0b1010, 2)
    0
    >>> get_bit(0b1010, 3)
    1
    """"""
    return int(number & 1 << position != 0)",0.5774063,0.0020559337
is_strobogrammatic2,str_eval,is_strobogrammatic2 Another implementation.,"str_eval >>> str_eval(""987654321"")
362880
>>> str_eval(""22222222"")
256","def is_strobogrammatic2(num: str):
    """"""Another implementation.""""""
    return num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')","def str_eval(s: str) -> int:
    """"""
    Returns product of digits in given string n

    >>> str_eval(""987654321"")
    362880
    >>> str_eval(""22222222"")
    256
    """"""
    product = 1
    for digit in s:
        product *= int(digit)
    return product",0.59820664,7.9125886e-05
prime_check,validate,prime_check Else return False.,"validate whose first or last three digits are not prime
>>> validate(74679)
False
>>> validate(235693)
False
>>> validate(3797)
True","def prime_check(num):
    """"""Return True if num is a prime number
    Else return False.
    """"""
    if num <= 1:
        return False
    if num == 2 or num == 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    j = 5
    while j * j <= num:
        if num % j == 0 or num % (j + 2) == 0:
            return False
        j += 6
    return True","def validate(n: int) -> bool:
    """"""
    To optimize the approach, we will rule out the numbers above 1000,
    whose first or last three digits are not prime
    >>> validate(74679)
    False
    >>> validate(235693)
    False
    >>> validate(3797)
    True
    """"""
    if len(str(n)) > 3:
        if not is_prime(int(str(n)[-3:])) or not is_prime(int(str(n)[:3])):
            return False
    return True",0.76169556,0.9971366
find_order,gcd,"find_order Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1.","gcd input: two positive integer 'number1' and 'number2'
returns the greatest common divisor of 'number1' and 'number2'","def find_order(a, n):
    """"""
    Find order for positive integer n and given integer a that satisfies gcd(a, n) = 1.
    """"""
    if (a == 1) & (n == 1):
        return 1
    if math.gcd(a, n) != 1:
        print('a and n should be relative prime!')
        return -1
    for i in range(1, n):
        if pow(a, i) % n == 1:
            return i
    return -1","def gcd(number1, number2):
    """"""
    Greatest common divisor
    input: two positive integer 'number1' and 'number2'
    returns the greatest common divisor of 'number1' and 'number2'
    """"""
    assert isinstance(number1, int) and isinstance(number2, int) and (number1 >= 0) and (number2 >= 0), ""'number1' and 'number2' must been positive integer.""
    rest = 0
    while number2 != 0:
        rest = number1 % number2
        number1 = number2
        number2 = rest
    assert isinstance(number1, int) and number1 >= 0, ""'number' must been from type int and positive""
    return number1",0.57560945,0.77926993
find_primitive_root,quadratic_roots,find_primitive_root Returns all primitive roots of n. ,"quadratic_roots calculates the roots for any quadratic equation of the form ax^2 + bx + c

>>> quadratic_roots(a=1, b=3, c=-4)
(1.0, -4.0)
>>> quadratic_roots(5, 6, 1)
(-0.2, -1.0)
>>> quadratic_roots(1, -6, 25)
((3+4j), (3-4j))","def find_primitive_root(n):
    """""" Returns all primitive roots of n. """"""
    if n == 1:
        return [0]
    phi = euler_totient(n)
    p_root_list = []
    for i in range(1, n):
        if math.gcd(i, n) != 1:
            continue
        order = find_order(i, n)
        if order == phi:
            p_root_list.append(i)
    return p_root_list","def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:
    """"""
    Given the numerical coefficients a, b and c,
    calculates the roots for any quadratic equation of the form ax^2 + bx + c

    >>> quadratic_roots(a=1, b=3, c=-4)
    (1.0, -4.0)
    >>> quadratic_roots(5, 6, 1)
    (-0.2, -1.0)
    >>> quadratic_roots(1, -6, 25)
    ((3+4j), (3-4j))
    """"""
    if a == 0:
        raise ValueError(""Coefficient 'a' must not be zero."")
    delta = b * b - 4 * a * c
    root_1 = (-b + sqrt(delta)) / (2 * a)
    root_2 = (-b - sqrt(delta)) / (2 * a)
    return (root_1.real if not root_1.imag else root_1, root_2.real if not root_2.imag else root_2)",0.538656,0.018824322
factorial,pollard_rho,"factorial If mod is not None, then return (n! % mod)
Time Complexity - O(n)","pollard_rho The returned factor may be composite and require further factorization.
If the algorithm will return None if it fails to find a factor within
the specified number of attempts or within the specified number of steps.
If ``num`` is prime, this algorithm is guaranteed to return None.
https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm

>>> pollard_rho(18446744073709551617)
274177
>>> pollard_rho(97546105601219326301)
9876543191
>>> pollard_rho(100)
2
>>> pollard_rho(17)
>>> pollard_rho(17**3)
17
>>> pollard_rho(17**3, attempts=1)
>>> pollard_rho(3*5*7)
21
>>> pollard_rho(1)
Traceback (most recent call last):
    ...
ValueError: The input value cannot be less than 2","def factorial(n, mod=None):
    """"""Calculates factorial iteratively.
    If mod is not None, then return (n! % mod)
    Time Complexity - O(n)""""""
    if not (isinstance(n, int) and n >= 0):
        raise ValueError(""'n' must be a non-negative integer."")
    if mod is not None and (not (isinstance(mod, int) and mod > 0)):
        raise ValueError(""'mod' must be a positive integer"")
    result = 1
    if n == 0:
        return 1
    for i in range(2, n + 1):
        result *= i
        if mod:
            result %= mod
    return result","def pollard_rho(num: int, seed: int=2, step: int=1, attempts: int=3) -> int | None:
    """"""
    Use Pollard's Rho algorithm to return a nontrivial factor of ``num``.
    The returned factor may be composite and require further factorization.
    If the algorithm will return None if it fails to find a factor within
    the specified number of attempts or within the specified number of steps.
    If ``num`` is prime, this algorithm is guaranteed to return None.
    https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm

    >>> pollard_rho(18446744073709551617)
    274177
    >>> pollard_rho(97546105601219326301)
    9876543191
    >>> pollard_rho(100)
    2
    >>> pollard_rho(17)
    >>> pollard_rho(17**3)
    17
    >>> pollard_rho(17**3, attempts=1)
    >>> pollard_rho(3*5*7)
    21
    >>> pollard_rho(1)
    Traceback (most recent call last):
        ...
    ValueError: The input value cannot be less than 2
    """"""
    if num < 2:
        raise ValueError('The input value cannot be less than 2')
    if num > 2 and num % 2 == 0:
        return 2

    def rand_fn(value: int, step: int, modulus: int) -> int:
        """"""
        Returns a pseudorandom value modulo ``modulus`` based on the
        input ``value`` and attempt-specific ``step`` size.

        >>> rand_fn(0, 0, 0)
        Traceback (most recent call last):
            ...
        ZeroDivisionError: integer division or modulo by zero
        >>> rand_fn(1, 2, 3)
        0
        >>> rand_fn(0, 10, 7)
        3
        >>> rand_fn(1234, 1, 17)
        16
        """"""
        return (pow(value, 2) + step) % modulus
    for _ in range(attempts):
        tortoise = seed
        hare = seed
        while True:
            tortoise = rand_fn(tortoise, step, num)
            hare = rand_fn(hare, step, num)
            hare = rand_fn(hare, step, num)
            divisor = gcd(hare - tortoise, num)
            if divisor == 1:
                continue
            elif divisor == num:
                break
            else:
                return divisor
        seed = hare
        step += 1
    return None",0.6027756,0.08018935
factorial_recur,factorial_recursive,"factorial_recur If mod is not None, then return (n! % mod)
Time Complexity - O(n)","factorial_recursive https://en.wikipedia.org/wiki/Factorial

>>> import math
>>> all(factorial(i) == math.factorial(i) for i in range(20))
True
>>> factorial(0.1)
Traceback (most recent call last):
    ...
ValueError: factorial() only accepts integral values
>>> factorial(-1)
Traceback (most recent call last):
    ...
ValueError: factorial() not defined for negative values","def factorial_recur(n, mod=None):
    """"""Calculates factorial recursively.
    If mod is not None, then return (n! % mod)
    Time Complexity - O(n)""""""
    if not (isinstance(n, int) and n >= 0):
        raise ValueError(""'n' must be a non-negative integer."")
    if mod is not None and (not (isinstance(mod, int) and mod > 0)):
        raise ValueError(""'mod' must be a positive integer"")
    if n == 0:
        return 1
    result = n * factorial(n - 1, mod)
    if mod:
        result %= mod
    return result","def factorial_recursive(n: int) -> int:
    """"""
    Calculate the factorial of a positive integer
    https://en.wikipedia.org/wiki/Factorial

    >>> import math
    >>> all(factorial(i) == math.factorial(i) for i in range(20))
    True
    >>> factorial(0.1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() only accepts integral values
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() not defined for negative values
    """"""
    if not isinstance(n, int):
        raise ValueError('factorial() only accepts integral values')
    if n < 0:
        raise ValueError('factorial() not defined for negative values')
    return 1 if n == 0 or n == 1 else n * factorial(n - 1)",0.64831614,0.9990073
find_nth_digit,get_digits,"find_nth_digit 1. find the length of the number where the nth digit is from.
2. find the actual number where the nth digit is from
3. find the nth digit and return","get_digits >>> get_digits(3)
'27'
>>> get_digits(99)
'027999'
>>> get_digits(123)
'0166788'","def find_nth_digit(n):
    """"""find the nth digit of given number.
    1. find the length of the number where the nth digit is from.
    2. find the actual number where the nth digit is from
    3. find the nth digit and return
    """"""
    length = 1
    count = 9
    start = 1
    while n > length * count:
        n -= length * count
        length += 1
        count *= 10
        start *= 10
    start += (n - 1) / length
    s = str(start)
    return int(s[(n - 1) % length])","def get_digits(num: int) -> str:
    """"""
    Computes the sorted sequence of digits of the cube of num.

    >>> get_digits(3)
    '27'
    >>> get_digits(99)
    '027999'
    >>> get_digits(123)
    '0166788'
    """"""
    return ''.join(sorted(str(num ** 3)))",0.6294083,0.0011959398
cycle_product,vol_spheres_union,"cycle_product cycle index of a symmetry group),
compute the resultant monomial
in the cartesian product
corresponding to their merging.","vol_spheres_union It is the sum of sphere A and sphere B minus their intersection.
First, it calculates the volumes (v1, v2) of the spheres,
then the volume of the intersection (i) and it returns the sum v1+v2-i.
If centers_distance is 0 then it returns the volume of the larger sphere
:return vol_sphere(radius_1) + vol_sphere(radius_2)
            - vol_spheres_intersect(radius_1, radius_2, centers_distance)

>>> vol_spheres_union(2, 2, 1)
45.814892864851146
>>> vol_spheres_union(1.56, 2.2, 1.4)
48.77802773671288
>>> vol_spheres_union(0, 2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius
>>> vol_spheres_union('1.56', '2.2', '1.4')
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'str' and 'int'
>>> vol_spheres_union(1, None, 1)
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'NoneType' and 'int'","def cycle_product(m1: Monomial, m2: Monomial) -> Monomial:
    """"""
    Given two monomials (from the
    cycle index of a symmetry group),
    compute the resultant monomial
    in the cartesian product
    corresponding to their merging.
    """"""
    assert isinstance(m1, Monomial) and isinstance(m2, Monomial)
    A = m1.variables
    B = m2.variables
    result_variables = dict()
    for i in A:
        for j in B:
            k = lcm(i, j)
            g = i * j // k
            if k in result_variables:
                result_variables[k] += A[i] * B[j] * g
            else:
                result_variables[k] = A[i] * B[j] * g
    return Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))","def vol_spheres_union(radius_1: float, radius_2: float, centers_distance: float) -> float:
    """"""
    Calculate the volume of the union of two spheres that possibly intersect.
    It is the sum of sphere A and sphere B minus their intersection.
    First, it calculates the volumes (v1, v2) of the spheres,
    then the volume of the intersection (i) and it returns the sum v1+v2-i.
    If centers_distance is 0 then it returns the volume of the larger sphere
    :return vol_sphere(radius_1) + vol_sphere(radius_2)
                - vol_spheres_intersect(radius_1, radius_2, centers_distance)

    >>> vol_spheres_union(2, 2, 1)
    45.814892864851146
    >>> vol_spheres_union(1.56, 2.2, 1.4)
    48.77802773671288
    >>> vol_spheres_union(0, 2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius
    >>> vol_spheres_union('1.56', '2.2', '1.4')
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'str' and 'int'
    >>> vol_spheres_union(1, None, 1)
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'NoneType' and 'int'
    """"""
    if radius_1 <= 0 or radius_2 <= 0 or centers_distance < 0:
        raise ValueError('vol_spheres_union() only accepts non-negative values, non-zero radius')
    if centers_distance == 0:
        return vol_sphere(max(radius_1, radius_2))
    return vol_sphere(radius_1) + vol_sphere(radius_2) - vol_spheres_intersect(radius_1, radius_2, centers_distance)",0.5354599,0.0013721714
cycle_product_for_two_polynomials,cramers_rule_2x2,"cycle_product_for_two_polynomials given cycle indices p1,
and p2 and evaluate it at q.","cramers_rule_2x2 :param: equation1: list of 3 numbers
:param: equation2: list of 3 numbers
:return: String of result
input format : [a1, b1, d1], [a2, b2, d2]
determinant = [[a1, b1], [a2, b2]]
determinant_x = [[d1, b1], [d2, b2]]
determinant_y = [[a1, d1], [a2, d2]]

>>> cramers_rule_2x2([2, 3, 0], [5, 1, 0])
(0.0, 0.0)
>>> cramers_rule_2x2([0, 4, 50], [2, 0, 26])
(13.0, 12.5)
>>> cramers_rule_2x2([11, 2, 30], [1, 0, 4])
(4.0, -7.0)
>>> cramers_rule_2x2([4, 7, 1], [1, 2, 0])
(2.0, -1.0)

>>> cramers_rule_2x2([1, 2, 3], [2, 4, 6])
Traceback (most recent call last):
    ...
ValueError: Infinite solutions. (Consistent system)
>>> cramers_rule_2x2([1, 2, 3], [2, 4, 7])
Traceback (most recent call last):
    ...
ValueError: No solution. (Inconsistent system)
>>> cramers_rule_2x2([1, 2, 3], [11, 22])
Traceback (most recent call last):
    ...
ValueError: Please enter a valid equation.
>>> cramers_rule_2x2([0, 1, 6], [0, 0, 3])
Traceback (most recent call last):
    ...
ValueError: No solution. (Inconsistent system)
>>> cramers_rule_2x2([0, 0, 6], [0, 0, 3])
Traceback (most recent call last):
    ...
ValueError: Both a & b of two equations can't be zero.
>>> cramers_rule_2x2([1, 2, 3], [1, 2, 3])
Traceback (most recent call last):
    ...
ValueError: Infinite solutions. (Consistent system)
>>> cramers_rule_2x2([0, 4, 50], [0, 3, 99])
Traceback (most recent call last):
    ...
ValueError: No solution. (Inconsistent system)","def cycle_product_for_two_polynomials(p1: Polynomial, p2: Polynomial, q: Union[float, int, Fraction]) -> Union[float, int, Fraction]:
    """"""
    Compute the product of
    given cycle indices p1,
    and p2 and evaluate it at q.
    """"""
    ans = Fraction(0, 1)
    for m1 in p1.monomials:
        for m2 in p2.monomials:
            ans += cycle_product(m1, m2).substitute(q)
    return ans","def cramers_rule_2x2(equation1: list[int], equation2: list[int]) -> tuple[float, float]:
    """"""
    Solves the system of linear equation in 2 variables.
    :param: equation1: list of 3 numbers
    :param: equation2: list of 3 numbers
    :return: String of result
    input format : [a1, b1, d1], [a2, b2, d2]
    determinant = [[a1, b1], [a2, b2]]
    determinant_x = [[d1, b1], [d2, b2]]
    determinant_y = [[a1, d1], [a2, d2]]

    >>> cramers_rule_2x2([2, 3, 0], [5, 1, 0])
    (0.0, 0.0)
    >>> cramers_rule_2x2([0, 4, 50], [2, 0, 26])
    (13.0, 12.5)
    >>> cramers_rule_2x2([11, 2, 30], [1, 0, 4])
    (4.0, -7.0)
    >>> cramers_rule_2x2([4, 7, 1], [1, 2, 0])
    (2.0, -1.0)

    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 6])
    Traceback (most recent call last):
        ...
    ValueError: Infinite solutions. (Consistent system)
    >>> cramers_rule_2x2([1, 2, 3], [2, 4, 7])
    Traceback (most recent call last):
        ...
    ValueError: No solution. (Inconsistent system)
    >>> cramers_rule_2x2([1, 2, 3], [11, 22])
    Traceback (most recent call last):
        ...
    ValueError: Please enter a valid equation.
    >>> cramers_rule_2x2([0, 1, 6], [0, 0, 3])
    Traceback (most recent call last):
        ...
    ValueError: No solution. (Inconsistent system)
    >>> cramers_rule_2x2([0, 0, 6], [0, 0, 3])
    Traceback (most recent call last):
        ...
    ValueError: Both a & b of two equations can't be zero.
    >>> cramers_rule_2x2([1, 2, 3], [1, 2, 3])
    Traceback (most recent call last):
        ...
    ValueError: Infinite solutions. (Consistent system)
    >>> cramers_rule_2x2([0, 4, 50], [0, 3, 99])
    Traceback (most recent call last):
        ...
    ValueError: No solution. (Inconsistent system)
    """"""
    if not len(equation1) == len(equation2) == 3:
        raise ValueError('Please enter a valid equation.')
    if equation1[0] == equation1[1] == equation2[0] == equation2[1] == 0:
        raise ValueError(""Both a & b of two equations can't be zero."")
    (a1, b1, c1) = equation1
    (a2, b2, c2) = equation2
    determinant = a1 * b2 - a2 * b1
    determinant_x = c1 * b2 - c2 * b1
    determinant_y = a1 * c2 - a2 * c1
    if determinant == 0:
        if determinant_x == determinant_y == 0:
            raise ValueError('Infinite solutions. (Consistent system)')
        else:
            raise ValueError('No solution. (Inconsistent system)')
    elif determinant_x == determinant_y == 0:
        return (0.0, 0.0)
    else:
        x = determinant_x / determinant
        y = determinant_y / determinant
        return (x, y)",0.50067055,0.67513394
cycle_index_sym_helper,hamilton_cycle,"cycle_index_sym_helper of the cycle index.

The recurrence is given in:
https://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn","hamilton_cycle which will either return array of vertices indicating hamiltonian cycle
or an empty list indicating that hamiltonian cycle was not found.
Case 1:
Following graph consists of 5 edges.
If we look closely, we can see that there are multiple Hamiltonian cycles.
For example one result is when we iterate like:
(0)->(1)->(2)->(4)->(3)->(0)

(0)---(1)---(2)
 |   /   \   |
 |  /     \  |
 | /       \ |
 |/         \|
(3)---------(4)
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> hamilton_cycle(graph)
[0, 1, 2, 4, 3, 0]

Case 2:
Same Graph as it was in Case 1, changed starting index from default to 3

(0)---(1)---(2)
 |   /   \   |
 |  /     \  |
 | /       \ |
 |/         \|
(3)---------(4)
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> hamilton_cycle(graph, 3)
[3, 0, 1, 2, 4, 3]

Case 3:
Following Graph is exactly what it was before, but edge 3-4 is removed.
Result is that there is no Hamiltonian Cycle anymore.

(0)---(1)---(2)
 |   /   \   |
 |  /     \  |
 | /       \ |
 |/         \|
(3)         (4)
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 0],
...          [0, 1, 1, 0, 0]]
>>> hamilton_cycle(graph,4)
[]","def cycle_index_sym_helper(n: int, memo: Dict[int, Polynomial]) -> Polynomial:
    """"""
    A helper for the dp-style evaluation
    of the cycle index.

    The recurrence is given in:
    https://en.wikipedia.org/wiki/Cycle_index#Symmetric_group_Sn

    """"""
    if n in memo:
        return memo[n]
    ans = Polynomial([Monomial({}, Fraction(0, 1))])
    for t in range(1, n + 1):
        ans = ans.__add__(Polynomial([Monomial({t: 1}, Fraction(1, 1))]) * cycle_index_sym_helper(n - t, memo))
    ans *= Fraction(1, n)
    memo[n] = ans
    return memo[n]","def hamilton_cycle(graph: list[list[int]], start_index: int=0) -> list[int]:
    """"""
    Wrapper function to call subroutine called util_hamilton_cycle,
    which will either return array of vertices indicating hamiltonian cycle
    or an empty list indicating that hamiltonian cycle was not found.
    Case 1:
    Following graph consists of 5 edges.
    If we look closely, we can see that there are multiple Hamiltonian cycles.
    For example one result is when we iterate like:
    (0)->(1)->(2)->(4)->(3)->(0)

    (0)---(1)---(2)
     |   /   \\   |
     |  /     \\  |
     | /       \\ |
     |/         \\|
    (3)---------(4)
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> hamilton_cycle(graph)
    [0, 1, 2, 4, 3, 0]

    Case 2:
    Same Graph as it was in Case 1, changed starting index from default to 3

    (0)---(1)---(2)
     |   /   \\   |
     |  /     \\  |
     | /       \\ |
     |/         \\|
    (3)---------(4)
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> hamilton_cycle(graph, 3)
    [3, 0, 1, 2, 4, 3]

    Case 3:
    Following Graph is exactly what it was before, but edge 3-4 is removed.
    Result is that there is no Hamiltonian Cycle anymore.

    (0)---(1)---(2)
     |   /   \\   |
     |  /     \\  |
     | /       \\ |
     |/         \\|
    (3)         (4)
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 0],
    ...          [0, 1, 1, 0, 0]]
    >>> hamilton_cycle(graph,4)
    []
    """"""
    path = [-1] * (len(graph) + 1)
    path[0] = path[-1] = start_index
    return path if util_hamilton_cycle(graph, path, 1) else []",0.59339106,0.9434885
get_cycle_index_sym,generate_parameters,"get_cycle_index_sym of S_n, i.e. the symmetry
group of n symbols.","generate_parameters A symbol is the uncomplemented form of a literal.
For example,
    Symbol of A3 is A3.
    Symbol of A5' is A5.

>>> formula = Formula([Clause([""A1"", ""A2'"", ""A3""]), Clause([""A5'"", ""A2'"", ""A1""])])
>>> clauses, symbols = generate_parameters(formula)
>>> clauses_list = [str(i) for i in clauses]
>>> clauses_list
[""{A1 , A2' , A3}"", ""{A5' , A2' , A1}""]
>>> symbols
['A1', 'A2', 'A3', 'A5']","def get_cycle_index_sym(n: int) -> Polynomial:
    """"""
    Compute the cycle index
    of S_n, i.e. the symmetry
    group of n symbols.

    """"""
    if n < 0:
        raise ValueError('n should be a non-negative integer.')
    memo = {0: Polynomial([Monomial({}, Fraction(1, 1))]), 1: Polynomial([Monomial({1: 1}, Fraction(1, 1))]), 2: Polynomial([Monomial({1: 2}, Fraction(1, 2)), Monomial({2: 1}, Fraction(1, 2))]), 3: Polynomial([Monomial({1: 3}, Fraction(1, 6)), Monomial({1: 1, 2: 1}, Fraction(1, 2)), Monomial({3: 1}, Fraction(1, 3))]), 4: Polynomial([Monomial({1: 4}, Fraction(1, 24)), Monomial({2: 1, 1: 2}, Fraction(1, 4)), Monomial({3: 1, 1: 1}, Fraction(1, 3)), Monomial({2: 2}, Fraction(1, 8)), Monomial({4: 1}, Fraction(1, 4))])}
    result = cycle_index_sym_helper(n, memo)
    return result","def generate_parameters(formula: Formula) -> tuple[list[Clause], list[str]]:
    """"""
    Return the clauses and symbols from a formula.
    A symbol is the uncomplemented form of a literal.
    For example,
        Symbol of A3 is A3.
        Symbol of A5' is A5.

    >>> formula = Formula([Clause([""A1"", ""A2'"", ""A3""]), Clause([""A5'"", ""A2'"", ""A1""])])
    >>> clauses, symbols = generate_parameters(formula)
    >>> clauses_list = [str(i) for i in clauses]
    >>> clauses_list
    [""{A1 , A2' , A3}"", ""{A5' , A2' , A1}""]
    >>> symbols
    ['A1', 'A2', 'A3', 'A5']
    """"""
    clauses = formula.clauses
    symbols_set = []
    for clause in formula.clauses:
        for literal in clause.literals:
            symbol = literal[:2]
            if symbol not in symbols_set:
                symbols_set.append(symbol)
    return (clauses, symbols_set)",0.48985037,0.82982147
alice_private_key,decrypt,"alice_private_key in the range of 1 ~ p-1.
This must be kept in secret","decrypt Decryption using Key #0: TMDETUX PMDVU
Decryption using Key #1: SLCDSTW OLCUT
Decryption using Key #2: RKBCRSV NKBTS
Decryption using Key #3: QJABQRU MJASR
Decryption using Key #4: PIZAPQT LIZRQ
Decryption using Key #5: OHYZOPS KHYQP
Decryption using Key #6: NGXYNOR JGXPO
Decryption using Key #7: MFWXMNQ IFWON
Decryption using Key #8: LEVWLMP HEVNM
Decryption using Key #9: KDUVKLO GDUML
Decryption using Key #10: JCTUJKN FCTLK
Decryption using Key #11: IBSTIJM EBSKJ
Decryption using Key #12: HARSHIL DARJI
Decryption using Key #13: GZQRGHK CZQIH
Decryption using Key #14: FYPQFGJ BYPHG
Decryption using Key #15: EXOPEFI AXOGF
Decryption using Key #16: DWNODEH ZWNFE
Decryption using Key #17: CVMNCDG YVMED
Decryption using Key #18: BULMBCF XULDC
Decryption using Key #19: ATKLABE WTKCB
Decryption using Key #20: ZSJKZAD VSJBA
Decryption using Key #21: YRIJYZC URIAZ
Decryption using Key #22: XQHIXYB TQHZY
Decryption using Key #23: WPGHWXA SPGYX
Decryption using Key #24: VOFGVWZ ROFXW
Decryption using Key #25: UNEFUVY QNEWV","def alice_private_key(p):
    """"""Alice determine her private key
    in the range of 1 ~ p-1.
    This must be kept in secret""""""
    return randint(1, p - 1)","def decrypt(message: str) -> None:
    """"""
    >>> decrypt('TMDETUX PMDVU')
    Decryption using Key #0: TMDETUX PMDVU
    Decryption using Key #1: SLCDSTW OLCUT
    Decryption using Key #2: RKBCRSV NKBTS
    Decryption using Key #3: QJABQRU MJASR
    Decryption using Key #4: PIZAPQT LIZRQ
    Decryption using Key #5: OHYZOPS KHYQP
    Decryption using Key #6: NGXYNOR JGXPO
    Decryption using Key #7: MFWXMNQ IFWON
    Decryption using Key #8: LEVWLMP HEVNM
    Decryption using Key #9: KDUVKLO GDUML
    Decryption using Key #10: JCTUJKN FCTLK
    Decryption using Key #11: IBSTIJM EBSKJ
    Decryption using Key #12: HARSHIL DARJI
    Decryption using Key #13: GZQRGHK CZQIH
    Decryption using Key #14: FYPQFGJ BYPHG
    Decryption using Key #15: EXOPEFI AXOGF
    Decryption using Key #16: DWNODEH ZWNFE
    Decryption using Key #17: CVMNCDG YVMED
    Decryption using Key #18: BULMBCF XULDC
    Decryption using Key #19: ATKLABE WTKCB
    Decryption using Key #20: ZSJKZAD VSJBA
    Decryption using Key #21: YRIJYZC URIAZ
    Decryption using Key #22: XQHIXYB TQHZY
    Decryption using Key #23: WPGHWXA SPGYX
    Decryption using Key #24: VOFGVWZ ROFXW
    Decryption using Key #25: UNEFUVY QNEWV
    """"""
    for key in range(len(string.ascii_uppercase)):
        translated = ''
        for symbol in message:
            if symbol in string.ascii_uppercase:
                num = string.ascii_uppercase.find(symbol)
                num = num - key
                if num < 0:
                    num = num + len(string.ascii_uppercase)
                translated = translated + string.ascii_uppercase[num]
            else:
                translated = translated + symbol
        print(f'Decryption using Key #{key}: {translated}')",0.48719823,0.93128866
alice_public_key,try_key,"alice_public_key with her private key.
This is open to public","try_key If the decrypted message contains a invalid character, i.e. not an ASCII letter,
a digit, punctuation or whitespace, then we know the key is incorrect, so return
None.
>>> try_key([0, 17, 20, 4, 27], (104, 116, 120))
'hello'
>>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None
True","def alice_public_key(a_pr_k, a, p):
    """"""Alice calculate her public key
    with her private key.
    This is open to public""""""
    return pow(a, a_pr_k) % p","def try_key(ciphertext: list[int], key: tuple[int, ...]) -> str | None:
    """"""
    Given an encrypted message and a possible 3-character key, decrypt the message.
    If the decrypted message contains a invalid character, i.e. not an ASCII letter,
    a digit, punctuation or whitespace, then we know the key is incorrect, so return
    None.
    >>> try_key([0, 17, 20, 4, 27], (104, 116, 120))
    'hello'
    >>> try_key([68, 10, 300, 4, 27], (104, 116, 120)) is None
    True
    """"""
    decoded: str = ''
    keychar: int
    cipherchar: int
    decodedchar: int
    for (keychar, cipherchar) in zip(cycle(key), ciphertext):
        decodedchar = cipherchar ^ keychar
        if decodedchar not in VALID_INTS:
            return None
        decoded += chr(decodedchar)
    return decoded",0.4232089,0.0030486984
bob_private_key,cipher_text,"bob_private_key in the range of 1 ~ p-1.
This must be kept in secret",cipher_text 'BDC PAYUWL JPAIYI',"def bob_private_key(p):
    """"""Bob determine his private key
    in the range of 1 ~ p-1.
    This must be kept in secret""""""
    return randint(1, p - 1)","def cipher_text(message: str, key_new: str) -> str:
    """"""
    >>> cipher_text(""THE GERMAN ATTACK"",""SECRETSECRETSECRE"")
    'BDC PAYUWL JPAIYI'
    """"""
    cipher_text = ''
    i = 0
    for letter in message:
        if letter == ' ':
            cipher_text += ' '
        else:
            x = (dict1[letter] - dict1[key_new[i]]) % 26
            i += 1
            cipher_text += dict2[x]
    return cipher_text",0.47378993,8.2221726e-05
bob_public_key,create_cipher_map,"bob_public_key with his private key.
This is open to public",create_cipher_map Returns a cipher map given a keyword.,"def bob_public_key(b_pr_k, a, p):
    """"""Bob calculate his public key
    with his private key.
    This is open to public""""""
    return pow(a, b_pr_k) % p","def create_cipher_map(key: str) -> dict[str, str]:
    """"""
    Returns a cipher map given a keyword.
    :param key: keyword to use
    :return: dictionary cipher map
    """"""
    alphabet = [chr(i + 65) for i in range(26)]
    key = remove_duplicates(key.upper())
    offset = len(key)
    cipher_alphabet = {alphabet[i]: char for (i, char) in enumerate(key)}
    for i in range(len(cipher_alphabet), 26):
        char = alphabet[i - offset]
        while char in key:
            offset -= 1
            char = alphabet[i - offset]
        cipher_alphabet[alphabet[i]] = char
    return cipher_alphabet",0.4294472,0.0011158505
alice_shared_key,dencrypt,"alice_shared_key with her private key and Bob's public key.
This must be kept in secret","dencrypt >>> msg = ""My secret bank account number is 173-52946 so don't tell anyone!!""
>>> s = dencrypt(msg)
>>> s
""Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!""
>>> dencrypt(s) == msg
True","def alice_shared_key(b_pu_k, a_pr_k, p):
    """""" Alice calculate secret key shared with Bob,
    with her private key and Bob's public key.
    This must be kept in secret""""""
    return pow(b_pu_k, a_pr_k) % p","def dencrypt(s: str, n: int=13) -> str:
    """"""
    https://en.wikipedia.org/wiki/ROT13

    >>> msg = ""My secret bank account number is 173-52946 so don't tell anyone!!""
    >>> s = dencrypt(msg)
    >>> s
    ""Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!""
    >>> dencrypt(s) == msg
    True
    """"""
    out = ''
    for c in s:
        if 'A' <= c <= 'Z':
            out += chr(ord('A') + (ord(c) - ord('A') + n) % 26)
        elif 'a' <= c <= 'z':
            out += chr(ord('a') + (ord(c) - ord('a') + n) % 26)
        else:
            out += c
    return out",0.40887195,0.0006100789
bob_shared_key,rsafactor,"bob_shared_key with his private key and Alice's public key.
This must be kept in secret","rsafactor Return: [p, q]

We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.
The pair (N, e) is the public key. As its name suggests, it is public and is used to
    encrypt messages.
The pair (N, d) is the secret key or private key and is known only to the recipient
    of encrypted messages.

>>> rsafactor(3, 16971, 25777)
[149, 173]
>>> rsafactor(7331, 11, 27233)
[113, 241]
>>> rsafactor(4021, 13, 17711)
[89, 199]","def bob_shared_key(a_pu_k, b_pr_k, p):
    """""" Bob calculate secret key shared with Alice,
    with his private key and Alice's public key.
    This must be kept in secret""""""
    return pow(a_pu_k, b_pr_k) % p","def rsafactor(d: int, e: int, n: int) -> list[int]:
    """"""
    This function returns the factors of N, where p*q=N
      Return: [p, q]

    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.
    The pair (N, e) is the public key. As its name suggests, it is public and is used to
        encrypt messages.
    The pair (N, d) is the secret key or private key and is known only to the recipient
        of encrypted messages.

    >>> rsafactor(3, 16971, 25777)
    [149, 173]
    >>> rsafactor(7331, 11, 27233)
    [113, 241]
    >>> rsafactor(4021, 13, 17711)
    [89, 199]
    """"""
    k = d * e - 1
    p = 0
    q = 0
    while p == 0:
        g = random.randint(2, n - 1)
        t = k
        while True:
            if t % 2 == 0:
                t = t // 2
                x = g ** t % n
                y = math.gcd(x - 1, n)
                if x > 1 and y > 1:
                    p = y
                    q = n // y
                    break
            else:
                break
    return sorted([p, q])",0.48605675,0.47413886
diffie_hellman_key_exchange,enigma,diffie_hellman_key_exchange Perform diffie-helmman key exchange. ,"enigma All characters are converted to uppercase. (non-letter symbol are ignored)
How it works:
(for every letter in the message)

- Input letter goes into the plugboard.
If it is connected to another one, switch it.

- Letter goes through 3 rotors.
Each rotor can be represented as 2 sets of symbol, where one is shuffled.
Each symbol from the first set has corresponding symbol in
the second set and vice versa.

example:
| ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F
| VKLEPDBGRNWTFCJOHQAMUZYIXS |

- Symbol then goes through reflector (static rotor).
There it is switched with paired symbol
The reflector can be represented as2 sets, each with half of the alphanet.
There are usually 10 pairs of letters.

Example:
| ABCDEFGHIJKLM | e.g. E is paired to X
| ZYXWVUTSRQPON | so when E goes in X goes out and vice versa

- Letter then goes through the rotors again

- If the letter is connected to plugboard, it is switched.

- Return the letter

>>> enigma('Hello World!', (1, 2, 1), plugb='pictures')
'KORYH JUHHI!'
>>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')
'HELLO, WORLD!'
>>> enigma('hello world!', (1, 1, 1), plugb='pictures')
'FPNCZ QWOBU!'
>>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')
'HELLO WORLD'","def diffie_hellman_key_exchange(a, p, option=None):
    """""" Perform diffie-helmman key exchange. """"""
    if option is not None:
        option = 1
    if prime_check(p) is False:
        print(f'{p} is not a prime number')
        return False
    try:
        p_root_list = find_primitive_root(p)
        p_root_list.index(a)
    except ValueError:
        print(f'{a} is not a primitive root of {p}')
        return False
    a_pr_k = alice_private_key(p)
    a_pu_k = alice_public_key(a_pr_k, a, p)
    b_pr_k = bob_private_key(p)
    b_pu_k = bob_public_key(b_pr_k, a, p)
    if option == 1:
        print(f""Alice's private key: {a_pr_k}"")
        print(f""Alice's public key: {a_pu_k}"")
        print(f""Bob's private key: {b_pr_k}"")
        print(f""Bob's public key: {b_pu_k}"")
    a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p)
    b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p)
    print(f'Shared key calculated by Alice = {a_sh_k}')
    print(f'Shared key calculated by Bob = {b_sh_k}')
    return a_sh_k == b_sh_k","def enigma(text: str, rotor_position: RotorPositionT, rotor_selection: RotorSelectionT=(rotor1, rotor2, rotor3), plugb: str='') -> str:
    """"""
    The only difference with real-world enigma is that I allowed string input.
    All characters are converted to uppercase. (non-letter symbol are ignored)
    How it works:
    (for every letter in the message)

    - Input letter goes into the plugboard.
    If it is connected to another one, switch it.

    - Letter goes through 3 rotors.
    Each rotor can be represented as 2 sets of symbol, where one is shuffled.
    Each symbol from the first set has corresponding symbol in
    the second set and vice versa.

    example:
    | ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F
    | VKLEPDBGRNWTFCJOHQAMUZYIXS |

    - Symbol then goes through reflector (static rotor).
    There it is switched with paired symbol
    The reflector can be represented as2 sets, each with half of the alphanet.
    There are usually 10 pairs of letters.

    Example:
    | ABCDEFGHIJKLM | e.g. E is paired to X
    | ZYXWVUTSRQPON | so when E goes in X goes out and vice versa

    - Letter then goes through the rotors again

    - If the letter is connected to plugboard, it is switched.

    - Return the letter

    >>> enigma('Hello World!', (1, 2, 1), plugb='pictures')
    'KORYH JUHHI!'
    >>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')
    'HELLO, WORLD!'
    >>> enigma('hello world!', (1, 1, 1), plugb='pictures')
    'FPNCZ QWOBU!'
    >>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')
    'HELLO WORLD'


    :param text: input message
    :param rotor_position: tuple with 3 values in range 1..26
    :param rotor_selection: tuple with 3 rotors ()
    :param plugb: string containing plugboard configuration (default '')
    :return: en/decrypted string
    """"""
    text = text.upper()
    (rotor_position, rotor_selection, plugboard) = _validator(rotor_position, rotor_selection, plugb.upper())
    (rotorpos1, rotorpos2, rotorpos3) = rotor_position
    (rotor1, rotor2, rotor3) = rotor_selection
    rotorpos1 -= 1
    rotorpos2 -= 1
    rotorpos3 -= 1
    result = []
    for symbol in text:
        if symbol in abc:
            if symbol in plugboard:
                symbol = plugboard[symbol]
            index = abc.index(symbol) + rotorpos1
            symbol = rotor1[index % len(abc)]
            index = abc.index(symbol) + rotorpos2
            symbol = rotor2[index % len(abc)]
            index = abc.index(symbol) + rotorpos3
            symbol = rotor3[index % len(abc)]
            symbol = reflector[symbol]
            symbol = abc[rotor3.index(symbol) - rotorpos3]
            symbol = abc[rotor2.index(symbol) - rotorpos2]
            symbol = abc[rotor1.index(symbol) - rotorpos1]
            if symbol in plugboard:
                symbol = plugboard[symbol]
            rotorpos1 += 1
            if rotorpos1 >= len(abc):
                rotorpos1 = 0
                rotorpos2 += 1
            if rotorpos2 >= len(abc):
                rotorpos2 = 0
                rotorpos3 += 1
            if rotorpos3 >= len(abc):
                rotorpos3 = 0
        result.append(symbol)
    return ''.join(result)",0.44508514,0.9717675
hailstone,peak,hailstone n: The starting point of the hailstone sequence,"peak >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])
5
>>> peak([1, 10, 9, 8, 7, 6, 5, 4])
10
>>> peak([1, 9, 8, 7])
9
>>> peak([1, 2, 3, 4, 5, 6, 7, 0])
7
>>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])
4","def hailstone(n):
    """"""
    Return the 'hailstone sequence' from n to 1
    n: The starting point of the hailstone sequence
    """"""
    sequence = [n]
    while n > 1:
        if n % 2 != 0:
            n = 3 * n + 1
        else:
            n = int(n / 2)
        sequence.append(n)
    return sequence","def peak(lst: list[int]) -> int:
    """"""
    Return the peak value of `lst`.
    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])
    5
    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])
    10
    >>> peak([1, 9, 8, 7])
    9
    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])
    7
    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])
    4
    """"""
    m = len(lst) // 2
    three = lst[m - 1:m + 2]
    if three[1] > three[0] and three[1] > three[2]:
        return three[1]
    elif three[0] < three[2]:
        if len(lst[:m]) == 2:
            m -= 1
        return peak(lst[m:])
    else:
        if len(lst[:m]) == 2:
            m += 1
        return peak(lst[:m])",0.41847324,0.98689866
square_root,mean_absolute_error,"square_root Return square root of n, with maximum absolute error epsilon",mean_absolute_error Return sum of square error for error calculation,"def square_root(n, epsilon=0.001):
    """"""Return square root of n, with maximum absolute error epsilon""""""
    guess = n / 2
    while abs(guess * guess - n) > epsilon:
        guess = (guess + n / guess) / 2
    return guess","def mean_absolute_error(predicted_y, original_y):
    """"""Return sum of square error for error calculation
    :param predicted_y   : contains the output of prediction (result vector)
    :param original_y    : contains values of expected outcome
    :return          : mean absolute error computed from given feature's
    """"""
    total = sum((abs(y - predicted_y[i]) for (i, y) in enumerate(original_y)))
    return total / len(original_y)",0.68318397,0.98430705
combination,rayleigh_quotient,combination This function calculates nCr.,"rayleigh_quotient vector v.
>>> import numpy as np
>>> A = np.array([
... [1,  2, 4],
... [2,  3,  -1],
... [4, -1,  1]
... ])
>>> v = np.array([
... [1],
... [2],
... [3]
... ])
>>> rayleigh_quotient(A, v)
array([[3.]])","def combination(n, r):
    """"""This function calculates nCr.""""""
    if n == r or r == 0:
        return 1
    return combination(n - 1, r - 1) + combination(n - 1, r)","def rayleigh_quotient(a: np.ndarray, v: np.ndarray) -> Any:
    """"""
    Returns the Rayleigh quotient of a Hermitian matrix A and
    vector v.
    >>> import numpy as np
    >>> A = np.array([
    ... [1,  2, 4],
    ... [2,  3,  -1],
    ... [4, -1,  1]
    ... ])
    >>> v = np.array([
    ... [1],
    ... [2],
    ... [3]
    ... ])
    >>> rayleigh_quotient(A, v)
    array([[3.]])
    """"""
    v_star = v.conjugate().T
    v_star_dot = v_star.dot(a)
    assert isinstance(v_star_dot, np.ndarray)
    return v_star_dot.dot(v) / v_star.dot(v)",0.5657388,0.0011764523
combination_memo,sum_of_digits_compact,combination_memo This function calculates nCr using memoization method.,"sum_of_digits_compact >>> sum_of_digits_compact(12345)
15
>>> sum_of_digits_compact(123)
6
>>> sum_of_digits_compact(-123)
6
>>> sum_of_digits_compact(0)
0","def combination_memo(n, r):
    """"""This function calculates nCr using memoization method.""""""
    memo = {}

    def recur(n, r):
        if n == r or r == 0:
            return 1
        if (n, r) not in memo:
            memo[n, r] = recur(n - 1, r - 1) + recur(n - 1, r)
        return memo[n, r]
    return recur(n, r)","def sum_of_digits_compact(n: int) -> int:
    """"""
    Find the sum of digits of a number
    >>> sum_of_digits_compact(12345)
    15
    >>> sum_of_digits_compact(123)
    6
    >>> sum_of_digits_compact(-123)
    6
    >>> sum_of_digits_compact(0)
    0
    """"""
    return sum((int(c) for c in str(abs(n))))",0.5244236,0.00064357737
find_factorial,factorial,find_factorial Calculates the factorial of a given number n ,"factorial 5040
>>> factorial(-1)
Traceback (most recent call last):
  ...
ValueError: Number should not be negative.
>>> [factorial(i) for i in range(10)]
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]","def find_factorial(n):
    """""" Calculates the factorial of a given number n """"""
    fact = 1
    while n != 0:
        fact *= n
        n -= 1
    return fact","@lru_cache
def factorial(num: int) -> int:
    """"""
    >>> factorial(7)
    5040
    >>> factorial(-1)
    Traceback (most recent call last):
      ...
    ValueError: Number should not be negative.
    >>> [factorial(i) for i in range(10)]
    [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    """"""
    if num < 0:
        raise ValueError('Number should not be negative.')
    return 1 if num in (0, 1) else num * factorial(num - 1)",0.6973481,0.99808407
pythagoras,pythagorean_triple,"pythagoras Passing ""?"" will indicate the unknown side.","pythagorean_triple and value as the number of corresponding triplets.
>>> pythagorean_triple(15)
Counter({12: 1})
>>> pythagorean_triple(40)
Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1})
>>> pythagorean_triple(50)
Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})","def pythagoras(opposite, adjacent, hypotenuse):
    """"""
    Returns length of a third side of a right angled triangle.
    Passing ""?"" will indicate the unknown side.
    """"""
    try:
        if opposite == str('?'):
            return 'Opposite = ' + str((hypotenuse ** 2 - adjacent ** 2) ** 0.5)
        if adjacent == str('?'):
            return 'Adjacent = ' + str((hypotenuse ** 2 - opposite ** 2) ** 0.5)
        if hypotenuse == str('?'):
            return 'Hypotenuse = ' + str((opposite ** 2 + adjacent ** 2) ** 0.5)
        return 'You already know the answer!'
    except:
        raise ValueError('invalid argument(s) were given.')","def pythagorean_triple(max_perimeter: int) -> typing.Counter[int]:
    """"""
    Returns a dictionary with keys as the perimeter of a right angled triangle
    and value as the number of corresponding triplets.
    >>> pythagorean_triple(15)
    Counter({12: 1})
    >>> pythagorean_triple(40)
    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1})
    >>> pythagorean_triple(50)
    Counter({12: 1, 30: 1, 24: 1, 40: 1, 36: 1, 48: 1})
    """"""
    triplets: typing.Counter[int] = Counter()
    for base in range(1, max_perimeter + 1):
        for perpendicular in range(base, max_perimeter + 1):
            hypotenuse = (base * base + perpendicular * perpendicular) ** 0.5
            if hypotenuse == int(hypotenuse):
                perimeter = int(base + perpendicular + hypotenuse)
                if perimeter > max_perimeter:
                    continue
                triplets[perimeter] += 1
    return triplets",0.40173835,0.99229795
k_closest,get_bounds,"k_closest Python does not support a max heap; thus we can use the default min heap
where the keys (distance) are negated.","get_bounds >>> import numpy
>>> array = numpy.linspace(-20.0, 20.0, 1000)
>>> get_bounds(array, 1000)
(-20, 20)","def k_closest(points, k, origin=(0, 0)):
    """"""Initialize max heap with first k points.
    Python does not support a max heap; thus we can use the default min heap
    where the keys (distance) are negated.
    """"""
    heap = [(-distance(p, origin), p) for p in points[:k]]
    heapify(heap)
    '\n    For every point p in points[k:],\n    check if p is smaller than the root of the max heap;\n    if it is, add p to heap and remove root. Reheapify.\n    '
    for point in points[k:]:
        dist = distance(point, origin)
        heappushpop(heap, (-dist, point))
        'Same as:\n            if d < -heap[0][0]:\n                heappush(heap, (-d,p))\n                heappop(heap)\n\n        Note: heappushpop is more efficient than separate push and pop calls.\n        Each heappushpop call takes O(logk) time.\n        '
    return [point for (nd, point) in heap]","def get_bounds(fft_results: np.ndarray, samplerate: int) -> tuple[int | float, int | float]:
    """"""
    Get bounds for printing fft results

    >>> import numpy
    >>> array = numpy.linspace(-20.0, 20.0, 1000)
    >>> get_bounds(array, 1000)
    (-20, 20)
    """"""
    lowest = min([-20, np.min(fft_results[1:samplerate // 2 - 1])])
    highest = max([20, np.max(fft_results[1:samplerate // 2 - 1])])
    return (lowest, highest)",0.48249817,0.9382975
get_skyline,prim_heap,get_skyline Wortst Time Complexity: O(NlogN),"prim_heap Runtime:
    O((m + n)log n) with `m` edges and `n` vertices

Yield:
    Edges of a Minimum Spanning Tree

Usage:
    prim(graph, graph[0])","def get_skyline(lrh):
    """"""
    Wortst Time Complexity: O(NlogN)
    :type buildings: List[List[int]]
    :rtype: List[List[int]]
    """"""
    (skyline, live) = ([], [])
    (i, n) = (0, len(lrh))
    while i < n or live:
        if not live or (i < n and lrh[i][0] <= -live[0][1]):
            x = lrh[i][0]
            while i < n and lrh[i][0] == x:
                heapq.heappush(live, (-lrh[i][2], -lrh[i][1]))
                i += 1
        else:
            x = -live[0][1]
            while live and -live[0][1] <= x:
                heapq.heappop(live)
        height = len(live) and -live[0][0]
        if not skyline or height != skyline[-1][1]:
            skyline += ([x, height],)
    return skyline","def prim_heap(graph: list, root: Vertex) -> Iterator[tuple]:
    """"""Prim's Algorithm with min heap.

    Runtime:
        O((m + n)log n) with `m` edges and `n` vertices

    Yield:
        Edges of a Minimum Spanning Tree

    Usage:
        prim(graph, graph[0])
    """"""
    for u in graph:
        u.key = math.inf
        u.pi = None
    root.key = 0
    h = list(graph)
    hq.heapify(h)
    while h:
        u = hq.heappop(h)
        for v in u.neighbors:
            if v in h and u.edges[v.id] < v.key:
                v.pi = u
                v.key = u.edges[v.id]
                hq.heapify(h)
    for i in range(1, len(graph)):
        yield (int(graph[i].id) + 1, int(graph[i].pi.id) + 1)",0.49667388,0.97654086
merge_k_lists,merge_lists,merge_k_lists Merge List ,"merge_lists >>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))
>>> len(merged)
16
>>> str(merged)
'-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'
>>> list(merged) == list(sorted(test_data_odd + test_data_even))
True","def merge_k_lists(lists):
    """""" Merge List """"""
    dummy = ListNode(None)
    curr = dummy
    q = PriorityQueue()
    for node in lists:
        if node:
            q.put((node.val, node))
    while not q.empty():
        curr.next = q.get()[1]
        curr = curr.next
        if curr.next:
            q.put((curr.next.val, curr.next))
    return dummy.next","def merge_lists(sll_one: SortedLinkedList, sll_two: SortedLinkedList) -> SortedLinkedList:
    """"""
    >>> SSL = SortedLinkedList
    >>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))
    >>> len(merged)
    16
    >>> str(merged)
    '-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'
    >>> list(merged) == list(sorted(test_data_odd + test_data_even))
    True
    """"""
    return SortedLinkedList(list(sll_one) + list(sll_two))",0.6315421,0.99022734
dfs,mixed_keyword,"dfs the dictionary, keyed by the original nodes.","mixed_keyword H E L O
A B C D
F G I J
K M N P
Q R S T
U V W X
Y Z
and map vertically

>>> mixed_keyword(""college"", ""UNIVERSITY"")  # doctest: +NORMALIZE_WHITESPACE
{'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',
 'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',
 'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',
 'Y': 'T', 'Z': 'Y'}
'XKJGUFMJST'","def dfs(node, dic):
    """"""
    Clones a graph using a recursive depth first search. Stores the clones in
    the dictionary, keyed by the original nodes.
    """"""
    for neighbor in node.neighbors:
        if neighbor not in dic:
            neighbor_copy = neighbor.shallow_copy()
            dic[neighbor] = neighbor_copy
            dic[node].add_neighbor(neighbor_copy)
            dfs(neighbor, dic)
        else:
            dic[node].add_neighbor(dic[neighbor])","def mixed_keyword(key: str='college', pt: str='UNIVERSITY') -> str:
    """"""

    For key:hello

    H E L O
    A B C D
    F G I J
    K M N P
    Q R S T
    U V W X
    Y Z
    and map vertically

    >>> mixed_keyword(""college"", ""UNIVERSITY"")  # doctest: +NORMALIZE_WHITESPACE
    {'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',
     'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',
     'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',
     'Y': 'T', 'Z': 'Y'}
    'XKJGUFMJST'
    """"""
    key = key.upper()
    pt = pt.upper()
    temp = []
    for i in key:
        if i not in temp:
            temp.append(i)
    len_temp = len(temp)
    alpha = []
    modalpha = []
    for j in range(65, 91):
        t = chr(j)
        alpha.append(t)
        if t not in temp:
            temp.append(t)
    r = int(26 / 4)
    k = 0
    for _ in range(r):
        s = []
        for _ in range(len_temp):
            s.append(temp[k])
            if k >= 25:
                break
            k += 1
        modalpha.append(s)
    d = {}
    j = 0
    k = 0
    for j in range(len_temp):
        for m in modalpha:
            if not len(m) - 1 >= j:
                break
            d[alpha[k]] = m[j]
            if not k < 25:
                break
            k += 1
    print(d)
    cypher = ''
    for i in pt:
        cypher += d[i]
    return cypher",0.44605374,0.0009827296
__is_balanced_recursive,is_right,__is_balanced_recursive O(N) solution,"is_right Note: this doesn't check if P and Q are equal, but that's handled by the use of
itertools.combinations in the solution function.

>>> is_right(0, 1, 2, 0)
True
>>> is_right(1, 0, 2, 2)
False","def __is_balanced_recursive(root):
    """"""
    O(N) solution
    """"""
    return -1 != __get_depth(root)","def is_right(x1: int, y1: int, x2: int, y2: int) -> bool:
    """"""
    Check if the triangle described by P(x1,y1), Q(x2,y2) and O(0,0) is right-angled.
    Note: this doesn't check if P and Q are equal, but that's handled by the use of
    itertools.combinations in the solution function.

    >>> is_right(0, 1, 2, 0)
    True
    >>> is_right(1, 0, 2, 2)
    False
    """"""
    if x1 == y1 == 0 or x2 == y2 == 0:
        return False
    a_square = x1 * x1 + y1 * y1
    b_square = x2 * x2 + y2 * y2
    c_square = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
    return a_square + b_square == c_square or a_square + c_square == b_square or b_square + c_square == a_square",0.5984743,0.018158969
__get_depth,depth_of_tree,__get_depth return 0 if unbalanced else depth + 1,"depth_of_tree >>> root = Node(0)
>>> depth_of_tree(root)
1
>>> root.left = Node(0)
>>> depth_of_tree(root)
2
>>> root.right = Node(0)
>>> depth_of_tree(root)
2
>>> root.left.right = Node(0)
>>> depth_of_tree(root)
3
>>> depth_of_tree(root.left)
2","def __get_depth(root):
    """"""
    return 0 if unbalanced else depth + 1
    """"""
    if root is None:
        return 0
    left = __get_depth(root.left)
    right = __get_depth(root.right)
    if abs(left - right) > 1 or -1 in [left, right]:
        return -1
    return 1 + max(left, right)","def depth_of_tree(tree: Node | None) -> int:
    """"""
    Recursive function that returns the depth of a binary tree.

    >>> root = Node(0)
    >>> depth_of_tree(root)
    1
    >>> root.left = Node(0)
    >>> depth_of_tree(root)
    2
    >>> root.right = Node(0)
    >>> depth_of_tree(root)
    2
    >>> root.left.right = Node(0)
    >>> depth_of_tree(root)
    3
    >>> depth_of_tree(root.left)
    2
    """"""
    return 1 + max(depth_of_tree(tree.left), depth_of_tree(tree.right)) if tree else 0",0.55129313,0.99893063
bin_tree_to_list,rank,bin_tree_to_list type root: root class,"rank >>> root = build_tree(test_array)
>>> rank(root, 6, 3, 13)
2
>>> rank(root, 2, 0, 19)
4
>>> rank(root, 9, 2 ,2)
0
>>> rank(root, 0, 5, 10)
2","def bin_tree_to_list(root):
    """"""
    type root: root class
    """"""
    if not root:
        return root
    root = bin_tree_to_list_util(root)
    while root.left:
        root = root.left
    return root","def rank(node: Node | None, num: int, start: int, end: int) -> int:
    """"""
    Returns the number of occurrences of num in interval [start, end] in the list

    >>> root = build_tree(test_array)
    >>> rank(root, 6, 3, 13)
    2
    >>> rank(root, 2, 0, 19)
    4
    >>> rank(root, 9, 2 ,2)
    0
    >>> rank(root, 0, 5, 10)
    2
    """"""
    if start > end:
        return 0
    rank_till_end = rank_till_index(node, num, end)
    rank_before_start = rank_till_index(node, num, start - 1)
    return rank_till_end - rank_before_start",0.508413,0.9759829
construct_tree_util,rank_till_index,"construct_tree_util preIndex is a global variable that keeps track of the index in preorder
array.
preorder and postorder array are represented are pre[] and post[] respectively.
low and high are the indices for the postorder array.","rank_till_index >>> root = build_tree(test_array)
>>> rank_till_index(root, 6, 6)
1
>>> rank_till_index(root, 2, 0)
1
>>> rank_till_index(root, 1, 10)
2
>>> rank_till_index(root, 17, 7)
0
>>> rank_till_index(root, 0, 9)
1","def construct_tree_util(pre: list, post: list, low: int, high: int, size: int):
    """"""
        Recursive function that constructs tree from preorder and postorder array.
        
        preIndex is a global variable that keeps track of the index in preorder
        array.
        preorder and postorder array are represented are pre[] and post[] respectively.
        low and high are the indices for the postorder array.
    """"""
    global pre_index
    if pre_index == -1:
        pre_index = 0
    if pre_index >= size or low > high:
        return None
    root = TreeNode(pre[pre_index])
    pre_index += 1
    if low == high or pre_index >= size:
        return root
    i = low
    while i <= high:
        if pre[pre_index] == post[i]:
            break
        i += 1
    if i <= high:
        root.left = construct_tree_util(pre, post, low, i, size)
        root.right = construct_tree_util(pre, post, i + 1, high, size)
    return root","def rank_till_index(node: Node | None, num: int, index: int) -> int:
    """"""
    Returns the number of occurrences of num in interval [0, index] in the list

    >>> root = build_tree(test_array)
    >>> rank_till_index(root, 6, 6)
    1
    >>> rank_till_index(root, 2, 0)
    1
    >>> rank_till_index(root, 1, 10)
    2
    >>> rank_till_index(root, 17, 7)
    0
    >>> rank_till_index(root, 0, 9)
    1
    """"""
    if index < 0 or node is None:
        return 0
    if node.minn == node.maxx:
        return index + 1 if node.minn == num else 0
    pivot = (node.minn + node.maxx) // 2
    if num <= pivot:
        return rank_till_index(node.left, num, node.map_left[index] - 1)
    else:
        return rank_till_index(node.right, num, index - node.map_left[index])",0.5003401,0.9869473
construct_tree,postorder,construct_tree and postorder array.,"postorder postOrder (left, right, self)","def construct_tree(pre: list, post: list, size: int):
    """"""
        Main Function that will construct the full binary tree from given preorder
        and postorder array.
    """"""
    global pre_index
    root = construct_tree_util(pre, post, 0, size - 1, size)
    return print_inorder(root)","def postorder(curr_node: Node | None) -> list[Node]:
    """"""
    postOrder (left, right, self)
    """"""
    node_list = []
    if curr_node is not None:
        node_list = postorder(curr_node.left) + postorder(curr_node.right) + [curr_node]
    return node_list",0.61373055,0.98612636
print_inorder,print_preorder,print_inorder Prints the tree constructed in inorder format,"print_preorder >>> root = Node(1)
>>> root.left = Node(2)
>>> root.right = Node(3)
>>> print_preorder(root)
1
2
3
>>> print_preorder(root.right)
3","def print_inorder(root: TreeNode, result=None):
    """"""
        Prints the tree constructed in inorder format
    """"""
    if root is None:
        return []
    if result is None:
        result = []
    print_inorder(root.left, result)
    result.append(root.val)
    print_inorder(root.right, result)
    return result","def print_preorder(root: Node | None) -> None:
    """"""
    Print pre-order traversal of the tree.

    >>> root = Node(1)
    >>> root.left = Node(2)
    >>> root.right = Node(3)
    >>> print_preorder(root)
    1
    2
    3
    >>> print_preorder(root.right)
    3
    """"""
    if root:
        print(root.value)
        print_preorder(root.left)
        print_preorder(root.right)",0.6583163,0.999724
preorder,get_preds,preorder Function to Preorder ,"get_preds >>> get_preds(
...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]),
...     np.array([[1.01, 1.66, 3.5]]),
...     0.6
... )
array([1.07173261, 1.65970737, 3.50160179])","def preorder(root):
    """""" Function to Preorder """"""
    res = []
    if not root:
        return res
    stack = []
    stack.append(root)
    while stack:
        root = stack.pop()
        res.append(root.val)
        if root.right:
            stack.append(root.right)
        if root.left:
            stack.append(root.left)
    return res","def get_preds(training_data_x: np.array, mcol_b: np.array, tau: float) -> np.array:
    """"""
    Get predictions with minimum error for each training data
    >>> get_preds(
    ...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]),
    ...     np.array([[1.01, 1.66, 3.5]]),
    ...     0.6
    ... )
    array([1.07173261, 1.65970737, 3.50160179])
    """"""
    ypred = local_weight_regression(training_data_x, mcol_b, tau)
    return ypred",0.58748513,0.02309719
preorder_rec,reaumur_to_rankine,preorder_rec Recursive Implementation ,"reaumur_to_rankine Reference:- http://www.csgnetwork.com/temp2conv.html

>>> reaumur_to_rankine(0)
491.67
>>> reaumur_to_rankine(20.0)
536.67
>>> reaumur_to_rankine(40)
581.67
>>> reaumur_to_rankine(""reaumur"")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'reaumur'","def preorder_rec(root, res=None):
    """""" Recursive Implementation """"""
    if root is None:
        return []
    if res is None:
        res = []
    res.append(root.val)
    preorder_rec(root.left, res)
    preorder_rec(root.right, res)
    return res","def reaumur_to_rankine(reaumur: float, ndigits: int=2) -> float:
    """"""
    Convert a given value from reaumur to rankine and round it to 2 decimal places.
    Reference:- http://www.csgnetwork.com/temp2conv.html

    >>> reaumur_to_rankine(0)
    491.67
    >>> reaumur_to_rankine(20.0)
    536.67
    >>> reaumur_to_rankine(40)
    581.67
    >>> reaumur_to_rankine(""reaumur"")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'reaumur'
    """"""
    return round(float(reaumur) * 2.25 + 32 + 459.67, ndigits)",0.55389917,0.017002253
inorder,precedence,inorder In order function ,"precedence order of operation.
https://en.wikipedia.org/wiki/Order_of_operations","def inorder(root):
    """""" In order function """"""
    res = []
    if not root:
        return res
    stack = []
    while root or stack:
        while root:
            stack.append(root)
            root = root.left
        root = stack.pop()
        res.append(root.val)
        root = root.right
    return res","def precedence(char: str) -> int:
    """"""
    Return integer value representing an operator's precedence, or
    order of operation.
    https://en.wikipedia.org/wiki/Order_of_operations
    """"""
    return {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}.get(char, -1)",0.6574281,0.0012023904
inorder_rec,count_inversions_recursive,inorder_rec Recursive Implementation ,"count_inversions_recursive Parameters
-----------
arr: array-like, the list containing the items for which the number
of inversions is desired. The elements of `arr` must be comparable.","def inorder_rec(root, res=None):
    """""" Recursive Implementation """"""
    if root is None:
        return []
    if res is None:
        res = []
    inorder_rec(root.left, res)
    res.append(root.val)
    inorder_rec(root.right, res)
    return res","def count_inversions_recursive(arr):
    """"""
    Counts the number of inversions using a divide-and-conquer algorithm
    Parameters
    -----------
    arr: array-like, the list containing the items for which the number
    of inversions is desired. The elements of `arr` must be comparable.
    Returns
    -------
    C: a sorted copy of `arr`.
    num_inversions: int, the total number of inversions in 'arr'
    Examples
    --------
    >>> count_inversions_recursive([1, 4, 2, 4, 1])
    ([1, 1, 2, 4, 4], 4)
    >>> count_inversions_recursive([1, 1, 2, 4, 4])
    ([1, 1, 2, 4, 4], 0)
    >>> count_inversions_recursive([])
    ([], 0)
    """"""
    if len(arr) <= 1:
        return (arr, 0)
    mid = len(arr) // 2
    p = arr[0:mid]
    q = arr[mid:]
    (a, inversion_p) = count_inversions_recursive(p)
    (b, inversions_q) = count_inversions_recursive(q)
    (c, cross_inversions) = _count_cross_inversions(a, b)
    num_inversions = inversion_p + inversions_q + cross_inversions
    return (c, num_inversions)",0.56434995,0.1153929
two_sum,sum_digits,"two_sum numbers such that their sum is the given target.

Using binary search.","sum_digits >>> sum_digits(1)
1
>>> sum_digits(12345)
15
>>> sum_digits(999001)
28","def two_sum(numbers, target):
    """"""
    Given a list of numbers sorted in ascending order, find the indices of two
    numbers such that their sum is the given target.

    Using binary search.
    """"""
    for (i, number) in enumerate(numbers):
        second_val = target - number
        (low, high) = (i + 1, len(numbers) - 1)
        while low <= high:
            mid = low + (high - low) // 2
            if second_val == numbers[mid]:
                return [i + 1, mid + 1]
            if second_val > numbers[mid]:
                low = mid + 1
            else:
                high = mid - 1
    return None","def sum_digits(num: int) -> int:
    """"""
    Returns the sum of every digit in num.

    >>> sum_digits(1)
    1
    >>> sum_digits(12345)
    15
    >>> sum_digits(999001)
    28
    """"""
    digit_sum = 0
    while num > 0:
        digit_sum += num % 10
        num //= 10
    return digit_sum",0.6556524,0.0013446317
n_sum,sum_of_geometric_progression,"n_sum nums: list[object]
target: object
sum_closure: function, optional
    Given two elements of nums, return sum of both.
compare_closure: function, optional
    Given one object of nums and target, return -1, 1, or 0.
same_closure: function, optional
    Given two object of nums, return bool.
return: list[list[object]]

Note:
1. type of sum_closure's return should be same 
   as type of compare_closure's first param","sum_of_geometric_progression Return the sum of n terms in a geometric progression.
>>> sum_of_geometric_progression(1, 2, 10)
1023.0
>>> sum_of_geometric_progression(1, 10, 5)
11111.0
>>> sum_of_geometric_progression(0, 2, 10)
0.0
>>> sum_of_geometric_progression(1, 0, 10)
1.0
>>> sum_of_geometric_progression(1, 2, 0)
-0.0
>>> sum_of_geometric_progression(-1, 2, 10)
-1023.0
>>> sum_of_geometric_progression(1, -2, 10)
-341.0
>>> sum_of_geometric_progression(1, 2, -10)
-0.9990234375","def n_sum(n, nums, target, **kv):
    """"""
    n: int
    nums: list[object]
    target: object
    sum_closure: function, optional
        Given two elements of nums, return sum of both.
    compare_closure: function, optional
        Given one object of nums and target, return -1, 1, or 0.
    same_closure: function, optional
        Given two object of nums, return bool.
    return: list[list[object]]

    Note:
    1. type of sum_closure's return should be same 
       as type of compare_closure's first param
    """"""

    def sum_closure_default(a, b):
        return a + b

    def compare_closure_default(num, target):
        """""" above, below, or right on? """"""
        if num < target:
            return -1
        elif num > target:
            return 1
        else:
            return 0

    def same_closure_default(a, b):
        return a == b

    def n_sum(n, nums, target):
        if n == 2:
            results = two_sum(nums, target)
        else:
            results = []
            prev_num = None
            for (index, num) in enumerate(nums):
                if prev_num is not None and same_closure(prev_num, num):
                    continue
                prev_num = num
                n_minus1_results = n_sum(n - 1, nums[index + 1:], target - num)
                n_minus1_results = append_elem_to_each_list(num, n_minus1_results)
                results += n_minus1_results
        return union(results)

    def two_sum(nums, target):
        nums.sort()
        lt = 0
        rt = len(nums) - 1
        results = []
        while lt < rt:
            sum_ = sum_closure(nums[lt], nums[rt])
            flag = compare_closure(sum_, target)
            if flag == -1:
                lt += 1
            elif flag == 1:
                rt -= 1
            else:
                results.append(sorted([nums[lt], nums[rt]]))
                lt += 1
                rt -= 1
                while lt < len(nums) and same_closure(nums[lt - 1], nums[lt]):
                    lt += 1
                while 0 <= rt and same_closure(nums[rt], nums[rt + 1]):
                    rt -= 1
        return results

    def append_elem_to_each_list(elem, container):
        results = []
        for elems in container:
            elems.append(elem)
            results.append(sorted(elems))
        return results

    def union(duplicate_results):
        results = []
        if len(duplicate_results) != 0:
            duplicate_results.sort()
            results.append(duplicate_results[0])
            for result in duplicate_results[1:]:
                if results[-1] != result:
                    results.append(result)
        return results
    sum_closure = kv.get('sum_closure', sum_closure_default)
    same_closure = kv.get('same_closure', same_closure_default)
    compare_closure = kv.get('compare_closure', compare_closure_default)
    nums.sort()
    return n_sum(n, nums, target)","def sum_of_geometric_progression(first_term: int, common_ratio: int, num_of_terms: int) -> float:
    """""" ""
    Return the sum of n terms in a geometric progression.
    >>> sum_of_geometric_progression(1, 2, 10)
    1023.0
    >>> sum_of_geometric_progression(1, 10, 5)
    11111.0
    >>> sum_of_geometric_progression(0, 2, 10)
    0.0
    >>> sum_of_geometric_progression(1, 0, 10)
    1.0
    >>> sum_of_geometric_progression(1, 2, 0)
    -0.0
    >>> sum_of_geometric_progression(-1, 2, 10)
    -1023.0
    >>> sum_of_geometric_progression(1, -2, 10)
    -341.0
    >>> sum_of_geometric_progression(1, 2, -10)
    -0.9990234375
    """"""
    if common_ratio == 1:
        return num_of_terms * first_term
    return first_term / (1 - common_ratio) * (1 - common_ratio ** num_of_terms)",0.6133344,0.00027142285
merge_intervals,bitonic_merge,merge_intervals Merge intervals in the form of a list. ,"bitonic_merge descending if direction = 0.
The sequence to be sorted starts at index position low, the parameter length is the
number of elements to be sorted.

>>> arr = [12, 42, -21, 1]
>>> bitonic_merge(arr, 0, 4, 1)
>>> arr
[-21, 1, 12, 42]

>>> bitonic_merge(arr, 0, 4, 0)
>>> arr
[42, 12, 1, -21]","def merge_intervals(intervals):
    """""" Merge intervals in the form of a list. """"""
    if intervals is None:
        return None
    intervals.sort(key=lambda i: i[0])
    out = [intervals.pop(0)]
    for i in intervals:
        if out[-1][-1] >= i[0]:
            out[-1][-1] = max(out[-1][-1], i[-1])
        else:
            out.append(i)
    return out","def bitonic_merge(array: list[int], low: int, length: int, direction: int) -> None:
    """"""
    It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in
    descending if direction = 0.
    The sequence to be sorted starts at index position low, the parameter length is the
    number of elements to be sorted.

    >>> arr = [12, 42, -21, 1]
    >>> bitonic_merge(arr, 0, 4, 1)
    >>> arr
    [-21, 1, 12, 42]

    >>> bitonic_merge(arr, 0, 4, 0)
    >>> arr
    [42, 12, 1, -21]
    """"""
    if length > 1:
        middle = int(length / 2)
        for i in range(low, low + middle):
            comp_and_swap(array, i, i + middle, direction)
        bitonic_merge(array, low, middle, direction)
        bitonic_merge(array, low + middle, middle, direction)",0.53832835,0.0055877976
flatten_iter,print_solution,flatten_iter returns generator which produces one dimensional output.,print_solution of a 9x9 grid,"def flatten_iter(iterable):
    """"""
    Takes as input multi dimensional iterable and
    returns generator which produces one dimensional output.
    """"""
    for element in iterable:
        if not isinstance(element, str) and isinstance(element, Iterable):
            yield from flatten_iter(element)
        else:
            yield element","def print_solution(grid: Matrix) -> None:
    """"""
    A function to print the solution in the form
    of a 9x9 grid
    """"""
    for row in grid:
        for cell in row:
            print(cell, end=' ')
        print()",0.46771544,0.8942094
rotate_v1,rotate,rotate_v1 T(n)- O(nk),"rotate angle can be any integer between 1, 360 and axis can be any one of
'x', 'y', 'z'

>>> rotate(1.0, 2.0, 3.0, 'y', 90.0)
(3.130524675073759, 2.0, 0.4470070007889556)

>>> rotate(1, 2, 3, ""z"", 180)
(0.999736015495891, -2.0001319704760485, 3)

>>> rotate('1', 2, 3, ""z"", 90.0)  # '1' is str
Traceback (most recent call last):
    ...
TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]

>>> rotate(1, 2, 3, ""n"", 90)  # 'n' is not a valid axis
Traceback (most recent call last):
    ...
ValueError: not a valid axis, choose one of 'x', 'y', 'z'

>>> rotate(1, 2, 3, ""x"", -90)
(1, -2.5049096187183877, -2.5933429780983657)

>>> rotate(1, 2, 3, ""x"", 450)  # 450 wrap around to 90
(1, 3.5776792428178217, -0.44744970165427644)","def rotate_v1(array, k):
    """"""
    Rotate the entire array 'k' times
    T(n)- O(nk)

    :type array: List[int]
    :type k: int
    :rtype: void Do not return anything, modify array in-place instead.
    """"""
    array = array[:]
    n = len(array)
    for i in range(k):
        temp = array[n - 1]
        for j in range(n - 1, 0, -1):
            array[j] = array[j - 1]
        array[0] = temp
    return array","def rotate(x: float, y: float, z: float, axis: str, angle: float) -> tuple[float, float, float]:
    """"""
    rotate a point around a certain axis with a certain angle
    angle can be any integer between 1, 360 and axis can be any one of
    'x', 'y', 'z'

    >>> rotate(1.0, 2.0, 3.0, 'y', 90.0)
    (3.130524675073759, 2.0, 0.4470070007889556)

    >>> rotate(1, 2, 3, ""z"", 180)
    (0.999736015495891, -2.0001319704760485, 3)

    >>> rotate('1', 2, 3, ""z"", 90.0)  # '1' is str
    Traceback (most recent call last):
        ...
    TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]

    >>> rotate(1, 2, 3, ""n"", 90)  # 'n' is not a valid axis
    Traceback (most recent call last):
        ...
    ValueError: not a valid axis, choose one of 'x', 'y', 'z'

    >>> rotate(1, 2, 3, ""x"", -90)
    (1, -2.5049096187183877, -2.5933429780983657)

    >>> rotate(1, 2, 3, ""x"", 450)  # 450 wrap around to 90
    (1, 3.5776792428178217, -0.44744970165427644)
    """"""
    if not isinstance(axis, str):
        raise TypeError('Axis must be a str')
    input_variables = locals()
    del input_variables['axis']
    if not all((isinstance(val, (float, int)) for val in input_variables.values())):
        raise TypeError(f'Input values except axis must either be float or int: {list(input_variables.values())}')
    angle = angle % 360 / 450 * 180 / math.pi
    if axis == 'z':
        new_x = x * math.cos(angle) - y * math.sin(angle)
        new_y = y * math.cos(angle) + x * math.sin(angle)
        new_z = z
    elif axis == 'x':
        new_y = y * math.cos(angle) - z * math.sin(angle)
        new_z = z * math.cos(angle) + y * math.sin(angle)
        new_x = x
    elif axis == 'y':
        new_x = x * math.cos(angle) - z * math.sin(angle)
        new_z = z * math.cos(angle) + x * math.sin(angle)
        new_y = y
    else:
        raise ValueError(""not a valid axis, choose one of 'x', 'y', 'z'"")
    return (new_x, new_y, new_z)",0.7188697,4.5153145e-05
rotate_v2,rotate_270,rotate_v2 T(n)- O(n),"rotate_270 [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]
>>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))
True","def rotate_v2(array, k):
    """"""
    Reverse segments of the array, followed by the entire array
    T(n)- O(n)
    :type array: List[int]
    :type k: int
    :rtype: void Do not return anything, modify nums in-place instead.
    """"""
    array = array[:]

    def reverse(arr, a, b):
        while a < b:
            (arr[a], arr[b]) = (arr[b], arr[a])
            a += 1
            b -= 1
    n = len(array)
    k = k % n
    reverse(array, 0, n - k - 1)
    reverse(array, n - k, n - 1)
    reverse(array, 0, n - 1)
    return array","def rotate_270(matrix: list[list[int]]) -> list[list[int]]:
    """"""
    >>> rotate_270(make_matrix())
    [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]
    >>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))
    True
    """"""
    return reverse_column(transpose(matrix))",0.6928829,0.7517821
longest_non_repeat_v1,longest_subsequence,longest_non_repeat_v1 without repeating characters.,"longest_subsequence >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])
[10, 22, 33, 41, 60, 80]
>>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])
[1, 2, 3, 9]
>>> longest_subsequence([9, 8, 7, 6, 5, 7])
[8]
>>> longest_subsequence([1, 1, 1])
[1, 1, 1]
>>> longest_subsequence([])
[]","def longest_non_repeat_v1(string):
    """"""
    Find the length of the longest substring
    without repeating characters.
    """"""
    if string is None:
        return 0
    dict = {}
    max_length = 0
    j = 0
    for i in range(len(string)):
        if string[i] in dict:
            j = max(dict[string[i]], j)
        dict[string[i]] = i + 1
        max_length = max(max_length, i - j + 1)
    return max_length","def longest_subsequence(array: list[int]) -> list[int]:
    """"""
    Some examples
    >>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])
    [10, 22, 33, 41, 60, 80]
    >>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])
    [1, 2, 3, 9]
    >>> longest_subsequence([9, 8, 7, 6, 5, 7])
    [8]
    >>> longest_subsequence([1, 1, 1])
    [1, 1, 1]
    >>> longest_subsequence([])
    []
    """"""
    array_length = len(array)
    if array_length <= 1:
        return array
    pivot = array[0]
    is_found = False
    i = 1
    longest_subseq: list[int] = []
    while not is_found and i < array_length:
        if array[i] < pivot:
            is_found = True
            temp_array = [element for element in array[i:] if element >= array[i]]
            temp_array = longest_subsequence(temp_array)
            if len(temp_array) > len(longest_subseq):
                longest_subseq = temp_array
        else:
            i += 1
    temp_array = [element for element in array[1:] if element >= pivot]
    temp_array = [pivot] + longest_subsequence(temp_array)
    if len(temp_array) > len(longest_subseq):
        return temp_array
    else:
        return longest_subseq",0.5890473,0.990393
longest_non_repeat_v2,longest_prefix,"longest_non_repeat_v2 without repeating characters.
Uses alternative algorithm.","longest_prefix Finding longest prefix which is suffix as well

>>> longest_prefix(""aabcdaabc"")
4
>>> longest_prefix(""asdasdad"")
4
>>> longest_prefix(""abcab"")
2","def longest_non_repeat_v2(string):
    """"""
    Find the length of the longest substring
    without repeating characters.
    Uses alternative algorithm.
    """"""
    if string is None:
        return 0
    (start, max_len) = (0, 0)
    used_char = {}
    for (index, char) in enumerate(string):
        if char in used_char and start <= used_char[char]:
            start = used_char[char] + 1
        else:
            max_len = max(max_len, index - start + 1)
        used_char[char] = index
    return max_len","def longest_prefix(input_str: str) -> int:
    """"""
    Prefix-function use case
    Finding longest prefix which is suffix as well

    >>> longest_prefix(""aabcdaabc"")
    4
    >>> longest_prefix(""asdasdad"")
    4
    >>> longest_prefix(""abcab"")
    2
    """"""
    return max(prefix_function(input_str))",0.51777065,0.84008336
get_longest_non_repeat_v1,longest_increasing_subsequence_length,"get_longest_non_repeat_v1 without repeating characters.
Return max_len and the substring as a tuple","longest_increasing_subsequence_length 6
>>> longest_increasing_subsequence_length([])
0
>>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13,
...                                     3, 11, 7, 15])
6
>>> longest_increasing_subsequence_length([5, 4, 3, 2, 1])
1","def get_longest_non_repeat_v1(string):
    """"""
    Find the length of the longest substring
    without repeating characters.
    Return max_len and the substring as a tuple
    """"""
    if string is None:
        return (0, '')
    sub_string = ''
    dict = {}
    max_length = 0
    j = 0
    for i in range(len(string)):
        if string[i] in dict:
            j = max(dict[string[i]], j)
        dict[string[i]] = i + 1
        if i - j + 1 > max_length:
            max_length = i - j + 1
            sub_string = string[j:i + 1]
    return (max_length, sub_string)","def longest_increasing_subsequence_length(v: list[int]) -> int:
    """"""
    >>> longest_increasing_subsequence_length([2, 5, 3, 7, 11, 8, 10, 13, 6])
    6
    >>> longest_increasing_subsequence_length([])
    0
    >>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13,
    ...                                     3, 11, 7, 15])
    6
    >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1])
    1
    """"""
    if len(v) == 0:
        return 0
    tail = [0] * len(v)
    length = 1
    tail[0] = v[0]
    for i in range(1, len(v)):
        if v[i] < tail[0]:
            tail[0] = v[i]
        elif v[i] > tail[length - 1]:
            tail[length] = v[i]
            length += 1
        else:
            tail[ceil_index(tail, -1, length - 1, v[i])] = v[i]
    return length",0.62361425,0.9883967
get_longest_non_repeat_v2,palindromic_string,"get_longest_non_repeat_v2 without repeating characters.
Uses alternative algorithm.
Return max_len and the substring as a tuple","palindromic_string 'abbba'
>>> palindromic_string('ababa')
'ababa'

Manacherâ€™s algorithm which finds Longest palindromic Substring in linear time.

1. first this convert input_string(""xyx"") into new_string(""x|y|x"") where odd
    positions are actual input characters.
2. for each character in new_string it find corresponding length and store the
    length and l,r to store previously calculated info.(please look the explanation
    for details)

3. return corresponding output_string by removing all ""|""","def get_longest_non_repeat_v2(string):
    """"""
    Find the length of the longest substring
    without repeating characters.
    Uses alternative algorithm.
    Return max_len and the substring as a tuple
    """"""
    if string is None:
        return (0, '')
    sub_string = ''
    (start, max_len) = (0, 0)
    used_char = {}
    for (index, char) in enumerate(string):
        if char in used_char and start <= used_char[char]:
            start = used_char[char] + 1
        elif index - start + 1 > max_len:
            max_len = index - start + 1
            sub_string = string[start:index + 1]
        used_char[char] = index
    return (max_len, sub_string)","def palindromic_string(input_string: str) -> str:
    """"""
    >>> palindromic_string('abbbaba')
    'abbba'
    >>> palindromic_string('ababa')
    'ababa'

    Manacherâ€™s algorithm which finds Longest palindromic Substring in linear time.

    1. first this convert input_string(""xyx"") into new_string(""x|y|x"") where odd
        positions are actual input characters.
    2. for each character in new_string it find corresponding length and store the
        length and l,r to store previously calculated info.(please look the explanation
        for details)

    3. return corresponding output_string by removing all ""|""
    """"""
    max_length = 0
    new_input_string = ''
    output_string = ''
    for i in input_string[:len(input_string) - 1]:
        new_input_string += i + '|'
    new_input_string += input_string[-1]
    (l, r) = (0, 0)
    length = [1 for i in range(len(new_input_string))]
    start = 0
    for j in range(len(new_input_string)):
        k = 1 if j > r else min(length[l + r - j] // 2, r - j + 1)
        while j - k >= 0 and j + k < len(new_input_string) and (new_input_string[k + j] == new_input_string[j - k]):
            k += 1
        length[j] = 2 * k - 1
        if j + k - 1 > r:
            l = j - k + 1
            r = j + k - 1
        if max_length < length[j]:
            max_length = length[j]
            start = j
    s = new_input_string[start - max_length // 2:start + max_length // 2 + 1]
    for i in s:
        if i != '|':
            output_string += i
    return output_string",0.5976026,0.99308914
ladder_length,topological_sort,ladder_length Bidirectional BFS!!!,topological_sort using BFS,"def ladder_length(begin_word, end_word, word_list):
    """"""
    Bidirectional BFS!!!
    :type begin_word: str
    :type end_word: str
    :type word_list: Set[str]
    :rtype: int
    """"""
    if len(begin_word) != len(end_word):
        return -1
    if begin_word == end_word:
        return 0
    if sum((c1 != c2 for (c1, c2) in zip(begin_word, end_word))) == 1:
        return 1
    begin_set = set()
    end_set = set()
    begin_set.add(begin_word)
    end_set.add(end_word)
    result = 2
    while begin_set and end_set:
        if len(begin_set) > len(end_set):
            (begin_set, end_set) = (end_set, begin_set)
        next_begin_set = set()
        for word in begin_set:
            for ladder_word in word_range(word):
                if ladder_word in end_set:
                    return result
                if ladder_word in word_list:
                    next_begin_set.add(ladder_word)
                    word_list.remove(ladder_word)
        begin_set = next_begin_set
        result += 1
    return -1","def topological_sort(graph):
    """"""
    Kahn's Algorithm is used to find Topological ordering of Directed Acyclic Graph
    using BFS
    """"""
    indegree = [0] * len(graph)
    queue = []
    topo = []
    cnt = 0
    for values in graph.values():
        for i in values:
            indegree[i] += 1
    for i in range(len(indegree)):
        if indegree[i] == 0:
            queue.append(i)
    while queue:
        vertex = queue.pop(0)
        cnt += 1
        topo.append(vertex)
        for x in graph[vertex]:
            indegree[x] -= 1
            if indegree[x] == 0:
                queue.append(x)
    if cnt != len(graph):
        print('Cycle exists')
    else:
        print(topo)",0.5006468,0.8415435
invert_matrix,square_zero_matrix,invert_matrix invert an n x n matrix,square_zero_matrix returns a square zero-matrix of dimension NxN,"def invert_matrix(m):
    """"""invert an n x n matrix""""""
    if not array_is_matrix(m):
        print('Invalid matrix: array is not a matrix')
        return [[-1]]
    elif len(m) != len(m[0]):
        print('Invalid matrix: matrix is not square')
        return [[-2]]
    elif len(m) < 2:
        print('Invalid matrix: matrix is too small')
        return [[-3]]
    elif get_determinant(m) == 0:
        print('Invalid matrix: matrix is square, but singular (determinant = 0)')
        return [[-4]]
    elif len(m) == 2:
        multiplier = 1 / get_determinant(m)
        inverted = [[multiplier] * len(m) for n in range(len(m))]
        inverted[0][1] = inverted[0][1] * -1 * m[0][1]
        inverted[1][0] = inverted[1][0] * -1 * m[1][0]
        inverted[0][0] = multiplier * m[1][1]
        inverted[1][1] = multiplier * m[0][0]
        return inverted
    else:
        'some steps combined in helpers to reduce traversals'
        m_of_minors = get_matrix_of_minors(m)
        multiplier = fractions.Fraction(1, get_determinant(m))
        inverted = transpose_and_multiply(m_of_minors, multiplier)
        return inverted","def square_zero_matrix(n: int) -> Matrix:
    """"""
    returns a square zero-matrix of dimension NxN
    """"""
    ans: list[list[float]] = [[0] * n for _ in range(n)]
    return Matrix(ans, n, n)",0.6991928,0.15168004
get_determinant,determinant,"get_determinant recursively calculate the determinant of an n x n matrix, n >= 2","determinant -2
>>> determinant([[1.5, 2.5], [3, 4]])
-1.5","def get_determinant(m):
    """"""recursively calculate the determinant of an n x n matrix, n >= 2""""""
    if len(m) == 2:
        return m[0][0] * m[1][1] - m[0][1] * m[1][0]
    else:
        sign = 1
        det = 0
        for i in range(len(m)):
            det += sign * m[0][i] * get_determinant(get_minor(m, 0, i))
            sign *= -1
        return det","def determinant(matrix: list[list[int]]) -> Any:
    """"""
    >>> determinant([[1, 2], [3, 4]])
    -2
    >>> determinant([[1.5, 2.5], [3, 4]])
    -1.5
    """"""
    if len(matrix) == 1:
        return matrix[0][0]
    return sum((x * determinant(minor(matrix, 0, i)) * (-1) ** i for (i, x) in enumerate(matrix[0])))",0.67441696,0.999974
get_matrix_of_minors,largest_square_area_in_matrix_bottom_up,get_matrix_of_minors get the matrix of minors and alternate signs,"largest_square_area_in_matrix_bottom_up >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])
0","def get_matrix_of_minors(m):
    """"""get the matrix of minors and alternate signs""""""
    matrix_of_minors = [[0 for i in range(len(m))] for j in range(len(m))]
    for row in range(len(m)):
        for col in range(len(m[0])):
            if (row + col) % 2 == 0:
                sign = 1
            else:
                sign = -1
            matrix_of_minors[row][col] = sign * get_determinant(get_minor(m, row, col))
    return matrix_of_minors","def largest_square_area_in_matrix_bottom_up(rows: int, cols: int, mat: list[list[int]]) -> int:
    """"""
    Function updates the largest_square_area, using bottom up approach.

    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])
    0

    """"""
    dp_array = [[0] * (cols + 1) for _ in range(rows + 1)]
    largest_square_area = 0
    for row in range(rows - 1, -1, -1):
        for col in range(cols - 1, -1, -1):
            right = dp_array[row][col + 1]
            diagonal = dp_array[row + 1][col + 1]
            bottom = dp_array[row + 1][col]
            if mat[row][col] == 1:
                dp_array[row][col] = 1 + min(right, diagonal, bottom)
                largest_square_area = max(dp_array[row][col], largest_square_area)
            else:
                dp_array[row][col] = 0
    return largest_square_area",0.5513177,0.15017252
get_minor,get_distance,get_minor (all values m[r][c] where r != row and c != col),"get_distance >>> get_distance([6, -1, 6, -1, 6], 2)
1
>>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)
3
>>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)
4","def get_minor(m, row, col):
    """"""
    get the minor of the matrix position m[row][col]
    (all values m[r][c] where r != row and c != col)
    """"""
    minors = []
    for i in range(len(m)):
        if i != row:
            new_row = m[i][:col]
            new_row.extend(m[i][col + 1:])
            minors.append(new_row)
    return minors","def get_distance(highway_now: list, car_index: int) -> int:
    """"""
    Get the distance between a car (at index car_index) and the next car
    >>> get_distance([6, -1, 6, -1, 6], 2)
    1
    >>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)
    3
    >>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)
    4
    """"""
    distance = 0
    cells = highway_now[car_index + 1:]
    for cell in range(len(cells)):
        if cells[cell] != -1:
            return distance
        distance += 1
    return distance + get_distance(highway_now, -1)",0.55325913,0.9067279
transpose_and_multiply,swap,"transpose_and_multiply swap values along diagonal, optionally adding multiplier","swap >>> swap(2,3)
(3, 2)
>>> swap(3,4)
(4, 3)
>>> swap(67, 12)
(12, 67)","def transpose_and_multiply(m, multiplier=1):
    """"""swap values along diagonal, optionally adding multiplier""""""
    for row in range(len(m)):
        for col in range(row + 1):
            temp = m[row][col] * multiplier
            m[row][col] = m[col][row] * multiplier
            m[col][row] = temp
    return m","def swap(a: int, b: int) -> tuple[int, int]:
    """"""
    Return a tuple (b, a) when given two integers a and b
    >>> swap(2,3)
    (3, 2)
    >>> swap(3,4)
    (4, 3)
    >>> swap(67, 12)
    (12, 67)
    """"""
    a ^= b
    b ^= a
    a ^= b
    return (a, b)",0.694846,0.20524573
identity,is_contains_unique_chars,identity Time Complexity: O(n^2),"is_contains_unique_chars >>> is_contains_unique_chars(""I_love.py"")
True
>>> is_contains_unique_chars(""I don't love Python"")
False

Time complexity: O(n)
Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode","def identity(n: int) -> list:
    """"""
    Returns the Identity matrix of size n x n
    Time Complexity: O(n^2)
    """"""
    I = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        I[i][i] = 1
    return I","def is_contains_unique_chars(input_str: str) -> bool:
    """"""
    Check if all characters in the string is unique or not.
    >>> is_contains_unique_chars(""I_love.py"")
    True
    >>> is_contains_unique_chars(""I don't love Python"")
    False

    Time complexity: O(n)
    Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode
    """"""
    bitmap = 0
    for ch in input_str:
        ch_unicode = ord(ch)
        ch_bit_index_on = pow(2, ch_unicode)
        if bitmap >> ch_unicode & 1 == 1:
            return False
        bitmap |= ch_bit_index_on
    return True",0.56669486,0.006025535
matrix_exponentiation,largest_square_area_in_matrix_top_down_approch,"matrix_exponentiation Time Complexity: O(d^3 log(n))
                 d: dimension of the square matrix mat
                 n: power the matrix is raised to","largest_square_area_in_matrix_top_down_approch square with maximum area.

We aren't using dp_array here, so the time complexity would be exponential.

>>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])
0","def matrix_exponentiation(mat: list, n: int) -> list:
    """"""
    Calculates mat^n by repeated squaring
    Time Complexity: O(d^3 log(n))
                     d: dimension of the square matrix mat
                     n: power the matrix is raised to
    """"""
    if n == 0:
        return identity(len(mat))
    elif n % 2 == 1:
        return multiply(matrix_exponentiation(mat, n - 1), mat)
    else:
        tmp = matrix_exponentiation(mat, n // 2)
        return multiply(tmp, tmp)","def largest_square_area_in_matrix_top_down_approch(rows: int, cols: int, mat: list[list[int]]) -> int:
    """"""
    Function updates the largest_square_area[0], if recursive call found
    square with maximum area.

    We aren't using dp_array here, so the time complexity would be exponential.

    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])
    0
    """"""

    def update_area_of_max_square(row: int, col: int) -> int:
        if row >= rows or col >= cols:
            return 0
        right = update_area_of_max_square(row, col + 1)
        diagonal = update_area_of_max_square(row + 1, col + 1)
        down = update_area_of_max_square(row + 1, col)
        if mat[row][col]:
            sub_problem_sol = 1 + min([right, diagonal, down])
            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)
            return sub_problem_sol
        else:
            return 0
    largest_square_area = [0]
    update_area_of_max_square(0, 0)
    return largest_square_area[0]",0.7187541,0.014302088
main,get_edges,"main Input consists of different weighted, connected, undirected graphs.
line 1:
  integers n, m
lines 2..m+2:
  edge with the format -> node index u, node index v, integer weight

Samples of input:

5 6
1 2 3
1 3 8
2 4 5
3 4 2
3 5 4
4 5 6

3 3
2 1 20
3 1 20
2 3 100

Sum of weights of the optimal paths:
14, 40","get_edges @input: graph (graph stored in an adjacency list where each vertex is
        represented as an integer)
@example:
>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}
>>> get_edges(graph)
{(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}","def main():
    """"""
    Test. How input works:
    Input consists of different weighted, connected, undirected graphs.
    line 1:
      integers n, m
    lines 2..m+2:
      edge with the format -> node index u, node index v, integer weight

    Samples of input:

    5 6
    1 2 3
    1 3 8
    2 4 5
    3 4 2
    3 5 4
    4 5 6

    3 3
    2 1 20
    3 1 20
    2 3 100

    Sum of weights of the optimal paths:
    14, 40
    """"""
    for size in sys.stdin:
        (vertex_count, edge_count) = map(int, size.split())
        forest = DisjointSet(edge_count)
        edges = [None] * edge_count
        for i in range(edge_count):
            (source, target, weight) = map(int, input().split())
            source -= 1
            target -= 1
            edges[i] = Edge(source, target, weight)
        print('MST weights sum:', kruskal(vertex_count, edges, forest))","def get_edges(graph: dict) -> set:
    """"""
    Return a set of couples that represents all of the edges.
    @input: graph (graph stored in an adjacency list where each vertex is
            represented as an integer)
    @example:
    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}
    >>> get_edges(graph)
    {(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}
    """"""
    edges = set()
    for (from_node, to_nodes) in graph.items():
        for to_node in to_nodes:
            edges.add((from_node, to_node))
    return edges",0.65959954,0.0052754795
permute,permute,permute returns a list with the permuations.,"permute >>> from itertools import permutations
>>> numbers= [1,2,3]
>>> all(list(nums) in permute(numbers) for nums in permutations(numbers))
True","def permute(elements):
    """"""
        returns a list with the permuations.
    """"""
    if len(elements) <= 1:
        return [elements]
    else:
        tmp = []
        for perm in permute(elements[1:]):
            for i in range(len(elements)):
                tmp.append(perm[:i] + elements[0:1] + perm[i:])
        return tmp","def permute(nums: list[int]) -> list[list[int]]:
    """"""
    Return all permutations.

    >>> from itertools import permutations
    >>> numbers= [1,2,3]
    >>> all(list(nums) in permute(numbers) for nums in permutations(numbers))
    True
    """"""
    result = []
    if len(nums) == 1:
        return [nums.copy()]
    for _ in range(len(nums)):
        n = nums.pop(0)
        permutations = permute(nums)
        for perm in permutations:
            perm.append(n)
        result.extend(permutations)
        nums.append(n)
    return result",0.77015465,0.9997098
permute_iter,gcd_by_iterative,permute_iter iterator: returns a perumation by each call.,"gcd_by_iterative stack frames for recursive functions calls (as done in the above method).
>>> gcd_by_iterative(24, 40)
8
>>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)
True
>>> gcd_by_iterative(-3, -9)
3
>>> gcd_by_iterative(3, -9)
3
>>> gcd_by_iterative(1, -800)
1
>>> gcd_by_iterative(11, 37)
1","def permute_iter(elements):
    """"""
        iterator: returns a perumation by each call.
    """"""
    if len(elements) <= 1:
        yield elements
    else:
        for perm in permute_iter(elements[1:]):
            for i in range(len(elements)):
                yield (perm[:i] + elements[0:1] + perm[i:])","def gcd_by_iterative(x: int, y: int) -> int:
    """"""
    Below method is more memory efficient because it does not create additional
    stack frames for recursive functions calls (as done in the above method).
    >>> gcd_by_iterative(24, 40)
    8
    >>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)
    True
    >>> gcd_by_iterative(-3, -9)
    3
    >>> gcd_by_iterative(3, -9)
    3
    >>> gcd_by_iterative(1, -800)
    1
    >>> gcd_by_iterative(11, 37)
    1
    """"""
    while y:
        (x, y) = (y, x % y)
    return abs(x)",0.5885016,0.07331554
convert_to_list,convert,"convert_to_list for example: give 112
result 2 -> 1 -> 1","convert >>> convert(123)
'OneHundred,TwentyThree'","def convert_to_list(number: int) -> Node:
    """"""
        converts a positive integer into a (reversed) linked list.
        for example: give 112
        result 2 -> 1 -> 1
    """"""
    if number >= 0:
        head = Node(0)
        current = head
        remainder = number % 10
        quotient = number // 10
        while quotient != 0:
            current.next = Node(remainder)
            current = current.next
            remainder = quotient % 10
            quotient //= 10
        current.next = Node(remainder)
        return head.next
    else:
        print('number must be positive!')","def convert(number: int) -> str:
    """"""
    Given a number return the number in words.

    >>> convert(123)
    'OneHundred,TwentyThree'
    """"""
    if number == 0:
        words = 'Zero'
        return words
    else:
        digits = math.log10(number)
        digits = digits + 1
        singles = {}
        singles[0] = ''
        singles[1] = 'One'
        singles[2] = 'Two'
        singles[3] = 'Three'
        singles[4] = 'Four'
        singles[5] = 'Five'
        singles[6] = 'Six'
        singles[7] = 'Seven'
        singles[8] = 'Eight'
        singles[9] = 'Nine'
        doubles = {}
        doubles[0] = ''
        doubles[2] = 'Twenty'
        doubles[3] = 'Thirty'
        doubles[4] = 'Forty'
        doubles[5] = 'Fifty'
        doubles[6] = 'Sixty'
        doubles[7] = 'Seventy'
        doubles[8] = 'Eighty'
        doubles[9] = 'Ninety'
        teens = {}
        teens[0] = 'Ten'
        teens[1] = 'Eleven'
        teens[2] = 'Twelve'
        teens[3] = 'Thirteen'
        teens[4] = 'Fourteen'
        teens[5] = 'Fifteen'
        teens[6] = 'Sixteen'
        teens[7] = 'Seventeen'
        teens[8] = 'Eighteen'
        teens[9] = 'Nineteen'
        placevalue = {}
        placevalue[2] = 'Hundred,'
        placevalue[3] = 'Thousand,'
        placevalue[5] = 'Lakh,'
        placevalue[7] = 'Crore,'
        temp_num = number
        words = ''
        counter = 0
        digits = int(digits)
        while counter < digits:
            current = temp_num % 10
            if counter % 2 == 0:
                addition = ''
                if counter in placevalue.keys() and current != 0:
                    addition = placevalue[counter]
                if counter == 2:
                    words = singles[current] + addition + words
                elif counter == 0:
                    if temp_num % 100 // 10 == 1:
                        words = teens[current] + addition + words
                        temp_num = temp_num // 10
                        counter += 1
                    else:
                        words = singles[current] + addition + words
                else:
                    words = doubles[current] + addition + words
            elif counter == 1:
                if current == 1:
                    words = teens[number % 10] + words
                else:
                    addition = ''
                    if counter in placevalue.keys():
                        addition = placevalue[counter]
                    words = doubles[current] + addition + words
            else:
                addition = ''
                if counter in placevalue.keys():
                    if current == 0 and temp_num % 100 // 10 == 0:
                        addition = ''
                    else:
                        addition = placevalue[counter]
                if temp_num % 100 // 10 == 1:
                    words = teens[current] + addition + words
                    temp_num = temp_num // 10
                    counter += 1
                else:
                    words = singles[current] + addition + words
            counter += 1
            temp_num = temp_num // 10
    return words",0.5946207,0.9896067
convert_to_str,convert_to_2d,convert_to_str converts the non-negative number list into a string.,"convert_to_2d >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)
(7.6923076923076925, 15.384615384615385)

>>> convert_to_2d(1, 2, 3, 10, 10)
(7.6923076923076925, 15.384615384615385)

>>> convert_to_2d(""1"", 2, 3, 10, 10)  # '1' is str
Traceback (most recent call last):
    ...
TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]","def convert_to_str(l: Node) -> str:
    """"""
        converts the non-negative number list into a string.
    """"""
    result = ''
    while l:
        result += str(l.val)
        l = l.next
    return result","def convert_to_2d(x: float, y: float, z: float, scale: float, distance: float) -> tuple[float, float]:
    """"""
    Converts 3d point to a 2d drawable point

    >>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)
    (7.6923076923076925, 15.384615384615385)

    >>> convert_to_2d(1, 2, 3, 10, 10)
    (7.6923076923076925, 15.384615384615385)

    >>> convert_to_2d(""1"", 2, 3, 10, 10)  # '1' is str
    Traceback (most recent call last):
        ...
    TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]
    """"""
    if not all((isinstance(val, (float, int)) for val in locals().values())):
        raise TypeError(f'Input values must either be float or int: {list(locals().values())}')
    projected_x = x * distance / (z + distance) * scale
    projected_y = y * distance / (z + distance) * scale
    return (projected_x, projected_y)",0.5837446,0.20440851
is_palindrome_dict,is_substring_divisible,"is_palindrome_dict and the values are the positions at which these values occur in the list.
We then iterate over the dict and if there is more than one key with an odd
number of occurrences, bail out and return False.
Otherwise, we want to ensure that the positions of occurrence sum to the
value of the length of the list - 1, working from the outside of the list inward.
For example:
Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1
d = {1: [0,1,5,6], 2: [2,4], 3: [3]}
'3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.","is_substring_divisible all the divisibility tests.
>>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))
False
>>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))
False
>>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))
True","def is_palindrome_dict(head):
    """"""
    This function builds up a dictionary where the keys are the values of the list,
    and the values are the positions at which these values occur in the list.
    We then iterate over the dict and if there is more than one key with an odd
    number of occurrences, bail out and return False.
    Otherwise, we want to ensure that the positions of occurrence sum to the
    value of the length of the list - 1, working from the outside of the list inward.
    For example:
    Input: 1 -> 1 -> 2 -> 3 -> 2 -> 1 -> 1
    d = {1: [0,1,5,6], 2: [2,4], 3: [3]}
    '3' is the middle outlier, 2+4=6, 0+6=6 and 5+1=6 so we have a palindrome.
    """"""
    if not head or not head.next:
        return True
    d = {}
    pos = 0
    while head:
        if head.val in d.keys():
            d[head.val].append(pos)
        else:
            d[head.val] = [pos]
        head = head.next
        pos += 1
    checksum = pos - 1
    middle = 0
    for v in d.values():
        if len(v) % 2 != 0:
            middle += 1
        else:
            step = 0
            for i in range(0, len(v)):
                if v[i] + v[len(v) - 1 - step] != checksum:
                    return False
                step += 1
        if middle > 1:
            return False
    return True","def is_substring_divisible(num: tuple) -> bool:
    """"""
    Returns True if the pandigital number passes
    all the divisibility tests.
    >>> is_substring_divisible((0, 1, 2, 4, 6, 5, 7, 3, 8, 9))
    False
    >>> is_substring_divisible((5, 1, 2, 4, 6, 0, 7, 8, 3, 9))
    False
    >>> is_substring_divisible((1, 4, 0, 6, 3, 5, 7, 2, 8, 9))
    True
    """"""
    if num[3] % 2 != 0:
        return False
    if (num[2] + num[3] + num[4]) % 3 != 0:
        return False
    if num[5] % 5 != 0:
        return False
    tests = [7, 11, 13, 17]
    for (i, test) in enumerate(tests):
        if (num[i + 4] * 100 + num[i + 5] * 10 + num[i + 6]) % test != 0:
            return False
    return True",0.6133047,0.9937937
remove_dups,allocation_num,remove_dups Space Complexity: O(N),allocation_num Divide a number of bytes into x partitions.,"def remove_dups(head):
    """"""
    Time Complexity: O(N)
    Space Complexity: O(N)
    """"""
    hashset = set()
    prev = Node()
    while head:
        if head.val in hashset:
            prev.next = head.next
        else:
            hashset.add(head.val)
            prev = head
        head = head.next","def allocation_num(number_of_bytes: int, partitions: int) -> list[str]:
    """"""
    Divide a number of bytes into x partitions.
    :param number_of_bytes: the total of bytes.
    :param partitions: the number of partition need to be allocated.
    :return: list of bytes to be assigned to each worker thread

    >>> allocation_num(16647, 4)
    ['1-4161', '4162-8322', '8323-12483', '12484-16647']
    >>> allocation_num(50000, 5)
    ['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']
    >>> allocation_num(888, 999)
    Traceback (most recent call last):
        ...
    ValueError: partitions can not > number_of_bytes!
    >>> allocation_num(888, -4)
    Traceback (most recent call last):
        ...
    ValueError: partitions must be a positive number!
    """"""
    if partitions <= 0:
        raise ValueError('partitions must be a positive number!')
    if partitions > number_of_bytes:
        raise ValueError('partitions can not > number_of_bytes!')
    bytes_per_partition = number_of_bytes // partitions
    allocation_list = []
    for i in range(partitions):
        start_bytes = i * bytes_per_partition + 1
        end_bytes = number_of_bytes if i == partitions - 1 else (i + 1) * bytes_per_partition
        allocation_list.append(f'{start_bytes}-{end_bytes}')
    return allocation_list",0.49041736,0.0019540724
remove_dups_wothout_set,largest_square_area_in_matrix_top_down_approch_with_dp,remove_dups_wothout_set Space Complexity: O(1),"largest_square_area_in_matrix_top_down_approch_with_dp square with maximum area.

We are using dp_array here, so the time complexity would be O(N^2).

>>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])
0","def remove_dups_wothout_set(head):
    """"""
    Time Complexity: O(N^2)
    Space Complexity: O(1)
    """"""
    current = head
    while current:
        runner = current
        while runner.next:
            if runner.next.val == current.val:
                runner.next = runner.next.next
            else:
                runner = runner.next
        current = current.next","def largest_square_area_in_matrix_top_down_approch_with_dp(rows: int, cols: int, mat: list[list[int]]) -> int:
    """"""
    Function updates the largest_square_area[0], if recursive call found
    square with maximum area.

    We are using dp_array here, so the time complexity would be O(N^2).

    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])
    0
    """"""

    def update_area_of_max_square_using_dp_array(row: int, col: int, dp_array: list[list[int]]) -> int:
        if row >= rows or col >= cols:
            return 0
        if dp_array[row][col] != -1:
            return dp_array[row][col]
        right = update_area_of_max_square_using_dp_array(row, col + 1, dp_array)
        diagonal = update_area_of_max_square_using_dp_array(row + 1, col + 1, dp_array)
        down = update_area_of_max_square_using_dp_array(row + 1, col, dp_array)
        if mat[row][col]:
            sub_problem_sol = 1 + min([right, diagonal, down])
            largest_square_area[0] = max(largest_square_area[0], sub_problem_sol)
            dp_array[row][col] = sub_problem_sol
            return sub_problem_sol
        else:
            return 0
    largest_square_area = [0]
    dp_array = [[-1] * cols for _ in range(rows)]
    update_area_of_max_square_using_dp_array(0, 0, dp_array)
    return largest_square_area[0]",0.508772,0.013486381
kth_to_last_eval,filter_valid_chars,kth_to_last_eval safe for user input. We guard against danger by ensuring k in an int,"filter_valid_chars key. Return a list of the possible decrypted messages.
>>> from itertools import cycle
>>> text = ""The enemy's gate is down""
>>> key = ""end""
>>> encoded = [ord(k) ^ ord(c) for k,c in zip(cycle(key), text)]
>>> text in filter_valid_chars(encoded)
True","def kth_to_last_eval(head, k):
    """"""
    This is a suboptimal, hacky method using eval(), which is not
     safe for user input. We guard against danger by ensuring k in an int
    """"""
    if not isinstance(k, int) or not head.val:
        return False
    nexts = '.'.join(['next' for n in range(1, k + 1)])
    seeker = str('.'.join(['head', nexts]))
    while head:
        if eval(seeker) is None:
            return head
        else:
            head = head.next
    return False","def filter_valid_chars(ciphertext: list[int]) -> list[str]:
    """"""
    Given an encrypted message, test all 3-character strings to try and find the
    key. Return a list of the possible decrypted messages.
    >>> from itertools import cycle
    >>> text = ""The enemy's gate is down""
    >>> key = ""end""
    >>> encoded = [ord(k) ^ ord(c) for k,c in zip(cycle(key), text)]
    >>> text in filter_valid_chars(encoded)
    True
    """"""
    possibles: list[str] = []
    for key in product(LOWERCASE_INTS, repeat=3):
        encoded = try_key(ciphertext, key)
        if encoded is not None:
            possibles.append(encoded)
    return possibles",0.4305063,0.0075452942
kth_to_last_dict,_validate_dicts,"kth_to_last_dict Then we check it for the value we need. If the key is not in the dict,
our and statement will short circuit and return False","_validate_dicts >>> _validate_dicts(""invalid"", {""d"": {""e"": 0.6}}, {""f"": {""g"": 0.7}})
Traceback (most recent call last):
        ...
ValueError: initial_probabilities must be a dict
>>> _validate_dicts({""c"":0.5}, {2: {""e"": 0.6}}, {""f"": {""g"": 0.7}})
Traceback (most recent call last):
        ...
ValueError: transition_probabilities all keys must be strings
>>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {2: 0.7}})
Traceback (most recent call last):
        ...
ValueError: emission_probabilities all keys must be strings
>>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {""g"": ""h""}})
Traceback (most recent call last):
        ...
ValueError: emission_probabilities nested dictionary all values must be float","def kth_to_last_dict(head, k):
    """"""
    This is a brute force method where we keep a dict the size of the list
    Then we check it for the value we need. If the key is not in the dict,
    our and statement will short circuit and return False
    """"""
    if not (head and k > -1):
        return False
    d = dict()
    count = 0
    while head:
        d[count] = head
        head = head.next
        count += 1
    return len(d) - k in d and d[len(d) - k]","def _validate_dicts(initial_probabilities: Any, transition_probabilities: Any, emission_probabilities: Any) -> None:
    """"""
    >>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {""g"": 0.7}})

    >>> _validate_dicts(""invalid"", {""d"": {""e"": 0.6}}, {""f"": {""g"": 0.7}})
    Traceback (most recent call last):
            ...
    ValueError: initial_probabilities must be a dict
    >>> _validate_dicts({""c"":0.5}, {2: {""e"": 0.6}}, {""f"": {""g"": 0.7}})
    Traceback (most recent call last):
            ...
    ValueError: transition_probabilities all keys must be strings
    >>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {2: 0.7}})
    Traceback (most recent call last):
            ...
    ValueError: emission_probabilities all keys must be strings
    >>> _validate_dicts({""c"":0.5}, {""d"": {""e"": 0.6}}, {""f"": {""g"": ""h""}})
    Traceback (most recent call last):
            ...
    ValueError: emission_probabilities nested dictionary all values must be float
    """"""
    _validate_dict(initial_probabilities, 'initial_probabilities', float)
    _validate_nested_dict(transition_probabilities, 'transition_probabilities')
    _validate_nested_dict(emission_probabilities, 'emission_probabilities')",0.58217454,0.6935405
kth_to_last,kth_permutation,"kth_to_last We move p1 k steps ahead into the list.
Then we move p1 and p2 together until p1 hits the end.","kth_permutation 0,1,2,...n-1 in O(n^2) time.

Examples:
First permutation is always 0,1,2,...n
>>> kth_permutation(0,5)
[0, 1, 2, 3, 4]

The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],
[0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],
[1,2,3,0], [1,3,0,2]
>>> kth_permutation(10,4)
[1, 3, 0, 2]","def kth_to_last(head, k):
    """"""
    This is an optimal method using iteration.
    We move p1 k steps ahead into the list.
    Then we move p1 and p2 together until p1 hits the end.
    """"""
    if not (head or k > -1):
        return False
    p1 = head
    p2 = head
    for i in range(1, k + 1):
        if p1 is None:
            raise IndexError
        p1 = p1.next
    while p1:
        p1 = p1.next
        p2 = p2.next
    return p2","def kth_permutation(k, n):
    """"""
    Finds k'th lexicographic permutation (in increasing order) of
    0,1,2,...n-1 in O(n^2) time.

    Examples:
    First permutation is always 0,1,2,...n
    >>> kth_permutation(0,5)
    [0, 1, 2, 3, 4]

    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],
    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],
    [1,2,3,0], [1,3,0,2]
    >>> kth_permutation(10,4)
    [1, 3, 0, 2]
    """"""
    factorials = [1]
    for i in range(2, n):
        factorials.append(factorials[-1] * i)
    assert 0 <= k < factorials[-1] * n, 'k out of bounds'
    permutation = []
    elements = list(range(n))
    while factorials:
        factorial = factorials.pop()
        (number, k) = divmod(k, factorial)
        permutation.append(elements[number])
        elements.remove(elements[number])
    permutation.append(elements[0])
    return permutation",0.5876828,0.01936448
two_sum1,two_sum,"two_sum1 sum is the given target.

Using a hash table.","two_sum [0, 1]
>>> two_sum([15, 2, 11, 7], 13)
[1, 2]
>>> two_sum([2, 7, 11, 15], 17)
[0, 3]
>>> two_sum([7, 15, 11, 2], 18)
[0, 2]
>>> two_sum([2, 7, 11, 15], 26)
[2, 3]
>>> two_sum([2, 7, 11, 15], 8)
[]
>>> two_sum([3 * i for i in range(10)], 19)
[]","def two_sum1(numbers, target):
    """"""
    Given a list of numbers, find the indices of two numbers such that their
    sum is the given target.

    Using a hash table.
    """"""
    dic = {}
    for (i, num) in enumerate(numbers):
        if target - num in dic:
            return [dic[target - num] + 1, i + 1]
        dic[num] = i
    return None","def two_sum(nums: list[int], target: int) -> list[int]:
    """"""
    >>> two_sum([2, 7, 11, 15], 9)
    [0, 1]
    >>> two_sum([15, 2, 11, 7], 13)
    [1, 2]
    >>> two_sum([2, 7, 11, 15], 17)
    [0, 3]
    >>> two_sum([7, 15, 11, 2], 18)
    [0, 2]
    >>> two_sum([2, 7, 11, 15], 26)
    [2, 3]
    >>> two_sum([2, 7, 11, 15], 8)
    []
    >>> two_sum([3 * i for i in range(10)], 19)
    []
    """"""
    chk_map: dict[int, int] = {}
    for (index, val) in enumerate(nums):
        compl = target - val
        if compl in chk_map:
            return [chk_map[compl], index]
        chk_map[val] = index
    return []",0.7106629,0.9997961
two_sum2,sum_reverse,"two_sum2 numbers such that their sum is the given target.

Using a bidirectional linear search.","sum_reverse >>> sum_reverse(123)
444
>>> sum_reverse(3478)
12221
>>> sum_reverse(12)
33","def two_sum2(numbers, target):
    """"""
    Given a list of numbers sorted in ascending order, find the indices of two
    numbers such that their sum is the given target.

    Using a bidirectional linear search.
    """"""
    left = 0
    right = len(numbers) - 1
    while left < right:
        current_sum = numbers[left] + numbers[right]
        if current_sum == target:
            return [left + 1, right + 1]
        if current_sum > target:
            right = right - 1
        else:
            left = left + 1","def sum_reverse(n: int) -> int:
    """"""
    Returns the sum of n and reverse of n.
    >>> sum_reverse(123)
    444
    >>> sum_reverse(3478)
    12221
    >>> sum_reverse(12)
    33
    """"""
    return int(n) + int(str(n)[::-1])",0.67350656,0.0047052563
next_greatest_letter,go_next,next_greatest_letter Using bisect libarary,go_next Check if we have to move forward to the next characters or not,"def next_greatest_letter(letters, target):
    """"""
    Using bisect libarary
    """"""
    index = bisect.bisect(letters, target)
    return letters[index % len(letters)]","def go_next(i: int, z_result: list[int], s: str) -> bool:
    """"""
    Check if we have to move forward to the next characters or not
    """"""
    return i + z_result[i] < len(s) and s[z_result[i]] == s[i + z_result[i]]",0.52743876,0.9857145
next_greatest_letter_v1,rabin_karp,next_greatest_letter_v1 Using binary search: complexity O(logN),"rabin_karp with complexity O(nm), most efficient when it is used with multiple patterns
as it is able to check if any of a set of patterns match a section of text in o(1)
given the precomputed hashes.

This will be the simple version which only assumes one pattern is being searched
for but it's not hard to modify

1) Calculate pattern hash

2) Step through the text one character at a time passing a window with the same
    length as the pattern
    calculating the hash of the text within the window compare it with the hash
    of the pattern. Only testing equality if the hashes match","def next_greatest_letter_v1(letters, target):
    """"""
    Using binary search: complexity O(logN)
    """"""
    if letters[0] > target:
        return letters[0]
    if letters[len(letters) - 1] <= target:
        return letters[0]
    (left, right) = (0, len(letters) - 1)
    while left <= right:
        mid = left + (right - left) // 2
        if letters[mid] > target:
            right = mid - 1
        else:
            left = mid + 1
    return letters[left]","def rabin_karp(pattern: str, text: str) -> bool:
    """"""
    The Rabin-Karp Algorithm for finding a pattern within a piece of text
    with complexity O(nm), most efficient when it is used with multiple patterns
    as it is able to check if any of a set of patterns match a section of text in o(1)
    given the precomputed hashes.

    This will be the simple version which only assumes one pattern is being searched
    for but it's not hard to modify

    1) Calculate pattern hash

    2) Step through the text one character at a time passing a window with the same
        length as the pattern
        calculating the hash of the text within the window compare it with the hash
        of the pattern. Only testing equality if the hashes match
    """"""
    p_len = len(pattern)
    t_len = len(text)
    if p_len > t_len:
        return False
    p_hash = 0
    text_hash = 0
    modulus_power = 1
    for i in range(p_len):
        p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus
        text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus
        if i == p_len - 1:
            continue
        modulus_power = modulus_power * alphabet_size % modulus
    for i in range(0, t_len - p_len + 1):
        if text_hash == p_hash and text[i:i + p_len] == pattern:
            return True
        if i == t_len - p_len:
            continue
        text_hash = ((text_hash - ord(text[i]) * modulus_power) * alphabet_size + ord(text[i + p_len])) % modulus
    return False",0.5920542,0.011703715
next_greatest_letter_v2,next_greatest_element,next_greatest_letter_v2 Brute force: complexity O(N),"next_greatest_element Maximum element present after the current one which is also greater than the
current one.

A naive way to solve this is to take two loops and check for the next bigger
number but that will make the time complexity as O(n^2). The better way to solve
this would be to use a stack to keep track of maximum number giving a linear time
solution.
>>> next_greatest_element(arr) == expect
True","def next_greatest_letter_v2(letters, target):
    """"""
    Brute force: complexity O(N)
    """"""
    for index in letters:
        if index > target:
            return index
    return letters[0]","def next_greatest_element(arr: list[float]) -> list[float]:
    """"""
    Get the Next Greatest Element (NGE) for all elements in a list.
    Maximum element present after the current one which is also greater than the
    current one.

    A naive way to solve this is to take two loops and check for the next bigger
    number but that will make the time complexity as O(n^2). The better way to solve
    this would be to use a stack to keep track of maximum number giving a linear time
    solution.
    >>> next_greatest_element(arr) == expect
    True
    """"""
    arr_size = len(arr)
    stack: list[float] = []
    result: list[float] = [-1] * arr_size
    for index in reversed(range(arr_size)):
        if stack:
            while stack[-1] <= arr[index]:
                stack.pop()
                if not stack:
                    break
        if stack:
            result[index] = stack[-1]
        stack.append(arr[index])
    return result",0.6476736,0.9933484
ternary_search,ite_ternary_search,"ternary_search Returns the index of the value if found, and -1 otherwise.
If the index is not in the range left..right (ie. left <= index < right) returns -1.","ite_ternary_search >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
>>> ite_ternary_search(test_list, 3)
-1
>>> ite_ternary_search(test_list, 13)
4
>>> ite_ternary_search([4, 5, 6, 7], 4)
0
>>> ite_ternary_search([4, 5, 6, 7], -10)
-1
>>> ite_ternary_search([-18, 2], -18)
0
>>> ite_ternary_search([5], 5)
0
>>> ite_ternary_search(['a', 'c', 'd'], 'c')
1
>>> ite_ternary_search(['a', 'c', 'd'], 'f')
-1
>>> ite_ternary_search([], 1)
-1
>>> ite_ternary_search([.1, .4 , -.1], .1)
0","def ternary_search(left, right, key, arr):
    """"""
    Find the given value (key) in an array sorted in ascending order.
    Returns the index of the value if found, and -1 otherwise.
    If the index is not in the range left..right (ie. left <= index < right) returns -1.
    """"""
    while right >= left:
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        if key == arr[mid1]:
            return mid1
        if key == mid2:
            return mid2
        if key < arr[mid1]:
            right = mid1 - 1
        elif key > arr[mid2]:
            left = mid2 + 1
        else:
            left = mid1 + 1
            right = mid2 - 1
    return -1","def ite_ternary_search(array: list[int], target: int) -> int:
    """"""Iterative method of the ternary search algorithm.
    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
    >>> ite_ternary_search(test_list, 3)
    -1
    >>> ite_ternary_search(test_list, 13)
    4
    >>> ite_ternary_search([4, 5, 6, 7], 4)
    0
    >>> ite_ternary_search([4, 5, 6, 7], -10)
    -1
    >>> ite_ternary_search([-18, 2], -18)
    0
    >>> ite_ternary_search([5], 5)
    0
    >>> ite_ternary_search(['a', 'c', 'd'], 'c')
    1
    >>> ite_ternary_search(['a', 'c', 'd'], 'f')
    -1
    >>> ite_ternary_search([], 1)
    -1
    >>> ite_ternary_search([.1, .4 , -.1], .1)
    0
    """"""
    left = 0
    right = len(array)
    while left <= right:
        if right - left < precision:
            return lin_search(left, right, array, target)
        one_third = (left + right) // 3 + 1
        two_third = 2 * (left + right) // 3 + 1
        if array[one_third] == target:
            return one_third
        elif array[two_third] == target:
            return two_third
        elif target < array[one_third]:
            right = one_third - 1
        elif array[two_third] < target:
            left = two_third + 1
        else:
            left = one_third + 1
            right = two_third - 1
    else:
        return -1",0.61827606,0.9999913
search_insert,binary_search_insertion,"search_insert found. If not, return the index where it would be if it were inserted in order.

For example:
[1,3,5,6], 5 -> 2
[1,3,5,6], 2 -> 1
[1,3,5,6], 7 -> 4
[1,3,5,6], 0 -> 0","binary_search_insertion [1, 2, 4, 7, 9, 10]","def search_insert(array, val):
    """"""
    Given a sorted array and a target value, return the index if the target is
    found. If not, return the index where it would be if it were inserted in order.

    For example:
    [1,3,5,6], 5 -> 2
    [1,3,5,6], 2 -> 1
    [1,3,5,6], 7 -> 4
    [1,3,5,6], 0 -> 0
    """"""
    low = 0
    high = len(array) - 1
    while low <= high:
        mid = low + (high - low) // 2
        if val > array[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return low","def binary_search_insertion(sorted_list, item):
    """"""
    >>> binary_search_insertion([1, 2, 7, 9, 10], 4)
    [1, 2, 4, 7, 9, 10]
    """"""
    left = 0
    right = len(sorted_list) - 1
    while left <= right:
        middle = (left + right) // 2
        if left == right:
            if sorted_list[middle] < item:
                left = middle + 1
            break
        elif sorted_list[middle] < item:
            left = middle + 1
        else:
            right = middle - 1
    sorted_list.insert(left, item)
    return sorted_list",0.75194156,0.9999666
search_rotate,rotation,search_rotate ascending order and then rotated at some unknown pivot.,"rotation [[0.5253219888177297, -0.8509035245341184],
 [0.8509035245341184, 0.5253219888177297]]","def search_rotate(array, val):
    """"""
    Finds the index of the given value in an array that has been sorted in
    ascending order and then rotated at some unknown pivot.
    """"""
    (low, high) = (0, len(array) - 1)
    while low <= high:
        mid = (low + high) // 2
        if val == array[mid]:
            return mid
        if array[low] <= array[mid]:
            if array[low] <= val <= array[mid]:
                high = mid - 1
            else:
                low = mid + 1
        elif array[mid] <= val <= array[high]:
            low = mid + 1
        else:
            high = mid - 1
    return -1","def rotation(angle: float) -> list[list[float]]:
    """"""
    >>> rotation(45)  # doctest: +NORMALIZE_WHITESPACE
    [[0.5253219888177297, -0.8509035245341184],
     [0.8509035245341184, 0.5253219888177297]]
    """"""
    (c, s) = (cos(angle), sin(angle))
    return [[c, -s], [s, c]]",0.5835152,5.8760357e-05
search_rotate_recur,calculate_turnaroundtime,search_rotate_recur ascending order and then rotated at some unknown pivot.,"calculate_turnaroundtime Return: list of turn around times.
>>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])
[3, 6, 10, 1]
>>> calculate_turnaroundtime([3,3], 2, [0,3])
[3, 6]
>>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])
[9, 10, 4]","def search_rotate_recur(array, low, high, val):
    """"""
    Finds the index of the given value in an array that has been sorted in
    ascending order and then rotated at some unknown pivot.
    """"""
    if low >= high:
        return -1
    mid = (low + high) // 2
    if val == array[mid]:
        return mid
    if array[low] <= array[mid]:
        if array[low] <= val <= array[mid]:
            return search_rotate_recur(array, low, mid - 1, val)
        return search_rotate_recur(array, mid + 1, high, val)
    if array[mid] <= val <= array[high]:
        return search_rotate_recur(array, mid + 1, high, val)
    return search_rotate_recur(array, low, mid - 1, val)","def calculate_turnaroundtime(burst_time: list[int], no_of_processes: int, waiting_time: list[int]) -> list[int]:
    """"""
    Calculate the turn around time of each Processes
    Return: list of turn around times.
    >>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])
    [3, 6, 10, 1]
    >>> calculate_turnaroundtime([3,3], 2, [0,3])
    [3, 6]
    >>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])
    [9, 10, 4]
    """"""
    turn_around_time = [0] * no_of_processes
    for i in range(no_of_processes):
        turn_around_time[i] = burst_time[i] + waiting_time[i]
    return turn_around_time",0.5823377,0.0013654681
first_occurrence,interpolation_search_by_recursion,first_occurrence The array has to be sorted in increasing order.,"interpolation_search_by_recursion Be careful collection must be ascending sorted, otherwise result will be
unpredictable
First recursion should be started with left=0 and right=(len(sorted_collection)-1)","def first_occurrence(array, query):
    """"""
    Returns the index of the first occurance of the given element in an array.
    The array has to be sorted in increasing order.
    """"""
    (low, high) = (0, len(array) - 1)
    while low <= high:
        mid = (low + high) // 2
        if low == high:
            break
        if array[mid] < query:
            low = mid + 1
        else:
            high = mid
    if array[low] == query:
        return low","def interpolation_search_by_recursion(sorted_collection, item, left, right):
    """"""Pure implementation of interpolation search algorithm in Python by recursion
    Be careful collection must be ascending sorted, otherwise result will be
    unpredictable
    First recursion should be started with left=0 and right=(len(sorted_collection)-1)
    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found
    """"""
    if sorted_collection[left] == sorted_collection[right]:
        if sorted_collection[left] == item:
            return left
        else:
            return None
    point = left + (item - sorted_collection[left]) * (right - left) // (sorted_collection[right] - sorted_collection[left])
    if point < 0 or point >= len(sorted_collection):
        return None
    if sorted_collection[point] == item:
        return point
    elif point < left:
        return interpolation_search_by_recursion(sorted_collection, item, point, left)
    elif point > right:
        return interpolation_search_by_recursion(sorted_collection, item, right, left)
    elif sorted_collection[point] > item:
        return interpolation_search_by_recursion(sorted_collection, item, left, point - 1)
    else:
        return interpolation_search_by_recursion(sorted_collection, item, point + 1, right)",0.68603253,0.93320006
jump_search,jump_search,"jump_search All items in list must be sorted like binary search

Find block that contains target value and search it linearly in that block
It returns a first target value in array

reference: https://en.wikipedia.org/wiki/Jump_search","jump_search Examples:
>>> jump_search([0, 1, 2, 3, 4, 5], 3)
3
>>> jump_search([-5, -2, -1], -1)
2
>>> jump_search([0, 5, 10, 20], 8)
-1
>>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)
10","def jump_search(arr, target):
    """"""
    Worst-case Complexity: O(âˆšn) (root(n))
    All items in list must be sorted like binary search

    Find block that contains target value and search it linearly in that block
    It returns a first target value in array

    reference: https://en.wikipedia.org/wiki/Jump_search
    """"""
    length = len(arr)
    block_size = int(math.sqrt(length))
    block_prev = 0
    block = block_size
    if arr[length - 1] < target:
        return -1
    while block <= length and arr[block - 1] < target:
        block_prev = block
        block += block_size
    while arr[block_prev] < target:
        block_prev += 1
        if block_prev == min(block, length):
            return -1
    if arr[block_prev] == target:
        return block_prev
    return -1","def jump_search(arr: list, x: int) -> int:
    """"""
    Pure Python implementation of the jump search algorithm.
    Examples:
    >>> jump_search([0, 1, 2, 3, 4, 5], 3)
    3
    >>> jump_search([-5, -2, -1], -1)
    2
    >>> jump_search([0, 5, 10, 20], 8)
    -1
    >>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)
    10
    """"""
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n) - 1] < x:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1
    while arr[prev] < x:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == x:
        return prev
    return -1",0.6896012,0.9999925
find_min_rotate,rotate_180,find_min_rotate Finds the minimum element in a sorted array that has been rotated.,"rotate_180 [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]
>>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))
True","def find_min_rotate(array):
    """"""
    Finds the minimum element in a sorted array that has been rotated.
    """"""
    low = 0
    high = len(array) - 1
    while low < high:
        mid = (low + high) // 2
        if array[mid] > array[high]:
            low = mid + 1
        else:
            high = mid
    return array[low]","def rotate_180(matrix: list[list[int]]) -> list[list[int]]:
    """"""
    >>> rotate_180(make_matrix())
    [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]
    >>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))
    True
    """"""
    return reverse_row(reverse_column(matrix))",0.6127567,0.38833973
find_min_rotate_recur,rotate_90,find_min_rotate_recur Finds the minimum element in a sorted array that has been rotated.,"rotate_90 [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]
>>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))
True","def find_min_rotate_recur(array, low, high):
    """"""
    Finds the minimum element in a sorted array that has been rotated.
    """"""
    mid = (low + high) // 2
    if mid == low:
        return array[low]
    if array[mid] > array[high]:
        return find_min_rotate_recur(array, mid + 1, high)
    return find_min_rotate_recur(array, low, mid)","def rotate_90(matrix: list[list[int]]) -> list[list[int]]:
    """"""
    >>> rotate_90(make_matrix())
    [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]
    >>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))
    True
    """"""
    return reverse_row(transpose(matrix))",0.6011425,0.22548388
binary_search,binary_search_by_recursion,"binary_search (before current job) that doesn't conflict with current
job.  ""index"" is index of the current job.  This function
returns -1 if all jobs before index conflict with it.
The array jobs[] is sorted in increasing order of finish
time.","binary_search_by_recursion Be careful collection must be ascending sorted, otherwise result will be
unpredictable
First recursion should be started with left=0 and right=(len(sorted_collection)-1)","def binary_search(job, start_index):
    """"""
    A Binary Search based function to find the latest job
    (before current job) that doesn't conflict with current
    job.  ""index"" is index of the current job.  This function
    returns -1 if all jobs before index conflict with it.
    The array jobs[] is sorted in increasing order of finish
    time.
    """"""
    left = 0
    right = start_index - 1
    while left <= right:
        mid = (left + right) // 2
        if job[mid].finish <= job[start_index].start:
            if job[mid + 1].finish <= job[start_index].start:
                left = mid + 1
            else:
                return mid
        else:
            right = mid - 1
    return -1","def binary_search_by_recursion(sorted_collection: list[int], item: int, left: int, right: int) -> int | None:
    """"""Pure implementation of binary search algorithm in Python by recursion

    Be careful collection must be ascending sorted, otherwise result will be
    unpredictable
    First recursion should be started with left=0 and right=(len(sorted_collection)-1)

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)
    0

    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)
    4

    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)
    1

    >>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)

    """"""
    if right < left:
        return None
    midpoint = left + (right - left) // 2
    if sorted_collection[midpoint] == item:
        return midpoint
    elif sorted_collection[midpoint] > item:
        return binary_search_by_recursion(sorted_collection, item, left, midpoint - 1)
    else:
        return binary_search_by_recursion(sorted_collection, item, midpoint + 1, right)",0.5607738,0.9974498
binary_search_recur,binary_search_std_lib,binary_search_recur reference: https://en.wikipedia.org/wiki/Binary_search_algorithm,"binary_search_std_lib Be careful collection must be ascending sorted, otherwise result will be
unpredictable","def binary_search_recur(array, low, high, val):
    """"""
    Worst-case Complexity: O(log(n))

    reference: https://en.wikipedia.org/wiki/Binary_search_algorithm
    """"""
    if low > high:
        return -1
    mid = (low + high) // 2
    if val < array[mid]:
        return binary_search_recur(array, low, mid - 1, val)
    if val > array[mid]:
        return binary_search_recur(array, mid + 1, high, val)
    return mid","def binary_search_std_lib(sorted_collection: list[int], item: int) -> int | None:
    """"""Pure implementation of binary search algorithm in Python using stdlib

    Be careful collection must be ascending sorted, otherwise result will be
    unpredictable

    :param sorted_collection: some ascending sorted collection with comparable items
    :param item: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> binary_search_std_lib([0, 5, 7, 10, 15], 0)
    0

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 15)
    4

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 5)
    1

    >>> binary_search_std_lib([0, 5, 7, 10, 15], 6)

    """"""
    index = bisect.bisect_left(sorted_collection, item)
    if index != len(sorted_collection) and sorted_collection[index] == item:
        return index
    return None",0.58970416,0.98608243
last_occurrence,get_distinct_edge,last_occurrence The array has to be sorted in increasing order.,"get_distinct_edge >>> sorted(get_distinct_edge(edge_array))
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']","def last_occurrence(array, query):
    """"""
    Returns the index of the last occurance of the given element in an array.
    The array has to be sorted in increasing order.
    """"""
    (low, high) = (0, len(array) - 1)
    while low <= high:
        mid = (high + low) // 2
        if array[mid] == query and mid == len(array) - 1 or (array[mid] == query and array[mid + 1] > query):
            return mid
        if array[mid] <= query:
            low = mid + 1
        else:
            high = mid - 1","def get_distinct_edge(edge_array):
    """"""
    Return Distinct edges from edge array of multiple graphs
    >>> sorted(get_distinct_edge(edge_array))
    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
    """"""
    distinct_edge = set()
    for row in edge_array:
        for item in row:
            distinct_edge.add(item[0])
    return list(distinct_edge)",0.6108074,0.28480712
linear_search,lin_search,"linear_search There are no restrictions on the order of the elements in the array.
If the element couldn't be found, returns -1.",lin_search Perform linear search in list. Returns -1 if element is not found.,"def linear_search(array, query):
    """"""
    Find the index of the given element in the array.
    There are no restrictions on the order of the elements in the array.
    If the element couldn't be found, returns -1.
    """"""
    for (i, value) in enumerate(array):
        if value == query:
            return i
    return -1","def lin_search(left: int, right: int, array: list[int], target: int) -> int:
    """"""Perform linear search in list. Returns -1 if element is not found.

    Parameters
    ----------
    left : int
        left index bound.
    right : int
        right index bound.
    array : List[int]
        List of elements to be searched on
    target : int
        Element that is searched

    Returns
    -------
    int
        index of element that is looked for.

    Examples
    --------
    >>> lin_search(0, 4, [4, 5, 6, 7], 7)
    3
    >>> lin_search(0, 3, [4, 5, 6, 7], 7)
    -1
    >>> lin_search(0, 2, [-18, 2], -18)
    0
    >>> lin_search(0, 1, [5], 5)
    0
    >>> lin_search(0, 3, ['a', 'c', 'd'], 'c')
    1
    >>> lin_search(0, 3, [.1, .4 , -.1], .1)
    0
    >>> lin_search(0, 3, [.1, .4 , -.1], -.1)
    2
    """"""
    for i in range(left, right):
        if array[i] == target:
            return i
    return -1",0.6618105,0.99981207
find_path,run_maze,find_path Find a path between two nodes using recursion and backtracking.,"run_maze up, down, left, right.
If a path is found to destination it returns True otherwise it returns False.","def find_path(graph, start, end, path=[]):
    """"""
    Find a path between two nodes using recursion and backtracking.
    """"""
    path = path + [start]
    if start == end:
        return path
    if not start in graph:
        return None
    for node in graph[start]:
        if node not in path:
            newpath = find_path(graph, node, end, path)
            return newpath
    return None","def run_maze(maze: list[list[int]], i: int, j: int, solutions: list[list[int]]) -> bool:
    """"""
    This method is recursive starting from (i, j) and going in one of four directions:
    up, down, left, right.
    If a path is found to destination it returns True otherwise it returns False.
    Parameters:
        maze(2D matrix) : maze
        i, j : coordinates of matrix
        solutions(2D matrix) : solutions
    Returns:
        Boolean if path is found True, Otherwise False.
    """"""
    size = len(maze)
    if i == j == size - 1:
        solutions[i][j] = 1
        return True
    lower_flag = not i < 0 and (not j < 0)
    upper_flag = i < size and j < size
    if lower_flag and upper_flag:
        block_flag = not solutions[i][j] and (not maze[i][j])
        if block_flag:
            solutions[i][j] = 1
            if run_maze(maze, i + 1, j, solutions) or run_maze(maze, i, j + 1, solutions) or run_maze(maze, i - 1, j, solutions) or run_maze(maze, i, j - 1, solutions):
                return True
            solutions[i][j] = 0
            return False
    return False",0.6186199,0.79451746
edit_distance,hamming_distance,"edit_distance Kwyword arguments:
word_a -- string
word_b -- string","hamming_distance In information theory, the Hamming distance between two strings of equal
length is the number of positions at which the corresponding symbols are
different. https://en.wikipedia.org/wiki/Hamming_distance","def edit_distance(word_a, word_b):
    """"""Finds edit distance between word_a and word_b

    Kwyword arguments:
    word_a -- string
    word_b -- string
    """"""
    (length_a, length_b) = (len(word_a) + 1, len(word_b) + 1)
    edit = [[0 for _ in range(length_b)] for _ in range(length_a)]
    for i in range(1, length_a):
        edit[i][0] = i
    for j in range(1, length_b):
        edit[0][j] = j
    for i in range(1, length_a):
        for j in range(1, length_b):
            cost = 0 if word_a[i - 1] == word_b[j - 1] else 1
            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost)
    return edit[-1][-1]","def hamming_distance(string1: str, string2: str) -> int:
    """"""Calculate the Hamming distance between two equal length strings
    In information theory, the Hamming distance between two strings of equal
    length is the number of positions at which the corresponding symbols are
    different. https://en.wikipedia.org/wiki/Hamming_distance

    Args:
        string1 (str): Sequence 1
        string2 (str): Sequence 2

    Returns:
        int: Hamming distance

    >>> hamming_distance(""python"", ""python"")
    0
    >>> hamming_distance(""karolin"", ""kathrin"")
    3
    >>> hamming_distance(""00000"", ""11111"")
    5
    >>> hamming_distance(""karolin"", ""kath"")
    Traceback (most recent call last):
      ...
    ValueError: String lengths must match!
    """"""
    if len(string1) != len(string2):
        raise ValueError('String lengths must match!')
    count = 0
    for (char1, char2) in zip(string1, string2):
        if char1 != char2:
            count += 1
    return count",0.53913987,0.78933376
count,get_1s_count,"count Keyword arguments:
coins -- int[]
value -- int","get_1s_count Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
>>> get_1s_count(25)
3
>>> get_1s_count(37)
3
>>> get_1s_count(21)
3
>>> get_1s_count(58)
4
>>> get_1s_count(0)
0
>>> get_1s_count(256)
1
>>> get_1s_count(-1)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer
>>> get_1s_count(0.8)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer
>>> get_1s_count(""25"")
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer","def count(coins, value):
    """""" Find number of combination of `coins` that adds upp to `value`

    Keyword arguments:
    coins -- int[]
    value -- int
    """"""
    dp_array = [1] + [0] * value
    for coin in coins:
        for i in range(coin, value + 1):
            dp_array[i] += dp_array[i - coin]
    return dp_array[value]","def get_1s_count(number: int) -> int:
    """"""
    Count the number of set bits in a 32 bit integer using Brian Kernighan's way.
    Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
    >>> get_1s_count(25)
    3
    >>> get_1s_count(37)
    3
    >>> get_1s_count(21)
    3
    >>> get_1s_count(58)
    4
    >>> get_1s_count(0)
    0
    >>> get_1s_count(256)
    1
    >>> get_1s_count(-1)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    >>> get_1s_count(0.8)
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    >>> get_1s_count(""25"")
    Traceback (most recent call last):
        ...
    ValueError: Input must be a non-negative integer
    """"""
    if not isinstance(number, int) or number < 0:
        raise ValueError('Input must be a non-negative integer')
    count = 0
    while number:
        number &= number - 1
        count += 1
    return count",0.5278636,0.92705035
schedule,job_sequencing_with_deadlines,schedule profit from given array of jobs,"job_sequencing_with_deadlines Args:
    num_jobs [int]: Number of jobs
    jobs [list]: A list of tuples of (job_id, deadline, profit)

Returns:
    max_profit [int]: Maximum profit that can be earned by doing jobs
    in a given time frame

Examples:
>>> job_sequencing_with_deadlines(4,
... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)])
[2, 60]
>>> job_sequencing_with_deadlines(5,
... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)])
[2, 127]","def schedule(job):
    """"""
    The main function that returns the maximum possible
    profit from given array of jobs
    """"""
    job = sorted(job, key=lambda j: j.finish)
    length = len(job)
    table = [0 for _ in range(length)]
    table[0] = job[0].profit
    for i in range(1, length):
        incl_prof = job[i].profit
        pos = binary_search(job, i)
        if pos != -1:
            incl_prof += table[pos]
        table[i] = max(incl_prof, table[i - 1])
    return table[length - 1]","def job_sequencing_with_deadlines(num_jobs: int, jobs: list) -> list:
    """"""
    Function to find the maximum profit by doing jobs in a given time frame

    Args:
        num_jobs [int]: Number of jobs
        jobs [list]: A list of tuples of (job_id, deadline, profit)

    Returns:
        max_profit [int]: Maximum profit that can be earned by doing jobs
        in a given time frame

    Examples:
    >>> job_sequencing_with_deadlines(4,
    ... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)])
    [2, 60]
    >>> job_sequencing_with_deadlines(5,
    ... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)])
    [2, 127]
    """"""
    jobs = sorted(jobs, key=lambda value: value[2], reverse=True)
    max_deadline = max(jobs, key=lambda value: value[1])[1]
    time_slots = [-1] * max_deadline
    count = 0
    max_profit = 0
    for job in jobs:
        for i in range(job[1] - 1, -1, -1):
            if time_slots[i] == -1:
                time_slots[i] = job[0]
                count += 1
                max_profit += job[2]
                break
    return [count, max_profit]",0.61024755,0.9959539
hosoya,vol_spheres_intersect,hosoya height -- height of the triangle,"vol_spheres_intersect The intersection is composed by two spherical caps and therefore its volume is the
sum of the volumes of the spherical caps. First, it calculates the heights (h1, h2)
of the spherical caps, then the two volumes and it returns the sum.
The height formulas are
h1 = (radius_1 - radius_2 + centers_distance)
   * (radius_1 + radius_2 - centers_distance)
   / (2 * centers_distance)
h2 = (radius_2 - radius_1 + centers_distance)
   * (radius_2 + radius_1 - centers_distance)
   / (2 * centers_distance)
if centers_distance is 0 then it returns the volume of the smallers sphere
:return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)
>>> vol_spheres_intersect(2, 2, 1)
21.205750411731103
>>> vol_spheres_intersect(2.6, 2.6, 1.6)
40.71504079052372
>>> vol_spheres_intersect(0, 0, 0)
0.0
>>> vol_spheres_intersect(-2, 2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_intersect() only accepts non-negative values
>>> vol_spheres_intersect(2, -2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_intersect() only accepts non-negative values
>>> vol_spheres_intersect(2, 2, -1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_intersect() only accepts non-negative values","def hosoya(height, width):
    """""" Calculates the hosoya triangle

    height -- height of the triangle
    """"""
    if width == 0 and height in (0, 1):
        return 1
    if width == 1 and height in (1, 2):
        return 1
    if height > width:
        return hosoya(height - 1, width) + hosoya(height - 2, width)
    if width == height:
        return hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)
    return 0","def vol_spheres_intersect(radius_1: float, radius_2: float, centers_distance: float) -> float:
    """"""
    Calculate the volume of the intersection of two spheres.
    The intersection is composed by two spherical caps and therefore its volume is the
    sum of the volumes of the spherical caps. First, it calculates the heights (h1, h2)
    of the spherical caps, then the two volumes and it returns the sum.
    The height formulas are
    h1 = (radius_1 - radius_2 + centers_distance)
       * (radius_1 + radius_2 - centers_distance)
       / (2 * centers_distance)
    h2 = (radius_2 - radius_1 + centers_distance)
       * (radius_2 + radius_1 - centers_distance)
       / (2 * centers_distance)
    if centers_distance is 0 then it returns the volume of the smallers sphere
    :return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)
    >>> vol_spheres_intersect(2, 2, 1)
    21.205750411731103
    >>> vol_spheres_intersect(2.6, 2.6, 1.6)
    40.71504079052372
    >>> vol_spheres_intersect(0, 0, 0)
    0.0
    >>> vol_spheres_intersect(-2, 2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_intersect() only accepts non-negative values
    >>> vol_spheres_intersect(2, -2, 1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_intersect() only accepts non-negative values
    >>> vol_spheres_intersect(2, 2, -1)
    Traceback (most recent call last):
        ...
    ValueError: vol_spheres_intersect() only accepts non-negative values
    """"""
    if radius_1 < 0 or radius_2 < 0 or centers_distance < 0:
        raise ValueError('vol_spheres_intersect() only accepts non-negative values')
    if centers_distance == 0:
        return vol_sphere(min(radius_1, radius_2))
    h1 = (radius_1 - radius_2 + centers_distance) * (radius_1 + radius_2 - centers_distance) / (2 * centers_distance)
    h2 = (radius_2 - radius_1 + centers_distance) * (radius_2 + radius_1 - centers_distance) / (2 * centers_distance)
    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)",0.4952472,0.48363763
print_hosoya,print_pascal_triangle,print_hosoya height -- height of the triangle,"print_pascal_triangle >>> print_pascal_triangle(5)
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1","def print_hosoya(height):
    """"""Prints the hosoya triangle

    height -- height of the triangle
    """"""
    for i in range(height):
        for j in range(i + 1):
            print(hosoya(i, j), end=' ')
        print('\n', end='')","def print_pascal_triangle(num_rows: int) -> None:
    """"""
    Print Pascal's triangle for different number of rows
    >>> print_pascal_triangle(5)
        1
       1 1
      1 2 1
     1 3 3 1
    1 4 6 4 1
    """"""
    triangle = generate_pascal_triangle(num_rows)
    for row_idx in range(num_rows):
        for _ in range(num_rows - row_idx - 1):
            print(end=' ')
        for col_idx in range(row_idx + 1):
            if col_idx != row_idx:
                print(triangle[row_idx][col_idx], end=' ')
            else:
                print(triangle[row_idx][col_idx], end='')
        print()",0.5663222,0.99790704
hosoya_testing,max_height,hosoya_testing height -- height of the triangle,"max_height Formula:
        v_0^2 * sin^2(alpha)
        --------------------
               2g
v_0 - initial velocity
alpha - angle
>>> max_height(30, 45)
22.94
>>> max_height(100, 78)
487.82
>>> max_height(""a"", 20)
Traceback (most recent call last):
    ...
TypeError: Invalid velocity. Should be a positive number.
>>> horizontal_distance(30, ""b"")
Traceback (most recent call last):
    ...
TypeError: Invalid angle. Range is 1-90 degrees.","def hosoya_testing(height):
    """"""Test hosoya function

    height -- height of the triangle
    """"""
    res = []
    for i in range(height):
        for j in range(i + 1):
            res.append(hosoya(i, j))
    return res","def max_height(init_velocity: float, angle: float) -> float:
    """"""
    Returns the maximum height that the object reach
    Formula:
            v_0^2 * sin^2(alpha)
            --------------------
                   2g
    v_0 - initial velocity
    alpha - angle
    >>> max_height(30, 45)
    22.94
    >>> max_height(100, 78)
    487.82
    >>> max_height(""a"", 20)
    Traceback (most recent call last):
        ...
    TypeError: Invalid velocity. Should be a positive number.
    >>> horizontal_distance(30, ""b"")
    Traceback (most recent call last):
        ...
    TypeError: Invalid angle. Range is 1-90 degrees.
    """"""
    check_args(init_velocity, angle)
    radians = angle_to_radians(angle)
    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)",0.5336458,3.0975934e-05
cut_rod,top_down_cut_rod,cut_rod price[] as prices of different pieces,"top_down_cut_rod problem via memoization. This function serves as a wrapper for
_top_down_cut_rod_recursive

Runtime: O(n^2)

Arguments
--------
n: int, the length of the rod
prices: list, the prices for each piece of rod. ``p[i-i]`` is the
price for a rod of length ``i``","def cut_rod(price):
    """"""
    Returns the best obtainable price for a rod of length n and
    price[] as prices of different pieces
    """"""
    n = len(price)
    val = [0] * (n + 1)
    for i in range(1, n + 1):
        max_val = INT_MIN
        for j in range(i):
            max_val = max(max_val, price[j] + val[i - j - 1])
        val[i] = max_val
    return val[n]","def top_down_cut_rod(n: int, prices: list):
    """"""
    Constructs a top-down dynamic programming solution for the rod-cutting
    problem via memoization. This function serves as a wrapper for
    _top_down_cut_rod_recursive

    Runtime: O(n^2)

    Arguments
    --------
    n: int, the length of the rod
    prices: list, the prices for each piece of rod. ``p[i-i]`` is the
    price for a rod of length ``i``

    Note
    ----
    For convenience and because Python's lists using 0-indexing, length(max_rev) =
    n + 1, to accommodate for the revenue obtainable from a rod of length 0.

    Returns
    -------
    The maximum revenue obtainable for a rod of length n given the list of prices
    for each piece.

    Examples
    -------
    >>> top_down_cut_rod(4, [1, 5, 8, 9])
    10
    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
    30
    """"""
    _enforce_args(n, prices)
    max_rev = [float('-inf') for _ in range(n + 1)]
    return _top_down_cut_rod_recursive(n, prices, max_rev)",0.6417819,0.9868593
max_profit_optimized,maximum_non_adjacent_sum,"max_profit_optimized diff : [X, -6, 4, -2, 3, -2]","maximum_non_adjacent_sum >>> maximum_non_adjacent_sum([1, 2, 3])
4
>>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])
18
>>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])
0
>>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])
500","def max_profit_optimized(prices):
    """"""
    input: [7, 1, 5, 3, 6, 4]
    diff : [X, -6, 4, -2, 3, -2]
    :type prices: List[int]
    :rtype: int
    """"""
    (cur_max, max_so_far) = (0, 0)
    for i in range(1, len(prices)):
        cur_max = max(0, cur_max + prices[i] - prices[i - 1])
        max_so_far = max(max_so_far, cur_max)
    return max_so_far","def maximum_non_adjacent_sum(nums: list[int]) -> int:
    """"""
    Find the maximum non-adjacent sum of the integers in the nums input list

    >>> maximum_non_adjacent_sum([1, 2, 3])
    4
    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])
    18
    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])
    0
    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])
    500
    """"""
    if not nums:
        return 0
    max_including = nums[0]
    max_excluding = 0
    for num in nums[1:]:
        (max_including, max_excluding) = (max_excluding + num, max(max_including, max_excluding))
    return max(max_excluding, max_including)",0.61889935,0.9996711
is_match,match_pattern,"is_match Keyword arguments:
str_a -- string
str_b -- string","match_pattern string with a given pattern.

Runtime: O(len(input_string)*len(pattern))

Arguments
--------
input_string: str, any string which should be compared with the pattern
pattern: str, the string that represents a pattern and may contain
'.' for single character matches and '*' for zero or more of preceding character
matches","def is_match(str_a, str_b):
    """"""Finds if `str_a` matches `str_b`

    Keyword arguments:
    str_a -- string
    str_b -- string
    """"""
    (len_a, len_b) = (len(str_a) + 1, len(str_b) + 1)
    matches = [[False] * len_b for _ in range(len_a)]
    matches[0][0] = True
    for (i, element) in enumerate(str_b[1:], 2):
        matches[0][i] = matches[0][i - 2] and element == '*'
    for (i, char_a) in enumerate(str_a, 1):
        for (j, char_b) in enumerate(str_b, 1):
            if char_b != '*':
                matches[i][j] = matches[i - 1][j - 1] and char_b in (char_a, '.')
            else:
                matches[i][j] |= matches[i][j - 2]
                if char_a == str_b[j - 2] or str_b[j - 2] == '.':
                    matches[i][j] |= matches[i - 1][j]
    return matches[-1][-1]","def match_pattern(input_string: str, pattern: str) -> bool:
    """"""
    uses bottom-up dynamic programming solution for matching the input
    string with a given pattern.

    Runtime: O(len(input_string)*len(pattern))

    Arguments
    --------
    input_string: str, any string which should be compared with the pattern
    pattern: str, the string that represents a pattern and may contain
    '.' for single character matches and '*' for zero or more of preceding character
    matches

    Note
    ----
    the pattern cannot start with a '*',
    because there should be at least one character before *

    Returns
    -------
    A Boolean denoting whether the given string follows the pattern

    Examples
    -------
    >>> match_pattern(""aab"", ""c*a*b"")
    True
    >>> match_pattern(""dabc"", ""*abc"")
    False
    >>> match_pattern(""aaa"", ""aa"")
    False
    >>> match_pattern(""aaa"", ""a.a"")
    True
    >>> match_pattern(""aaab"", ""aa*"")
    False
    >>> match_pattern(""aaab"", "".*"")
    True
    >>> match_pattern(""a"", ""bbbb"")
    False
    >>> match_pattern("""", ""bbbb"")
    False
    >>> match_pattern(""a"", """")
    False
    >>> match_pattern("""", """")
    True
    """"""
    len_string = len(input_string) + 1
    len_pattern = len(pattern) + 1
    dp = [[0 for i in range(len_pattern)] for j in range(len_string)]
    dp[0][0] = 1
    for i in range(1, len_string):
        dp[i][0] = 0
    for j in range(1, len_pattern):
        dp[0][j] = dp[0][j - 2] if pattern[j - 1] == '*' else 0
    for i in range(1, len_string):
        for j in range(1, len_pattern):
            if input_string[i - 1] == pattern[j - 1] or pattern[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif pattern[j - 1] == '*':
                if dp[i][j - 2] == 1:
                    dp[i][j] = 1
                elif pattern[j - 2] in (input_string[i - 1], '.'):
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = 0
            else:
                dp[i][j] = 0
    return bool(dp[-1][-1])",0.70508265,0.9999788
planting_trees,is_binary_search_tree,"planting_trees are all in a valid state.

    Parameters:
        tree (list<int>): A sorted list of integers with all trees'
                          position along the road.
        length (int): An integer with the length of the road.
        width (int): An integer with the width of the road.

    Returns:
        A float number with the total distance trees have been moved.","is_binary_search_tree ...                                left=TreeNode(data=1),
...                                right=TreeNode(data=3))
...                                )
True

>>> is_binary_search_tree(TreeNode(data=0,
...                                left=TreeNode(data=-11),
...                                right=TreeNode(data=3))
...                                )
True

>>> is_binary_search_tree(TreeNode(data=5,
...                                left=TreeNode(data=1),
...                                right=TreeNode(data=4, left=TreeNode(data=3)))
...                      )
False

>>> is_binary_search_tree(TreeNode(data='a',
...                                left=TreeNode(data=1),
...                                right=TreeNode(data=4, left=TreeNode(data=3)))
...                      )
Traceback (most recent call last):
 ...
ValueError: Each node should be type of TreeNode and data should be float.

>>> is_binary_search_tree(TreeNode(data=2,
...                                left=TreeNode([]),
...                                right=TreeNode(data=4, left=TreeNode(data=3)))
...                                )
Traceback (most recent call last):
 ...
ValueError: Each node should be type of TreeNode and data should be float.","def planting_trees(trees, length, width):
    """"""
    Returns the minimum distance that trees have to be moved before they
    are all in a valid state.

        Parameters:
            tree (list<int>): A sorted list of integers with all trees'
                              position along the road.
            length (int): An integer with the length of the road.
            width (int): An integer with the width of the road.

        Returns:
            A float number with the total distance trees have been moved.
    """"""
    trees = [0] + trees
    n_pairs = int(len(trees) / 2)
    space_between_pairs = length / (n_pairs - 1)
    target_locations = [location * space_between_pairs for location in range(n_pairs)]
    cmatrix = [[0 for _ in range(n_pairs + 1)] for _ in range(n_pairs + 1)]
    for r_i in range(1, n_pairs + 1):
        cmatrix[r_i][0] = cmatrix[r_i - 1][0] + sqrt(width + abs(trees[r_i] - target_locations[r_i - 1]) ** 2)
    for l_i in range(1, n_pairs + 1):
        cmatrix[0][l_i] = cmatrix[0][l_i - 1] + abs(trees[l_i] - target_locations[l_i - 1])
    for r_i in range(1, n_pairs + 1):
        for l_i in range(1, n_pairs + 1):
            cmatrix[r_i][l_i] = min(cmatrix[r_i - 1][l_i] + sqrt(width + (trees[l_i + r_i] - target_locations[r_i - 1]) ** 2), cmatrix[r_i][l_i - 1] + abs(trees[l_i + r_i] - target_locations[l_i - 1]))
    return cmatrix[n_pairs][n_pairs]","def is_binary_search_tree(root: TreeNode | None) -> bool:
    """"""
    >>> is_binary_search_tree(TreeNode(data=2,
    ...                                left=TreeNode(data=1),
    ...                                right=TreeNode(data=3))
    ...                                )
    True

    >>> is_binary_search_tree(TreeNode(data=0,
    ...                                left=TreeNode(data=-11),
    ...                                right=TreeNode(data=3))
    ...                                )
    True

    >>> is_binary_search_tree(TreeNode(data=5,
    ...                                left=TreeNode(data=1),
    ...                                right=TreeNode(data=4, left=TreeNode(data=3)))
    ...                      )
    False

    >>> is_binary_search_tree(TreeNode(data='a',
    ...                                left=TreeNode(data=1),
    ...                                right=TreeNode(data=4, left=TreeNode(data=3)))
    ...                      )
    Traceback (most recent call last):
     ...
    ValueError: Each node should be type of TreeNode and data should be float.

    >>> is_binary_search_tree(TreeNode(data=2,
    ...                                left=TreeNode([]),
    ...                                right=TreeNode(data=4, left=TreeNode(data=3)))
    ...                                )
    Traceback (most recent call last):
     ...
    ValueError: Each node should be type of TreeNode and data should be float.
    """"""

    def is_valid_tree(node: TreeNode | None) -> bool:
        """"""
        >>> is_valid_tree(None)
        True
        >>> is_valid_tree('abc')
        False
        >>> is_valid_tree(TreeNode(data='not a float'))
        False
        >>> is_valid_tree(TreeNode(data=1, left=TreeNode('123')))
        False
        """"""
        if node is None:
            return True
        if not isinstance(node, TreeNode):
            return False
        try:
            float(node.data)
        except (TypeError, ValueError):
            return False
        return is_valid_tree(node.left) and is_valid_tree(node.right)
    if not is_valid_tree(root):
        raise ValueError('Each node should be type of TreeNode and data should be float.')

    def is_binary_search_tree_recursive_check(node: TreeNode | None, left_bound: float, right_bound: float) -> bool:
        """"""
        >>> is_binary_search_tree_recursive_check(None)
        True
        >>> is_binary_search_tree_recursive_check(TreeNode(data=1), 10, 20)
        False
        """"""
        if node is None:
            return True
        return left_bound < node.data < right_bound and is_binary_search_tree_recursive_check(node.left, left_bound, node.data) and is_binary_search_tree_recursive_check(node.right, node.data, right_bound)
    return is_binary_search_tree_recursive_check(root, -float('inf'), float('inf'))",0.5241,0.005159985
matrix_chain_order,column_based_sort,matrix_chain_order array -- int[],"column_based_sort [(3, 0), (5, 1), (4, 2)]","def matrix_chain_order(array):
    """"""Finds optimal order to multiply matrices

    array -- int[]
    """"""
    n = len(array)
    matrix = [[0 for x in range(n)] for x in range(n)]
    sol = [[0 for x in range(n)] for x in range(n)]
    for chain_length in range(2, n):
        for a in range(1, n - chain_length + 1):
            b = a + chain_length - 1
            matrix[a][b] = INF
            for c in range(a, b):
                cost = matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]
                if cost < matrix[a][b]:
                    matrix[a][b] = cost
                    sol[a][b] = c
    return (matrix, sol)","def column_based_sort(array, column=0):
    """"""
    >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)
    [(3, 0), (5, 1), (4, 2)]
    """"""
    return sorted(array, key=lambda x: x[column])",0.61096054,0.12637764
print_optimal_solution,print_max_activities,"print_optimal_solution optimal_solution -- int[][]
i -- int[]
j -- int[]","print_max_activities >>> finish = [2, 4, 6, 7, 9, 9]
>>> print_max_activities(start, finish)
The following activities are selected:
0,1,3,4,","def print_optimal_solution(optimal_solution, i, j):
    """"""Print the solution

    optimal_solution -- int[][]
    i -- int[]
    j -- int[]
    """"""
    if i == j:
        print('A' + str(i), end=' ')
    else:
        print('(', end=' ')
        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])
        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)
        print(')', end=' ')","def print_max_activities(start: list[int], finish: list[int]) -> None:
    """"""
    >>> start = [1, 3, 0, 5, 8, 5]
    >>> finish = [2, 4, 6, 7, 9, 9]
    >>> print_max_activities(start, finish)
    The following activities are selected:
    0,1,3,4,
    """"""
    n = len(finish)
    print('The following activities are selected:')
    i = 0
    print(i, end=',')
    for j in range(n):
        if start[j] >= finish[i]:
            print(j, end=',')
            i = j",0.5402027,0.00074235856
find_k_factor,fractional_knapsack,"find_k_factor Keyword arguments:
length -- integer
k_factor -- integer","fractional_knapsack >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]
>>> fractional_knapsack(value, weight, 5)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, 15)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, 25)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, 26)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, -1)
(-90.0, [0, 0, 0, 0, -10.0])
>>> fractional_knapsack([1, 3, 5, 7], weight, 30)
(16, [1, 1, 1, 1])
>>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack([], [], 30)
(0, [])","def find_k_factor(length, k_factor):
    """"""Find the number of strings of length `length` with K factor = `k_factor`.

    Keyword arguments:
    length -- integer
    k_factor -- integer
    """"""
    mat = [[[0 for i in range(4)] for j in range((length - 1) // 3 + 2)] for k in range(length + 1)]
    if 3 * k_factor + 1 > length:
        return 0
    mat[1][0][0] = 1
    mat[1][0][1] = 0
    mat[1][0][2] = 0
    mat[1][0][3] = 25
    for i in range(2, length + 1):
        for j in range((length - 1) // 3 + 2):
            if j == 0:
                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3]
                mat[i][j][1] = mat[i - 1][j][0]
                mat[i][j][2] = mat[i - 1][j][1]
                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25
            elif 3 * j + 1 < i:
                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3] + mat[i - 1][j - 1][2]
                mat[i][j][1] = mat[i - 1][j][0]
                mat[i][j][2] = mat[i - 1][j][1]
                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25
            elif 3 * j + 1 == i:
                mat[i][j][0] = 1
                mat[i][j][1] = 0
                mat[i][j][2] = 0
                mat[i][j][3] = 0
            else:
                mat[i][j][0] = 0
                mat[i][j][1] = 0
                mat[i][j][2] = 0
                mat[i][j][3] = 0
    return sum(mat[length][k_factor])","def fractional_knapsack(value: list[int], weight: list[int], capacity: int) -> tuple[float, list[float]]:
    """"""
    >>> value = [1, 3, 5, 7, 9]
    >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]
    >>> fractional_knapsack(value, weight, 5)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 15)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 25)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 26)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, -1)
    (-90.0, [0, 0, 0, 0, -10.0])
    >>> fractional_knapsack([1, 3, 5, 7], weight, 30)
    (16, [1, 1, 1, 1])
    >>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack([], [], 30)
    (0, [])
    """"""
    index = list(range(len(value)))
    ratio = [v / w for (v, w) in zip(value, weight)]
    index.sort(key=lambda i: ratio[i], reverse=True)
    max_value: float = 0
    fractions: list[float] = [0] * len(value)
    for i in index:
        if weight[i] <= capacity:
            fractions[i] = 1
            max_value += value[i]
            capacity -= weight[i]
        else:
            fractions[i] = capacity / weight[i]
            max_value += value[i] * capacity / weight[i]
            break
    return (max_value, fractions)",0.484926,0.002571466
int_divide,simplify_fraction,int_divide decompose -- integer,"simplify_fraction assumes: 'denominator' != 0
returns: a tuple with simplify numerator and denominator.","def int_divide(decompose):
    """"""Find number of decompositions from `decompose`

    decompose -- integer
    """"""
    arr = [[0 for i in range(decompose + 1)] for j in range(decompose + 1)]
    arr[1][1] = 1
    for i in range(1, decompose + 1):
        for j in range(1, decompose + 1):
            if i < j:
                arr[i][j] = arr[i][i]
            elif i == j:
                arr[i][j] = 1 + arr[i][j - 1]
            else:
                arr[i][j] = arr[i][j - 1] + arr[i - j][j]
    return arr[decompose][decompose]","def simplify_fraction(numerator, denominator):
    """"""
    input: two integer 'numerator' and 'denominator'
    assumes: 'denominator' != 0
    returns: a tuple with simplify numerator and denominator.
    """"""
    assert isinstance(numerator, int) and isinstance(denominator, int) and (denominator != 0), ""The arguments must been from type int and 'denominator' != 0""
    gcd_of_fraction = gcd(abs(numerator), abs(denominator))
    assert isinstance(gcd_of_fraction, int) and numerator % gcd_of_fraction == 0 and (denominator % gcd_of_fraction == 0), 'Error in function gcd(...,...)'
    return (numerator // gcd_of_fraction, denominator // gcd_of_fraction)",0.5742328,0.001298439
subarray_with_max_product,max_subarray_sum,subarray_with_max_product arr is list of positive/negative numbers ,max_subarray_sum 17,"def subarray_with_max_product(arr):
    """""" arr is list of positive/negative numbers """"""
    length = len(arr)
    product_so_far = max_product_end = 1
    max_start_i = 0
    so_far_start_i = so_far_end_i = 0
    all_negative_flag = True
    for i in range(length):
        max_product_end *= arr[i]
        if arr[i] > 0:
            all_negative_flag = False
        if max_product_end <= 0:
            max_product_end = arr[i]
            max_start_i = i
        if product_so_far <= max_product_end:
            product_so_far = max_product_end
            so_far_end_i = i
            so_far_start_i = max_start_i
    if all_negative_flag:
        print(f'max_product_so_far: {reduce(lambda x, y: x * y, arr)}, {arr}')
    else:
        print(f'max_product_so_far: {product_so_far},{arr[so_far_start_i:so_far_end_i + 1]}')","def max_subarray_sum(nums: list) -> int:
    """"""
    >>> max_subarray_sum([6 , 9, -1, 3, -7, -5, 10])
    17
    """"""
    if not nums:
        return 0
    n = len(nums)
    (res, s, s_pre) = (nums[0], nums[0], nums[0])
    for i in range(1, n):
        s = max(nums[i], s_pre + nums[i])
        s_pre = s
        res = max(res, s)
    return res",0.6885701,0.96699643
egg_drop,n31,"egg_drop n -- number of floors
k -- number of eggs","n31 >>> n31(4)
([4, 2, 1], 3)","def egg_drop(n, k):
    """"""
    Keyword arguments:
    n -- number of floors
    k -- number of eggs
    """"""
    egg_floor = [[0 for _ in range(k + 1)] for _ in range(n + 1)]
    for i in range(1, n + 1):
        egg_floor[i][1] = 1
        egg_floor[i][0] = 0
    for j in range(1, k + 1):
        egg_floor[1][j] = j
    for i in range(2, n + 1):
        for j in range(2, k + 1):
            egg_floor[i][j] = INT_MAX
            for x in range(1, j + 1):
                res = 1 + max(egg_floor[i - 1][x - 1], egg_floor[i][j - x])
                if res < egg_floor[i][j]:
                    egg_floor[i][j] = res
    return egg_floor[n][k]","def n31(a: int) -> tuple[list[int], int]:
    """"""
    Returns the Collatz sequence and its length of any positive integer.
    >>> n31(4)
    ([4, 2, 1], 3)
    """"""
    if not isinstance(a, int):
        raise TypeError(f'Must be int, not {type(a).__name__}')
    if a < 1:
        raise ValueError(f'Given integer must be positive, not {a}')
    path = [a]
    while a != 1:
        if a % 2 == 0:
            a //= 2
        else:
            a = 3 * a + 1
        path.append(a)
    return (path, len(path))",0.5474754,0.00055642315
helper_topdown,num_digits,"helper_topdown Keyword arguments:
nums -- positive integer array without duplicates
target -- integer describing what a valid combination should add to","num_digits >>> num_digits(12345)
5
>>> num_digits(123)
3
>>> num_digits(0)
1
>>> num_digits(-1)
1
>>> num_digits(-123456)
6","def helper_topdown(nums, target):
    """"""Generates DP and finds result.

    Keyword arguments:
    nums -- positive integer array without duplicates
    target -- integer describing what a valid combination should add to
    """"""
    if DP[target] != -1:
        return DP[target]
    res = 0
    for num in nums:
        if target >= num:
            res += helper_topdown(nums, target - num)
    DP[target] = res
    return res","def num_digits(n: int) -> int:
    """"""
    Find the number of digits in a number.

    >>> num_digits(12345)
    5
    >>> num_digits(123)
    3
    >>> num_digits(0)
    1
    >>> num_digits(-1)
    1
    >>> num_digits(-123456)
    6
    """"""
    digits = 0
    n = abs(n)
    while True:
        n = n // 10
        digits += 1
        if n == 0:
            break
    return digits",0.55383265,0.029127691
combination_sum_topdown,combination_sum,"combination_sum_topdown Keyword arguments:
nums -- positive integer array without duplicates
target -- integer describing what a valid combination should add to","combination_sum [[2, 2, 2, 2], [2, 3, 3], [3, 5]]
>>> combination_sum([2, 3, 6, 7], 7)
[[2, 2, 3], [7]]
>>> combination_sum([-8, 2.3, 0], 1)
Traceback (most recent call last):
    ...
RecursionError: maximum recursion depth exceeded in comparison","def combination_sum_topdown(nums, target):
    """"""Find number of possible combinations in nums that add up to target, in top-down manner.

    Keyword arguments:
    nums -- positive integer array without duplicates
    target -- integer describing what a valid combination should add to
    """"""
    global DP
    DP = [-1] * (target + 1)
    DP[0] = 1
    return helper_topdown(nums, target)","def combination_sum(candidates: list, target: int) -> list:
    """"""
    >>> combination_sum([2, 3, 5], 8)
    [[2, 2, 2, 2], [2, 3, 3], [3, 5]]
    >>> combination_sum([2, 3, 6, 7], 7)
    [[2, 2, 3], [7]]
    >>> combination_sum([-8, 2.3, 0], 1)
    Traceback (most recent call last):
        ...
    RecursionError: maximum recursion depth exceeded in comparison
    """"""
    path = []
    answer = []
    backtrack(candidates, path, answer, target, 0)
    return answer",0.6245414,0.98682886
combination_sum_bottom_up,add_three,"combination_sum_bottom_up Keyword arguments:
nums -- positive integer array without duplicates
target -- integer describing what a valid combination should add to","add_three numerator and denominator of their sum in lowest form.
>>> add_three(1, 3, 1, 3, 1, 3)
(1, 1)
>>> add_three(2, 5, 4, 11, 12, 3)
(262, 55)","def combination_sum_bottom_up(nums, target):
    """"""Find number of possible combinations in nums that add up to target, in bottom-up manner.

    Keyword arguments:
    nums -- positive integer array without duplicates
    target -- integer describing what a valid combination should add to
    """"""
    combs = [0] * (target + 1)
    combs[0] = 1
    for i in range(0, len(combs)):
        for num in nums:
            if i - num >= 0:
                combs[i] += combs[i - num]
    return combs[target]","def add_three(x_num: int, x_den: int, y_num: int, y_den: int, z_num: int, z_den: int) -> tuple[int, int]:
    """"""
    Given the numerators and denominators of three fractions, return the
    numerator and denominator of their sum in lowest form.
    >>> add_three(1, 3, 1, 3, 1, 3)
    (1, 1)
    >>> add_three(2, 5, 4, 11, 12, 3)
    (262, 55)
    """"""
    top: int = x_num * y_den * z_den + y_num * x_den * z_den + z_num * x_den * y_den
    bottom: int = x_den * y_den * z_den
    hcf: int = gcd(top, bottom)
    top //= hcf
    bottom //= hcf
    return (top, bottom)",0.6355277,0.0011735068
min_cost,minimum_cost_path,"min_cost Keyword arguments:
cost -- matrix containing costs","minimum_cost_path a given matrix

>>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])
6

>>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])
7","def min_cost(cost):
    """"""Find minimum cost.

    Keyword arguments:
    cost -- matrix containing costs
    """"""
    length = len(cost)
    dist = [INF] * length
    dist[0] = 0
    for i in range(length):
        for j in range(i + 1, length):
            dist[j] = min(dist[j], dist[i] + cost[i][j])
    return dist[length - 1]","def minimum_cost_path(matrix: list[list[int]]) -> int:
    """"""
    Find the minimum cost traced by all possible paths from top left to bottom right in
    a given matrix

    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])
    6

    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])
    7
    """"""
    for i in range(1, len(matrix[0])):
        matrix[0][i] += matrix[0][i - 1]
    for i in range(1, len(matrix)):
        matrix[i][0] += matrix[i - 1][0]
    for i in range(1, len(matrix)):
        for j in range(1, len(matrix[0])):
            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])
    return matrix[-1][-1]",0.6314563,0.9994856
dfs_transposed,my_dfs,"dfs_transposed Stores the order in which nodes were visited to the list, in transposed order.",my_dfs find different DFS walk from given node to Header node,"def dfs_transposed(vertex, graph, order, visited):
    """"""
    Perform a depth first search traversal of the graph starting at the given vertex.
    Stores the order in which nodes were visited to the list, in transposed order.
    """"""
    visited[vertex] = True
    for adjacent in graph[vertex]:
        if not visited[adjacent]:
            dfs_transposed(adjacent, graph, order, visited)
    order.append(vertex)","def my_dfs(graph, start, end, path=None):
    """"""
    find different DFS walk from given node to Header node
    """"""
    path = (path or []) + [start]
    if start == end:
        paths.append(path)
    for node in graph[start]:
        if tuple(node) not in path:
            my_dfs(graph, tuple(node), end, path)",0.64441323,0.9970515
add_edge,create_edge,add_edge Add a directed edge to the graph.,create_edge create edge between the nodes,"def add_edge(graph, vertex_from, vertex_to):
    """"""
    Add a directed edge to the graph.
    """"""
    if vertex_from not in graph:
        graph[vertex_from] = []
    graph[vertex_from].append(vertex_to)","def create_edge(nodes, graph, cluster, c1):
    """"""
    create edge between the nodes
    """"""
    for i in cluster[c1].keys():
        count = 0
        c2 = c1 + 1
        while c2 < max(cluster.keys()):
            for j in cluster[c2].keys():
                '\n                creates edge only if the condition satisfies\n                '
                if int(i, 2) & int(j, 2) == int(i, 2):
                    if tuple(nodes[i]) in graph:
                        graph[tuple(nodes[i])].append(nodes[j])
                    else:
                        graph[tuple(nodes[i])] = [nodes[j]]
                    count += 1
            if count == 0:
                c2 = c2 + 1
            else:
                break",0.7336567,0.97505605
scc,strongly_connected_components,scc Computes the strongly connected components of a graph ,"strongly_connected_components and then returns the list of strongly connected components
>>> strongly_connected_components(test_graph_1)
[[0, 1, 2], [3], [4]]
>>> strongly_connected_components(test_graph_2)
[[0, 2, 1], [3, 5, 4]]","def scc(graph):
    """""" Computes the strongly connected components of a graph """"""
    order = []
    visited = {vertex: False for vertex in graph}
    graph_transposed = {vertex: [] for vertex in graph}
    for (source, neighbours) in graph.iteritems():
        for target in neighbours:
            add_edge(graph_transposed, target, source)
    for vertex in graph:
        if not visited[vertex]:
            dfs_transposed(vertex, graph_transposed, order, visited)
    visited = {vertex: False for vertex in graph}
    vertex_scc = {}
    current_comp = 0
    for vertex in reversed(order):
        if not visited[vertex]:
            dfs(vertex, current_comp, vertex_scc, graph, visited)
            current_comp += 1
    return vertex_scc","def strongly_connected_components(graph: dict[int, list[int]]) -> list[list[int]]:
    """"""
    This function takes graph as a parameter
    and then returns the list of strongly connected components
    >>> strongly_connected_components(test_graph_1)
    [[0, 1, 2], [3], [4]]
    >>> strongly_connected_components(test_graph_2)
    [[0, 2, 1], [3, 5, 4]]
    """"""
    visited = len(graph) * [False]
    reversed_graph: dict[int, list[int]] = {vert: [] for vert in range(len(graph))}
    for (vert, neighbours) in graph.items():
        for neighbour in neighbours:
            reversed_graph[neighbour].append(vert)
    order = []
    for (i, was_visited) in enumerate(visited):
        if not was_visited:
            order += topology_sort(graph, i, visited)
    components_list = []
    visited = len(graph) * [False]
    for i in range(len(graph)):
        vert = order[len(graph) - i - 1]
        if not visited[vert]:
            component = find_components(reversed_graph, vert, visited)
            components_list.append(component)
    return components_list",0.57040006,0.99954283
build_graph,compute_bridges,build_graph Builds the implication graph from the formula ,"compute_bridges >>> compute_bridges(__get_demo_graph(0))
[(3, 4), (2, 3), (2, 5)]
>>> compute_bridges(__get_demo_graph(1))
[(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]
>>> compute_bridges(__get_demo_graph(2))
[(1, 6), (4, 6), (0, 4)]
>>> compute_bridges(__get_demo_graph(3))
[]
>>> compute_bridges({})
[]","def build_graph(formula):
    """""" Builds the implication graph from the formula """"""
    graph = {}
    for clause in formula:
        for (lit, _) in clause:
            for neg in [False, True]:
                graph[lit, neg] = []
    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:
        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))
        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))
    return graph","def compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]:
    """"""
    Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi
    >>> compute_bridges(__get_demo_graph(0))
    [(3, 4), (2, 3), (2, 5)]
    >>> compute_bridges(__get_demo_graph(1))
    [(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]
    >>> compute_bridges(__get_demo_graph(2))
    [(1, 6), (4, 6), (0, 4)]
    >>> compute_bridges(__get_demo_graph(3))
    []
    >>> compute_bridges({})
    []
    """"""
    id_ = 0
    n = len(graph)
    low = [0] * n
    visited = [False] * n

    def dfs(at, parent, bridges, id_):
        visited[at] = True
        low[at] = id_
        id_ += 1
        for to in graph[at]:
            if to == parent:
                pass
            elif not visited[to]:
                dfs(to, at, bridges, id_)
                low[at] = min(low[at], low[to])
                if id_ <= low[to]:
                    bridges.append((at, to) if at < to else (to, at))
            else:
                low[at] = min(low[at], low[to])
    bridges: list[tuple[int, int]] = []
    for i in range(n):
        if not visited[i]:
            dfs(i, -1, bridges, id_)
    return bridges",0.6161796,0.98453057
solve_sat,solution_fast,solve_sat Solves the 2-SAT problem,"solution_fast the following:
  1. a < b < c
  2. a**2 + b**2 = c**2
  3. a + b + c = 1000

>>> solution_fast()
31875000","def solve_sat(formula):
    """"""
    Solves the 2-SAT problem
    """"""
    graph = build_graph(formula)
    vertex_scc = scc(graph)
    for (var, _) in graph:
        if vertex_scc[var, False] == vertex_scc[var, True]:
            return None
    comp_repr = {}
    for vertex in graph:
        if not vertex_scc[vertex] in comp_repr:
            comp_repr[vertex_scc[vertex]] = vertex
    comp_value = {}
    components = sorted(vertex_scc.values())
    for comp in components:
        if comp not in comp_value:
            comp_value[comp] = False
            (lit, neg) = comp_repr[comp]
            comp_value[vertex_scc[lit, not neg]] = True
    value = {var: comp_value[vertex_scc[var, False]] for (var, _) in graph}
    return value","def solution_fast() -> int:
    """"""
    Returns the product of a,b,c which are Pythagorean Triplet that satisfies
    the following:
      1. a < b < c
      2. a**2 + b**2 = c**2
      3. a + b + c = 1000

    >>> solution_fast()
    31875000
    """"""
    for a in range(300):
        for b in range(400):
            c = 1000 - a - b
            if a < b < c and a ** 2 + b ** 2 == c ** 2:
                return a * b * c
    return -1",0.5463791,0.00012463423
prims_minimum_spanning,prim,prims_minimum_spanning Prim's algorithm to find weight of minimum spanning tree,"prim Runtime:
    O(mn) with `m` edges and `n` vertices

Return:
    List with the edges of a Minimum Spanning Tree

Usage:
    prim(graph, graph[0])","def prims_minimum_spanning(graph_used):
    """"""
    Prim's algorithm to find weight of minimum spanning tree
    """"""
    vis = []
    heap = [[0, 1]]
    prim = set()
    mincost = 0
    while len(heap) > 0:
        (cost, node) = heapq.heappop(heap)
        if node in vis:
            continue
        mincost += cost
        prim.add(node)
        vis.append(node)
        for (distance, adjacent) in graph_used[node]:
            if adjacent not in vis:
                heapq.heappush(heap, [distance, adjacent])
    return mincost","def prim(graph: list, root: Vertex) -> list:
    """"""Prim's Algorithm.

    Runtime:
        O(mn) with `m` edges and `n` vertices

    Return:
        List with the edges of a Minimum Spanning Tree

    Usage:
        prim(graph, graph[0])
    """"""
    a = []
    for u in graph:
        u.key = math.inf
        u.pi = None
    root.key = 0
    q = graph[:]
    while q:
        u = min(q)
        q.remove(u)
        for v in u.neighbors:
            if v in q and u.edges[v.id] < v.key:
                v.pi = u
                v.key = u.edges[v.id]
    for i in range(1, len(graph)):
        a.append((int(graph[i].id) + 1, int(graph[i].pi.id) + 1))
    return a",0.6514865,0.97969496
check_bipartite,perfect_square_binary_search,"check_bipartite Time complexity is O(|E|)
Space complexity is O(|V|)","perfect_square_binary_search Time complexity : O(Log(n))
Space complexity: O(1)

>>> perfect_square_binary_search(9)
True
>>> perfect_square_binary_search(16)
True
>>> perfect_square_binary_search(1)
True
>>> perfect_square_binary_search(0)
True
>>> perfect_square_binary_search(10)
False
>>> perfect_square_binary_search(-1)
False
>>> perfect_square_binary_search(1.1)
False
>>> perfect_square_binary_search(""a"")
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'str'
>>> perfect_square_binary_search(None)
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'NoneType'
>>> perfect_square_binary_search([])
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'list'","def check_bipartite(adj_list):
    """"""
    Determine if the given graph is bipartite.

    Time complexity is O(|E|)
    Space complexity is O(|V|)
    """"""
    vertices = len(adj_list)
    set_type = [-1 for v in range(vertices)]
    set_type[0] = 0
    queue = [0]
    while queue:
        current = queue.pop(0)
        if adj_list[current][current]:
            return False
        for adjacent in range(vertices):
            if adj_list[current][adjacent]:
                if set_type[adjacent] == set_type[current]:
                    return False
                if set_type[adjacent] == -1:
                    set_type[adjacent] = 1 - set_type[current]
                    queue.append(adjacent)
    return True","def perfect_square_binary_search(n: int) -> bool:
    """"""
    Check if a number is perfect square using binary search.
    Time complexity : O(Log(n))
    Space complexity: O(1)

    >>> perfect_square_binary_search(9)
    True
    >>> perfect_square_binary_search(16)
    True
    >>> perfect_square_binary_search(1)
    True
    >>> perfect_square_binary_search(0)
    True
    >>> perfect_square_binary_search(10)
    False
    >>> perfect_square_binary_search(-1)
    False
    >>> perfect_square_binary_search(1.1)
    False
    >>> perfect_square_binary_search(""a"")
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> perfect_square_binary_search(None)
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'NoneType'
    >>> perfect_square_binary_search([])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'
    """"""
    left = 0
    right = n
    while left <= right:
        mid = (left + right) // 2
        if mid ** 2 == n:
            return True
        elif mid ** 2 > n:
            right = mid - 1
        else:
            left = mid + 1
    return False",0.6665058,0.02605881
bellman_ford,bellman_ford,"bellman_ford shortest path from given graph or not for single-source shortest-paths problem.
In other words, if given graph has any negative-weight cycle that is reachable
from the source, then it will give answer False for ""no solution exits"".
For argument graph, it should be a dictionary type
such as
graph = {
    'a': {'b': 6, 'e': 7},
    'b': {'c': 5, 'd': -4, 'e': 8},
    'c': {'b': -2},
    'd': {'a': 2, 'c': 7},
    'e': {'b': -3}
}","bellman_ford other vertices.
>>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]
>>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges]
>>> bellman_ford(g, 4, 4, 0)
[0.0, -2.0, 8.0, 5.0]
>>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges + [(1, 3, 5)]]
>>> bellman_ford(g, 4, 5, 0)
Traceback (most recent call last):
 ...
Exception: Negative cycle found","def bellman_ford(graph, source):
    """"""
    This Bellman-Ford Code is for determination whether we can get
    shortest path from given graph or not for single-source shortest-paths problem.
    In other words, if given graph has any negative-weight cycle that is reachable
    from the source, then it will give answer False for ""no solution exits"".
    For argument graph, it should be a dictionary type
    such as
    graph = {
        'a': {'b': 6, 'e': 7},
        'b': {'c': 5, 'd': -4, 'e': 8},
        'c': {'b': -2},
        'd': {'a': 2, 'c': 7},
        'e': {'b': -3}
    }
    """"""
    weight = {}
    pre_node = {}
    initialize_single_source(graph, source, weight, pre_node)
    for _ in range(1, len(graph)):
        for node in graph:
            for adjacent in graph[node]:
                if weight[adjacent] > weight[node] + graph[node][adjacent]:
                    weight[adjacent] = weight[node] + graph[node][adjacent]
                    pre_node[adjacent] = node
    for node in graph:
        for adjacent in graph[node]:
            if weight[adjacent] > weight[node] + graph[node][adjacent]:
                return False
    return True","def bellman_ford(graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int) -> list[float]:
    """"""
    Returns shortest paths from a vertex src to all
    other vertices.
    >>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]
    >>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges]
    >>> bellman_ford(g, 4, 4, 0)
    [0.0, -2.0, 8.0, 5.0]
    >>> g = [{""src"": s, ""dst"": d, ""weight"": w} for s, d, w in edges + [(1, 3, 5)]]
    >>> bellman_ford(g, 4, 5, 0)
    Traceback (most recent call last):
     ...
    Exception: Negative cycle found
    """"""
    distance = [float('inf')] * vertex_count
    distance[src] = 0.0
    for _ in range(vertex_count - 1):
        for j in range(edge_count):
            (u, v, w) = (graph[j][k] for k in ['src', 'dst', 'weight'])
            if distance[u] != float('inf') and distance[u] + w < distance[v]:
                distance[v] = distance[u] + w
    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)
    if negative_cycle_exists:
        raise Exception('Negative cycle found')
    return distance",0.55153215,0.9997515
initialize_single_source,get_initial_centroids,initialize_single_source Initialize data structures for Bellman-Ford algorithm.,get_initial_centroids Randomly choose k data points as initial centroids,"def initialize_single_source(graph, source, weight, pre_node):
    """"""
    Initialize data structures for Bellman-Ford algorithm.
    """"""
    for node in graph:
        weight[node] = float('inf')
        pre_node[node] = None
    weight[source] = 0","def get_initial_centroids(data, k, seed=None):
    """"""Randomly choose k data points as initial centroids""""""
    if seed is not None:
        np.random.seed(seed)
    n = data.shape[0]
    rand_indices = np.random.randint(0, n, k)
    centroids = data[rand_indices, :]
    return centroids",0.43620288,0.9519707
count_components,digit_factorial_sum,count_components return type : int,"digit_factorial_sum >>> digit_factorial_sum(69.0)
Traceback (most recent call last):
    ...
TypeError: Parameter number must be int

>>> digit_factorial_sum(-1)
Traceback (most recent call last):
    ...
ValueError: Parameter number must be greater than or equal to 0

>>> digit_factorial_sum(0)
1

>>> digit_factorial_sum(69)
363600","def count_components(adjacency_list, size):
    """"""
    Function that counts the Connected components on bases of DFS.
    return type : int
    """"""
    count = 0
    visited = [False] * (size + 1)
    for i in range(1, size + 1):
        if not visited[i]:
            dfs(i, visited, adjacency_list)
            count += 1
    return count","def digit_factorial_sum(number: int) -> int:
    """"""
    Function to perform the sum of the factorial of all the digits in number

    >>> digit_factorial_sum(69.0)
    Traceback (most recent call last):
        ...
    TypeError: Parameter number must be int

    >>> digit_factorial_sum(-1)
    Traceback (most recent call last):
        ...
    ValueError: Parameter number must be greater than or equal to 0

    >>> digit_factorial_sum(0)
    1

    >>> digit_factorial_sum(69)
    363600
    """"""
    if not isinstance(number, int):
        raise TypeError('Parameter number must be int')
    if number < 0:
        raise ValueError('Parameter number must be greater than or equal to 0')
    return sum((DIGIT_FACTORIAL[digit] for digit in str(number)))",0.5536448,0.0049339966
is_in_cycle,util_hamilton_cycle,"is_in_cycle :param: traversal_states: for each vertex, the state it is in","util_hamilton_cycle Base Case:
1. Check if we visited all of vertices
    1.1 If last visited vertex has path to starting vertex return True either
        return False
Recursive Step:
2. Iterate over each vertex
    Check if next vertex is valid for transiting from current vertex
        2.1 Remember next vertex as next transition
        2.2 Do recursive call and check if going to this vertex solves problem
        2.3 If next vertex leads to solution return True
        2.4 Else backtrack, delete remembered vertex

Case 1: Use exact graph as in main function, with initialized values
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> path = [0, -1, -1, -1, -1, 0]
>>> curr_ind = 1
>>> util_hamilton_cycle(graph, path, curr_ind)
True
>>> path
[0, 1, 2, 4, 3, 0]

Case 2: Use exact graph as in previous case, but in the properties taken from
    middle of calculation
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> path = [0, 1, 2, -1, -1, 0]
>>> curr_ind = 3
>>> util_hamilton_cycle(graph, path, curr_ind)
True
>>> path
[0, 1, 2, 4, 3, 0]","def is_in_cycle(graph, traversal_states, vertex):
    """"""
    Determines if the given vertex is in a cycle.

    :param: traversal_states: for each vertex, the state it is in
    """"""
    if traversal_states[vertex] == TraversalState.GRAY:
        return True
    traversal_states[vertex] = TraversalState.GRAY
    for neighbor in graph[vertex]:
        if is_in_cycle(graph, traversal_states, neighbor):
            return True
    traversal_states[vertex] = TraversalState.BLACK
    return False","def util_hamilton_cycle(graph: list[list[int]], path: list[int], curr_ind: int) -> bool:
    """"""
    Pseudo-Code
    Base Case:
    1. Check if we visited all of vertices
        1.1 If last visited vertex has path to starting vertex return True either
            return False
    Recursive Step:
    2. Iterate over each vertex
        Check if next vertex is valid for transiting from current vertex
            2.1 Remember next vertex as next transition
            2.2 Do recursive call and check if going to this vertex solves problem
            2.3 If next vertex leads to solution return True
            2.4 Else backtrack, delete remembered vertex

    Case 1: Use exact graph as in main function, with initialized values
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> path = [0, -1, -1, -1, -1, 0]
    >>> curr_ind = 1
    >>> util_hamilton_cycle(graph, path, curr_ind)
    True
    >>> path
    [0, 1, 2, 4, 3, 0]

    Case 2: Use exact graph as in previous case, but in the properties taken from
        middle of calculation
    >>> graph = [[0, 1, 0, 1, 0],
    ...          [1, 0, 1, 1, 1],
    ...          [0, 1, 0, 0, 1],
    ...          [1, 1, 0, 0, 1],
    ...          [0, 1, 1, 1, 0]]
    >>> path = [0, 1, 2, -1, -1, 0]
    >>> curr_ind = 3
    >>> util_hamilton_cycle(graph, path, curr_ind)
    True
    >>> path
    [0, 1, 2, 4, 3, 0]
    """"""
    if curr_ind == len(graph):
        return graph[path[curr_ind - 1]][path[0]] == 1
    for next_ver in range(0, len(graph)):
        if valid_connection(graph, next_ver, curr_ind, path):
            path[curr_ind] = next_ver
            if util_hamilton_cycle(graph, path, curr_ind + 1):
                return True
            path[curr_ind] = -1
    return False",0.5761689,0.9989281
contains_cycle,create_ngram,"contains_cycle The graph should be given as a dictionary:

    graph = {'A': ['B', 'C'],
             'B': ['D'],
             'C': ['F'],
             'D': ['E', 'F'],
             'E': ['B'],
             'F': []}","create_ngram >>> create_ngram(""I am a sentence"", 2)
['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']
>>> create_ngram(""I am an NLPer"", 2)
['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']
>>> create_ngram(""This is short"", 50)
[]","def contains_cycle(graph):
    """"""
    Determines if there is a cycle in the given graph.
    The graph should be given as a dictionary:

        graph = {'A': ['B', 'C'],
                 'B': ['D'],
                 'C': ['F'],
                 'D': ['E', 'F'],
                 'E': ['B'],
                 'F': []}
    """"""
    traversal_states = {vertex: TraversalState.WHITE for vertex in graph}
    for (vertex, state) in traversal_states.items():
        if state == TraversalState.WHITE and is_in_cycle(graph, traversal_states, vertex):
            return True
    return False","def create_ngram(sentence: str, ngram_size: int) -> list[str]:
    """"""
    Create ngrams from a sentence

    >>> create_ngram(""I am a sentence"", 2)
    ['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']
    >>> create_ngram(""I am an NLPer"", 2)
    ['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']
    >>> create_ngram(""This is short"", 50)
    []
    """"""
    return [sentence[i:i + ngram_size] for i in range(len(sentence) - ngram_size + 1)]",0.52116674,0.016218135
find_all_cliques,find_components,"find_all_cliques each key is a vertex
value is set of all edges connected to vertex
returns list of lists (each sub list is a maximal clique)
implementation of the basic algorithm described in:
Bron, Coen; Kerbosch, Joep (1973), ""Algorithm 457: finding all cliques of an undirected graph"",","find_components vertices. Now graph is reversed
>>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])
[0, 1, 2]
>>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])
[0, 2, 1]","def find_all_cliques(edges):
    """"""
    takes dict of sets
    each key is a vertex
    value is set of all edges connected to vertex
    returns list of lists (each sub list is a maximal clique)
    implementation of the basic algorithm described in:
    Bron, Coen; Kerbosch, Joep (1973), ""Algorithm 457: finding all cliques of an undirected graph"",
    """"""

    def expand_clique(candidates, nays):
        nonlocal compsub
        if not candidates and (not nays):
            nonlocal solutions
            solutions.append(compsub.copy())
        else:
            for selected in candidates.copy():
                candidates.remove(selected)
                candidates_temp = get_connected(selected, candidates)
                nays_temp = get_connected(selected, nays)
                compsub.append(selected)
                expand_clique(candidates_temp, nays_temp)
                nays.add(compsub.pop())

    def get_connected(vertex, old_set):
        new_set = set()
        for neighbor in edges[str(vertex)]:
            if neighbor in old_set:
                new_set.add(neighbor)
        return new_set
    compsub = []
    solutions = []
    possibles = set(edges.keys())
    expand_clique(possibles, set())
    return solutions","def find_components(reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]) -> list[int]:
    """"""
    Use depth first search to find strongliy connected
    vertices. Now graph is reversed
    >>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])
    [0, 1, 2]
    >>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])
    [0, 2, 1]
    """"""
    visited[vert] = True
    component = [vert]
    for neighbour in reversed_graph[vert]:
        if not visited[neighbour]:
            component += find_components(reversed_graph, neighbour, visited)
    return component",0.5845282,0.9944554
ford_fulkerson,freq_subgraphs_edge_list,"ford_fulkerson Time Complexity : O(Ef)
E is the number of edges and f is the maximum flow in the graph.",freq_subgraphs_edge_list returns Edge list for frequent subgraphs,"def ford_fulkerson(capacity, source, sink):
    """"""
    Computes maximum flow from source to sink using DFS.
    Time Complexity : O(Ef)
    E is the number of edges and f is the maximum flow in the graph.
    """"""
    vertices = len(capacity)
    ret = 0
    flow = [[0] * vertices for _ in range(vertices)]
    while True:
        visit = [False for _ in range(vertices)]
        tmp = dfs(capacity, flow, visit, vertices, source, sink)
        if tmp:
            ret += tmp
        else:
            break
    return ret","def freq_subgraphs_edge_list(paths):
    """"""
    returns Edge list for frequent subgraphs
    """"""
    freq_sub_el = []
    for edges in paths:
        el = []
        for j in range(len(edges) - 1):
            temp = list(edges[j])
            for e in temp:
                edge = (e[0], e[1])
                el.append(edge)
        freq_sub_el.append(el)
    return freq_sub_el",0.49535537,0.95010996
edmonds_karp,runge_kutta,"edmonds_karp Time complexity : O(V*E^2)
V is the number of vertices and E is the number of edges.","runge_kutta https://en.wikipedia.org/wiki/Runge-Kutta_methods

Arguments:
f -- The ode as a function of x and y
y0 -- the initial value for y
x0 -- the initial value for x
h -- the stepsize
x_end -- the end value for x

>>> # the exact solution is math.exp(x)
>>> def f(x, y):
...     return y
>>> y0 = 1
>>> y = runge_kutta(f, y0, 0.0, 0.01, 5)
>>> y[-1]
148.41315904125113","def edmonds_karp(capacity, source, sink):
    """"""
    Computes maximum flow from source to sink using BFS.
    Time complexity : O(V*E^2)
    V is the number of vertices and E is the number of edges.
    """"""
    vertices = len(capacity)
    ret = 0
    flow = [[0] * vertices for _ in range(vertices)]
    while True:
        tmp = 0
        queue = Queue()
        visit = [False for _ in range(vertices)]
        par = [-1 for _ in range(vertices)]
        visit[source] = True
        queue.put((source, 1 << 63))
        while queue.qsize():
            front = queue.get()
            (idx, current_flow) = front
            if idx == sink:
                tmp = current_flow
                break
            for nxt in range(vertices):
                if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:
                    visit[nxt] = True
                    par[nxt] = idx
                    queue.put((nxt, min(current_flow, capacity[idx][nxt] - flow[idx][nxt])))
        if par[sink] == -1:
            break
        ret += tmp
        parent = par[sink]
        idx = sink
        while parent != -1:
            flow[parent][idx] += tmp
            flow[idx][parent] -= tmp
            idx = parent
            parent = par[parent]
    return ret","def runge_kutta(f, y0, x0, h, x_end):
    """"""
    Calculate the numeric solution at each step to the ODE f(x, y) using RK4

    https://en.wikipedia.org/wiki/Runge-Kutta_methods

    Arguments:
    f -- The ode as a function of x and y
    y0 -- the initial value for y
    x0 -- the initial value for x
    h -- the stepsize
    x_end -- the end value for x

    >>> # the exact solution is math.exp(x)
    >>> def f(x, y):
    ...     return y
    >>> y0 = 1
    >>> y = runge_kutta(f, y0, 0.0, 0.01, 5)
    >>> y[-1]
    148.41315904125113
    """"""
    n = int(np.ceil((x_end - x0) / h))
    y = np.zeros((n + 1,))
    y[0] = y0
    x = x0
    for k in range(n):
        k1 = f(x, y[k])
        k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)
        k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)
        k4 = f(x + h, y[k] + h * k3)
        y[k + 1] = y[k] + 1 / 6 * h * (k1 + 2 * k2 + 2 * k3 + k4)
        x += h
    return y",0.5473908,0.09184384
dinic_bfs,check,dinic_bfs Check whether sink is reachable only using edges that is not full.,check ['0.00.01.5'],"def dinic_bfs(capacity, flow, level, source, sink):
    """"""
    BFS function for Dinic algorithm.
    Check whether sink is reachable only using edges that is not full.
    """"""
    vertices = len(capacity)
    queue = Queue()
    queue.put(source)
    level[source] = 0
    while queue.qsize():
        front = queue.get()
        for nxt in range(vertices):
            if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]:
                level[nxt] = level[front] + 1
                queue.put(nxt)
    return level[sink] != -1","def check(binary: list[str]) -> list[str]:
    """"""
    >>> check(['0.00.01.5'])
    ['0.00.01.5']
    """"""
    pi = []
    while True:
        check1 = ['$'] * len(binary)
        temp = []
        for i in range(len(binary)):
            for j in range(i + 1, len(binary)):
                k = compare_string(binary[i], binary[j])
                if k is False:
                    check1[i] = '*'
                    check1[j] = '*'
                    temp.append('X')
        for i in range(len(binary)):
            if check1[i] == '$':
                pi.append(binary[i])
        if len(temp) == 0:
            return pi
        binary = list(set(temp))",0.41979656,0.00018178727
dinic_dfs,dfs,dinic_dfs Finds new flow using edges that is not full.,dfs DFS traversal,"def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1 << 63):
    """"""
    DFS function for Dinic algorithm.
    Finds new flow using edges that is not full.
    """"""
    if idx == sink:
        return current_flow
    vertices = len(capacity)
    while work[idx] < vertices:
        nxt = work[idx]
        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:
            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])
            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow)
            if tmp > 0:
                flow[idx][nxt] += tmp
                flow[nxt][idx] -= tmp
                return tmp
        work[idx] += 1
    return 0","def dfs(start: int) -> int:
    """"""DFS traversal""""""
    ret = 1
    visited[start] = True
    for v in tree[start]:
        if v not in visited:
            ret += dfs(v)
    if ret % 2 == 0:
        cuts.append(start)
    return ret",0.5801245,0.17479645
dinic,dodecahedron_volume,"dinic Time complexity : O(V^2*E)
V is the number of vertices and E is the number of edges.","dodecahedron_volume v = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3)
where:
v --> is the volume of the dodecahedron
e --> is the length of the edge
reference-->""Dodecahedron"" Study.com
<https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>","def dinic(capacity, source, sink):
    """"""
    Computes maximum flow from source to sink using Dinic algorithm.
    Time complexity : O(V^2*E)
    V is the number of vertices and E is the number of edges.
    """"""
    vertices = len(capacity)
    flow = [[0] * vertices for i in range(vertices)]
    ret = 0
    while True:
        level = [-1 for i in range(vertices)]
        work = [0 for i in range(vertices)]
        if not dinic_bfs(capacity, flow, level, source, sink):
            break
        while True:
            tmp = dinic_dfs(capacity, flow, level, source, sink, work)
            if tmp > 0:
                ret += tmp
            else:
                break
    return ret","def dodecahedron_volume(edge: float) -> float:
    """"""
    Calculates the volume of a regular dodecahedron
    v = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3)
    where:
    v --> is the volume of the dodecahedron
    e --> is the length of the edge
    reference-->""Dodecahedron"" Study.com
    <https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>

    :param edge: length of the edge of the dodecahedron
    :type edge: float
    :return: the volume of the dodecahedron as a float

    Tests:
    >>> dodecahedron_volume(5)
    957.8898700780791
    >>> dodecahedron_volume(10)
    7663.118960624633
    >>> dodecahedron_volume(-1)
    Traceback (most recent call last):
      ...
    ValueError: Length must be a positive.
    """"""
    if edge <= 0 or not isinstance(edge, int):
        raise ValueError('Length must be a positive.')
    return (15 + 7 * 5 ** (1 / 2)) / 4 * edge ** 3",0.5785625,0.0007620927
maximum_flow_bfs,hill_climbing,maximum_flow_bfs Get the maximum flow through a graph using a breadth first search,"hill_climbing We start with a given state, find all its neighbors,
move towards the neighbor which provides the maximum (or minimum) change.
We keep doing this until we are at a state where we do not have any
neighbors which can improve the solution.
    Args:
        search_prob: The search state at the start.
        find_max: If True, the algorithm should find the maximum else the minimum.
        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.
        visualization: If True, a matplotlib graph is displayed.
        max_iter: number of times to run the iteration.
    Returns a search state having the maximum (or minimum) score.","def maximum_flow_bfs(adjacency_matrix):
    """"""
    Get the maximum flow through a graph using a breadth first search
    """"""
    new_array = copy.deepcopy(adjacency_matrix)
    total = 0
    while True:
        min_flow = math.inf
        visited = [0] * len(new_array)
        path = [0] * len(new_array)
        bfs = queue.Queue()
        visited[0] = 1
        bfs.put(0)
        while bfs.qsize() > 0:
            src = bfs.get()
            for k in range(len(new_array)):
                if new_array[src][k] > 0 and visited[k] == 0:
                    visited[k] = 1
                    bfs.put(k)
                    path[k] = src
        if visited[len(new_array) - 1] == 0:
            break
        tmp = len(new_array) - 1
        while tmp != 0:
            if min_flow > new_array[path[tmp]][tmp]:
                min_flow = new_array[path[tmp]][tmp]
            tmp = path[tmp]
        tmp = len(new_array) - 1
        while tmp != 0:
            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min_flow
            tmp = path[tmp]
        total = total + min_flow
    return total","def hill_climbing(search_prob, find_max: bool=True, max_x: float=math.inf, min_x: float=-math.inf, max_y: float=math.inf, min_y: float=-math.inf, visualization: bool=False, max_iter: int=10000) -> SearchProblem:
    """"""
    Implementation of the hill climbling algorithm.
    We start with a given state, find all its neighbors,
    move towards the neighbor which provides the maximum (or minimum) change.
    We keep doing this until we are at a state where we do not have any
    neighbors which can improve the solution.
        Args:
            search_prob: The search state at the start.
            find_max: If True, the algorithm should find the maximum else the minimum.
            max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.
            visualization: If True, a matplotlib graph is displayed.
            max_iter: number of times to run the iteration.
        Returns a search state having the maximum (or minimum) score.
    """"""
    current_state = search_prob
    scores = []
    iterations = 0
    solution_found = False
    visited = set()
    while not solution_found and iterations < max_iter:
        visited.add(current_state)
        iterations += 1
        current_score = current_state.score()
        scores.append(current_score)
        neighbors = current_state.get_neighbors()
        max_change = -math.inf
        min_change = math.inf
        next_state = None
        for neighbor in neighbors:
            if neighbor in visited:
                continue
            if neighbor.x > max_x or neighbor.x < min_x or neighbor.y > max_y or (neighbor.y < min_y):
                continue
            change = neighbor.score() - current_score
            if find_max:
                if change > max_change and change > 0:
                    max_change = change
                    next_state = neighbor
            elif change < min_change and change < 0:
                min_change = change
                next_state = neighbor
        if next_state is not None:
            current_state = next_state
        else:
            solution_found = True
    if visualization:
        from matplotlib import pyplot as plt
        plt.plot(range(iterations), scores)
        plt.xlabel('Iterations')
        plt.ylabel('Function values')
        plt.show()
    return current_state",0.4946134,0.98717904
dfs_traverse,breadth_first_search_with_deque,dfs_traverse Traversal by depth first search.,"breadth_first_search_with_deque >>> ''.join(breadth_first_search_with_deque(G, 'A'))
'ABCDEF'","def dfs_traverse(graph, start):
    """"""
    Traversal by depth first search.
    """"""
    (visited, stack) = (set(), [start])
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            for next_node in graph[node]:
                if next_node not in visited:
                    stack.append(next_node)
    return visited","def breadth_first_search_with_deque(graph: dict, start: str) -> list[str]:
    """"""
    Implementation of breadth first search using collection.queue.

    >>> ''.join(breadth_first_search_with_deque(G, 'A'))
    'ABCDEF'
    """"""
    visited = {start}
    result = [start]
    queue = deque([start])
    while queue:
        v = queue.popleft()
        for child in graph[v]:
            if child not in visited:
                visited.add(child)
                result.append(child)
                queue.append(child)
    return result",0.62694377,0.9999385
bfs_traverse,breadth_first_search,bfs_traverse Traversal by breadth first search.,"breadth_first_search >>> ''.join(breadth_first_search(G, 'A'))
'ABCDEF'","def bfs_traverse(graph, start):
    """"""
    Traversal by breadth first search.
    """"""
    (visited, queue) = (set(), [start])
    while queue:
        node = queue.pop(0)
        if node not in visited:
            visited.add(node)
            for next_node in graph[node]:
                if next_node not in visited:
                    queue.append(next_node)
    return visited","def breadth_first_search(graph: dict, start: str) -> list[str]:
    """"""
    Implementation of breadth first search using queue.Queue.

    >>> ''.join(breadth_first_search(G, 'A'))
    'ABCDEF'
    """"""
    explored = {start}
    result = [start]
    queue: Queue = Queue()
    queue.put(start)
    while not queue.empty():
        v = queue.get()
        for w in graph[v]:
            if w not in explored:
                explored.add(w)
                result.append(w)
                queue.put(w)
    return result",0.67200214,0.9999403
dfs_traverse_recursive,rec_linear_search,dfs_traverse_recursive Traversal by recursive depth first search.,rec_linear_search A pure Python implementation of a recursive linear search algorithm,"def dfs_traverse_recursive(graph, start, visited=None):
    """"""
    Traversal by recursive depth first search.
    """"""
    if visited is None:
        visited = set()
    visited.add(start)
    for next_node in graph[start]:
        if next_node not in visited:
            dfs_traverse_recursive(graph, next_node, visited)
    return visited","def rec_linear_search(sequence: list, low: int, high: int, target: int) -> int:
    """"""
    A pure Python implementation of a recursive linear search algorithm

    :param sequence: a collection with comparable items (as sorted items not required
        in Linear Search)
    :param low: Lower bound of the array
    :param high: Higher bound of the array
    :param target: The element to be found
    :return: Index of the key or -1 if key not found

    Examples:
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)
    0
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)
    4
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)
    1
    >>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)
    -1
    """"""
    if not (0 <= high < len(sequence) and 0 <= low < len(sequence)):
        raise Exception('Invalid upper or lower bound!')
    if high < low:
        return -1
    if sequence[low] == target:
        return low
    if sequence[high] == target:
        return high
    return rec_linear_search(sequence, low + 1, high - 1, target)",0.63710266,0.9536926
__choose_state,choose,__choose_state Choose the next state randomly,"choose >>> choose(4,2)
6
>>> choose(5,3)
10
>>> choose(20,6)
38760","def __choose_state(state_map):
    """"""
    Choose the next state randomly
    """"""
    choice = random.random()
    probability_reached = 0
    for (state, probability) in state_map.items():
        probability_reached += probability
        if probability_reached > choice:
            return state
    return None","def choose(n: int, r: int) -> int:
    """"""
    Calculate the binomial coefficient c(n,r) using the multiplicative formula.
    >>> choose(4,2)
    6
    >>> choose(5,3)
    10
    >>> choose(20,6)
    38760
    """"""
    ret = 1.0
    for i in range(1, r + 1):
        ret *= (n + 1 - i) / i
    return round(ret)",0.5998195,0.15162872
next_state,next_number,"next_state Given a markov-chain, randomly chooses the next state given the current state.","next_number to form a new number.
For example, if number = 12, next_number() will return 1^2 + 2^2 = 5.
Therefore, 5 is the next number of the chain.
>>> next_number(44)
32
>>> next_number(10)
1
>>> next_number(32)
13","def next_state(chain, current_state):
    """"""
    Given a markov-chain, randomly chooses the next state given the current state.
    """"""
    next_state_map = chain.get(current_state)
    return __choose_state(next_state_map)","def next_number(number: int) -> int:
    """"""
    Returns the next number of the chain by adding the square of each digit
    to form a new number.
    For example, if number = 12, next_number() will return 1^2 + 2^2 = 5.
    Therefore, 5 is the next number of the chain.
    >>> next_number(44)
    32
    >>> next_number(10)
    1
    >>> next_number(32)
    13
    """"""
    sum_of_digits_squared = 0
    while number:
        sum_of_digits_squared += DIGITS_SQUARED[number % 100000]
        number //= 100000
    return sum_of_digits_squared",0.5576867,0.0013915224
iterating_markov_chain,jacobi_iteration_method,iterating_markov_chain Yield a sequence of states given a markov chain and the initial state,"jacobi_iteration_method An iterative algorithm to determine the solutions of strictly diagonally dominant
system of linear equations

4x1 +  x2 +  x3 =  2
 x1 + 5x2 + 2x3 = -6
 x1 + 2x2 + 4x3 = -4

x_init = [0.5, -0.5 , -0.5]

Examples:

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
[0.909375, -1.14375, -0.7484375]


>>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
Traceback (most recent call last):
    ...
ValueError: Coefficient matrix dimensions must be nxn but received 2x3

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
Traceback (most recent call last):
    ...
ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but
            received 3x3 and 2x1

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
Traceback (most recent call last):
    ...
ValueError: Number of initial values must be equal to number of rows in coefficient
            matrix but received 2 and 3

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 0
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
Traceback (most recent call last):
    ...
ValueError: Iterations must be at least 1","def iterating_markov_chain(chain, state):
    """"""
    Yield a sequence of states given a markov chain and the initial state
    """"""
    while True:
        state = next_state(chain, state)
        yield state","def jacobi_iteration_method(coefficient_matrix: NDArray[float64], constant_matrix: NDArray[float64], init_val: list[int], iterations: int) -> list[float]:
    """"""
    Jacobi Iteration Method:
    An iterative algorithm to determine the solutions of strictly diagonally dominant
    system of linear equations

    4x1 +  x2 +  x3 =  2
     x1 + 5x2 + 2x3 = -6
     x1 + 2x2 + 4x3 = -4

    x_init = [0.5, -0.5 , -0.5]

    Examples:

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    [0.909375, -1.14375, -0.7484375]


    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    Traceback (most recent call last):
        ...
    ValueError: Coefficient matrix dimensions must be nxn but received 2x3

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    Traceback (most recent call last):
        ...
    ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but
                received 3x3 and 2x1

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5]
    >>> iterations = 3
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    Traceback (most recent call last):
        ...
    ValueError: Number of initial values must be equal to number of rows in coefficient
                matrix but received 2 and 3

    >>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
    >>> constant = np.array([[2], [-6], [-4]])
    >>> init_val = [0.5, -0.5, -0.5]
    >>> iterations = 0
    >>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
    Traceback (most recent call last):
        ...
    ValueError: Iterations must be at least 1
    """"""
    (rows1, cols1) = coefficient_matrix.shape
    (rows2, cols2) = constant_matrix.shape
    if rows1 != cols1:
        raise ValueError(f'Coefficient matrix dimensions must be nxn but received {rows1}x{cols1}')
    if cols2 != 1:
        raise ValueError(f'Constant matrix must be nx1 but received {rows2}x{cols2}')
    if rows1 != rows2:
        raise ValueError(f'Coefficient and constant matrices dimensions must be nxn and nx1 but\n            received {rows1}x{cols1} and {rows2}x{cols2}')
    if len(init_val) != rows1:
        raise ValueError(f'Number of initial values must be equal to number of rows in coefficient\n            matrix but received {len(init_val)} and {rows1}')
    if iterations <= 0:
        raise ValueError('Iterations must be at least 1')
    table: NDArray[float64] = np.concatenate((coefficient_matrix, constant_matrix), axis=1)
    (rows, cols) = table.shape
    strictly_diagonally_dominant(table)
    for _ in range(iterations):
        new_val = []
        for row in range(rows):
            temp = 0
            for col in range(cols):
                if col == row:
                    denom = table[row][col]
                elif col == cols - 1:
                    val = table[row][col]
                else:
                    temp += -1 * table[row][col] * init_val[col]
            temp = (temp + val) / denom
            new_val.append(temp)
        init_val = new_val
    return [float(i) for i in new_val]",0.56821537,0.3215374
all_pairs_shortest_path,bfs_shortest_path_distance,all_pairs_shortest_path matrix containing the shortest distance distance between the two nodes.,bfs_shortest_path_distance Find shortest path distance between `start` and `target` nodes.,"def all_pairs_shortest_path(adjacency_matrix):
    """"""
    Given a matrix of the edge weights between respective nodes, returns a
    matrix containing the shortest distance distance between the two nodes.
    """"""
    new_array = copy.deepcopy(adjacency_matrix)
    size = len(new_array)
    for k in range(size):
        for i in range(size):
            for j in range(size):
                if new_array[i][j] > new_array[i][k] + new_array[k][j]:
                    new_array[i][j] = new_array[i][k] + new_array[k][j]
    return new_array","def bfs_shortest_path_distance(graph: dict, start, target) -> int:
    """"""Find shortest path distance between `start` and `target` nodes.
    Args:
        graph: node/list of neighboring nodes key/value pairs.
        start: node to start search from.
        target: node to search for.
    Returns:
        Number of edges in shortest path between `start` and `target` nodes.
        -1 if no path exists.
    Example:
        >>> bfs_shortest_path_distance(demo_graph, ""G"", ""D"")
        4
        >>> bfs_shortest_path_distance(demo_graph, ""A"", ""A"")
        0
        >>> bfs_shortest_path_distance(demo_graph, ""A"", ""Unknown"")
        -1
    """"""
    if not graph or start not in graph or target not in graph:
        return -1
    if start == target:
        return 0
    queue = [start]
    visited = set(start)
    dist = {start: 0, target: -1}
    while queue:
        node = queue.pop(0)
        if node == target:
            dist[target] = dist[node] if dist[target] == -1 else min(dist[target], dist[node])
        for adjacent in graph[node]:
            if adjacent not in visited:
                visited.add(adjacent)
                queue.append(adjacent)
                dist[adjacent] = dist[node] + 1
    return dist[target]",0.7212666,0.89984894
find_all_path,find_empty_location,find_all_path Find all paths between two nodes using recursion and backtracking,find_empty_location for that particular row and column.,"def find_all_path(graph, start, end, path=[]):
    """"""
    Find all paths between two nodes using recursion and backtracking
    """"""
    path = path + [start]
    if start == end:
        return [path]
    if not start in graph:
        return []
    paths = []
    for node in graph[start]:
        if node not in path:
            newpaths = find_all_path(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths","def find_empty_location(grid: Matrix) -> tuple[int, int] | None:
    """"""
    This function finds an empty location so that we can assign a number
    for that particular row and column.
    """"""
    for i in range(9):
        for j in range(9):
            if grid[i][j] == 0:
                return (i, j)
    return None",0.49841198,0.732575
find_shortest_path,bfs_shortest_path,find_shortest_path find the shortest path between two nodes,bfs_shortest_path Find shortest path between `start` and `goal` nodes.,"def find_shortest_path(graph, start, end, path=[]):
    """"""
    find the shortest path between two nodes
    """"""
    path = path + [start]
    if start == end:
        return path
    if start not in graph:
        return None
    shortest = None
    for node in graph[start]:
        if node not in path:
            newpath = find_shortest_path(graph, node, end, path)
            if newpath:
                if not shortest or len(newpath) < len(shortest):
                    shortest = newpath
    return shortest","def bfs_shortest_path(graph: dict, start, goal) -> list[str]:
    """"""Find shortest path between `start` and `goal` nodes.
    Args:
        graph (dict): node/list of neighboring nodes key/value pairs.
        start: start node.
        goal: target node.
    Returns:
        Shortest path between `start` and `goal` nodes as a string of nodes.
        'Not found' string if no path found.
    Example:
        >>> bfs_shortest_path(demo_graph, ""G"", ""D"")
        ['G', 'C', 'A', 'B', 'D']
        >>> bfs_shortest_path(demo_graph, ""G"", ""G"")
        ['G']
        >>> bfs_shortest_path(demo_graph, ""G"", ""Unknown"")
        []
    """"""
    explored = set()
    queue = [[start]]
    if start == goal:
        return [start]
    while queue:
        path = queue.pop(0)
        node = path[-1]
        if node not in explored:
            neighbours = graph[node]
            for neighbour in neighbours:
                new_path = list(path)
                new_path.append(neighbour)
                queue.append(new_path)
                if neighbour == goal:
                    return new_path
            explored.add(node)
    return []",0.7617557,0.9994949
clone_graph1,generate_neighbours,clone_graph1 Returns a new graph as seen from the given node using a breadth first search (BFS).,"generate_neighbours neighbor, given a path file that includes a graph.","def clone_graph1(node):
    """"""
    Returns a new graph as seen from the given node using a breadth first search (BFS).
    """"""
    if not node:
        return None
    node_copy = node.shallow_copy()
    dic = {node: node_copy}
    queue = collections.deque([node])
    while queue:
        node = queue.popleft()
        for neighbor in node.neighbors:
            if neighbor not in dic:
                neighbor_copy = neighbor.shallow_copy()
                dic[neighbor] = neighbor_copy
                dic[node].add_neighbor(neighbor_copy)
                queue.append(neighbor)
            else:
                dic[node].add_neighbor(dic[neighbor])
    return node_copy","def generate_neighbours(path):
    """"""
    Pure implementation of generating a dictionary of neighbors and the cost with each
    neighbor, given a path file that includes a graph.

    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)
    :return dict_of_neighbours: Dictionary with key each node and value a list of lists
        with the neighbors of the node and the cost (distance) for each neighbor.

    Example of dict_of_neighbours:
    >>) dict_of_neighbours[a]
    [[b,20],[c,18],[d,22],[e,26]]

    This indicates the neighbors of node (city) 'a', which has neighbor the node 'b'
    with distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and
    the node 'e' with distance 26.
    """"""
    dict_of_neighbours = {}
    with open(path) as f:
        for line in f:
            if line.split()[0] not in dict_of_neighbours:
                _list = []
                _list.append([line.split()[1], line.split()[2]])
                dict_of_neighbours[line.split()[0]] = _list
            else:
                dict_of_neighbours[line.split()[0]].append([line.split()[1], line.split()[2]])
            if line.split()[1] not in dict_of_neighbours:
                _list = []
                _list.append([line.split()[0], line.split()[2]])
                dict_of_neighbours[line.split()[1]] = _list
            else:
                dict_of_neighbours[line.split()[1]].append([line.split()[0], line.split()[2]])
    return dict_of_neighbours",0.53815067,0.9978727
clone_graph2,create_sparse,clone_graph2 Returns a new graph as seen from the given node using an iterative depth first search (DFS).,create_sparse creating sparse table which saves each nodes 2^i-th parent,"def clone_graph2(node):
    """"""
    Returns a new graph as seen from the given node using an iterative depth first search (DFS).
    """"""
    if not node:
        return None
    node_copy = node.shallow_copy()
    dic = {node: node_copy}
    stack = [node]
    while stack:
        node = stack.pop()
        for neighbor in node.neighbors:
            if neighbor not in dic:
                neighbor_copy = neighbor.shallow_copy()
                dic[neighbor] = neighbor_copy
                dic[node].add_neighbor(neighbor_copy)
                stack.append(neighbor)
            else:
                dic[node].add_neighbor(dic[neighbor])
    return node_copy","def create_sparse(max_node: int, parent: list[list[int]]) -> list[list[int]]:
    """"""
    creating sparse table which saves each nodes 2^i-th parent
    """"""
    j = 1
    while 1 << j < max_node:
        for i in range(1, max_node + 1):
            parent[j][i] = parent[j - 1][parent[j - 1][i]]
        j += 1
    return parent",0.5129028,0.09842311
clone_graph,find_freq_subgraph_given_support,clone_graph Returns a new graph as seen from the given node using a recursive depth first search (DFS).,find_freq_subgraph_given_support find edges of multiple frequent subgraphs,"def clone_graph(node):
    """"""
    Returns a new graph as seen from the given node using a recursive depth first search (DFS).
    """"""
    if not node:
        return None
    node_copy = node.shallow_copy()
    dic = {node: node_copy}
    dfs(node, dic)
    return node_copy","def find_freq_subgraph_given_support(s, cluster, graph):
    """"""
    find edges of multiple frequent subgraphs
    """"""
    k = int(s / 100 * (len(cluster) - 1))
    for i in cluster[k].keys():
        my_dfs(graph, tuple(cluster[k][i]), (['Header'],))",0.53870124,0.004193499
maximum_flow_dfs,find_max_area,maximum_flow_dfs Get the maximum flow through a graph using a depth first search,"find_max_area >>> find_max_area(matrix)
6","def maximum_flow_dfs(adjacency_matrix):
    """"""
    Get the maximum flow through a graph using a depth first search
    """"""
    new_array = copy.deepcopy(adjacency_matrix)
    total = 0
    while True:
        min = math.inf
        visited = [0] * len(new_array)
        path = [0] * len(new_array)
        stack = []
        visited[0] = 1
        stack.append(0)
        while len(stack) > 0:
            src = stack.pop()
            for k in range(len(new_array)):
                if new_array[src][k] > 0 and visited[k] == 0:
                    visited[k] = 1
                    stack.append(k)
                    path[k] = src
        if visited[len(new_array) - 1] == 0:
            break
        tmp = len(new_array) - 1
        while tmp != 0:
            if min > new_array[path[tmp]][tmp]:
                min = new_array[path[tmp]][tmp]
            tmp = path[tmp]
        tmp = len(new_array) - 1
        while tmp != 0:
            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min
            tmp = path[tmp]
        total = total + min
    return total","def find_max_area(mat: list[list[int]]) -> int:
    """"""
    Finds the area of all islands and returns the maximum area.

    >>> find_max_area(matrix)
    6
    """"""
    seen: set = set()
    max_area = 0
    for (row, line) in enumerate(mat):
        for (col, item) in enumerate(line):
            if item == 1 and (row, col) not in seen:
                max_area = max(max_area, depth_first_search(row, col, seen, mat))
    return max_area",0.45476723,0.92401296
one_sparse,double_linear_search,"one_sparse Keyword arguments:
array -- stream of tuples","double_linear_search :param array: the array to be searched
:param search_item: the item to be searched
:return the index of search_item, if search_item is in array, else -1

Examples:
>>> double_linear_search([1, 5, 5, 10], 1)
0
>>> double_linear_search([1, 5, 5, 10], 5)
1
>>> double_linear_search([1, 5, 5, 10], 100)
-1
>>> double_linear_search([1, 5, 5, 10], 10)
3","def one_sparse(array):
    """"""1-sparse algorithm

    Keyword arguments:
    array -- stream of tuples
    """"""
    sum_signs = 0
    bitsum = [0] * 32
    sum_values = 0
    for (val, sign) in array:
        if sign == '+':
            sum_signs += 1
            sum_values += val
        else:
            sum_signs -= 1
            sum_values -= val
        _get_bit_sum(bitsum, val, sign)
    if sum_signs > 0 and _check_every_number_in_bitsum(bitsum, sum_signs):
        return int(sum_values / sum_signs)
    else:
        return None","def double_linear_search(array: list[int], search_item: int) -> int:
    """"""
    Iterate through the array from both sides to find the index of search_item.

    :param array: the array to be searched
    :param search_item: the item to be searched
    :return the index of search_item, if search_item is in array, else -1

    Examples:
    >>> double_linear_search([1, 5, 5, 10], 1)
    0
    >>> double_linear_search([1, 5, 5, 10], 5)
    1
    >>> double_linear_search([1, 5, 5, 10], 100)
    -1
    >>> double_linear_search([1, 5, 5, 10], 10)
    3
    """"""
    (start_ind, end_ind) = (0, len(array) - 1)
    while start_ind <= end_ind:
        if array[start_ind] == search_item:
            return start_ind
        elif array[end_ind] == search_item:
            return end_ind
        else:
            start_ind += 1
            end_ind -= 1
    return -1",0.5464543,2.099797e-05
misras_gries,max_sum_in_array,"misras_gries Keyword arguments:
array -- list of integers
k -- value of k (default 2)","max_sum_in_array >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]
>>> k = 4
>>> max_sum_in_array(arr, k)
24
>>> k = 10
>>> max_sum_in_array(arr,k)
Traceback (most recent call last):
    ...
ValueError: Invalid Input
>>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]
>>> k = 4
>>> max_sum_in_array(arr, k)
27","def misras_gries(array, k=2):
    """"""Misra-Gries algorithm

    Keyword arguments:
    array -- list of integers
    k -- value of k (default 2)
    """"""
    keys = {}
    for i in array:
        val = str(i)
        if val in keys:
            keys[val] = keys[val] + 1
        elif len(keys) < k - 1:
            keys[val] = 1
        else:
            for key in list(keys):
                keys[key] = keys[key] - 1
                if keys[key] == 0:
                    del keys[key]
    suspects = keys.keys()
    frequencies = {}
    for suspect in suspects:
        freq = _count_frequency(array, int(suspect))
        if freq >= len(array) / k:
            frequencies[suspect] = freq
    return frequencies if len(frequencies) > 0 else None","def max_sum_in_array(array: list[int], k: int) -> int:
    """"""
    Returns the maximum sum of k consecutive elements
    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]
    >>> k = 4
    >>> max_sum_in_array(arr, k)
    24
    >>> k = 10
    >>> max_sum_in_array(arr,k)
    Traceback (most recent call last):
        ...
    ValueError: Invalid Input
    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]
    >>> k = 4
    >>> max_sum_in_array(arr, k)
    27
    """"""
    if len(array) < k or k < 0:
        raise ValueError('Invalid Input')
    max_sum = current_sum = sum(array[:k])
    for i in range(len(array) - k):
        current_sum = current_sum - array[i] + array[i + k]
        max_sum = max(max_sum, current_sum)
    return max_sum",0.55917424,0.0034721454
single_number,has_same_digits,"single_number Else if all numbers appear twice, returns 0.","has_same_digits otherwise.

>>> has_same_digits(123456789, 987654321)
True

>>> has_same_digits(123, 23)
False

>>> has_same_digits(1234566, 123456)
False","def single_number(nums):
    """"""
    Returns single number, if found.
    Else if all numbers appear twice, returns 0.
    :type nums: List[int]
    :rtype: int
    """"""
    i = 0
    for num in nums:
        i ^= num
    return i","def has_same_digits(num1: int, num2: int) -> bool:
    """"""
    Return True if num1 and num2 have the same frequency of every digit, False
    otherwise.

    >>> has_same_digits(123456789, 987654321)
    True

    >>> has_same_digits(123, 23)
    False

    >>> has_same_digits(1234566, 123456)
    False
    """"""
    return sorted(str(num1)) == sorted(str(num2))",0.68975693,0.008677963
count_ones_recur,recursive_lucas_number,count_ones_recur Using Brian Kernighan's Algorithm. (Recursive Approach),"recursive_lucas_number >>> recursive_lucas_number(1)
1
>>> recursive_lucas_number(20)
15127
>>> recursive_lucas_number(0)
2
>>> recursive_lucas_number(25)
167761
>>> recursive_lucas_number(-1.5)
Traceback (most recent call last):
    ...
TypeError: recursive_lucas_number accepts only integer arguments.","def count_ones_recur(n):
    """"""Using Brian Kernighan's Algorithm. (Recursive Approach)""""""
    if not n:
        return 0
    return 1 + count_ones_recur(n & n - 1)","def recursive_lucas_number(n_th_number: int) -> int:
    """"""
    Returns the nth lucas number
    >>> recursive_lucas_number(1)
    1
    >>> recursive_lucas_number(20)
    15127
    >>> recursive_lucas_number(0)
    2
    >>> recursive_lucas_number(25)
    167761
    >>> recursive_lucas_number(-1.5)
    Traceback (most recent call last):
        ...
    TypeError: recursive_lucas_number accepts only integer arguments.
    """"""
    if not isinstance(n_th_number, int):
        raise TypeError('recursive_lucas_number accepts only integer arguments.')
    if n_th_number == 0:
        return 2
    if n_th_number == 1:
        return 1
    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(n_th_number - 2)",0.6248594,0.9925741
count_ones_iter,iterate,count_ones_iter Using Brian Kernighan's Algorithm. (Iterative Approach),"iterate Be careful with high values (above 5) since the time to calculate increases
exponentially.
>>> iterate([numpy.array([0, 0]), numpy.array([1, 0])], 1)
[array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]","def count_ones_iter(n):
    """"""Using Brian Kernighan's Algorithm. (Iterative Approach)""""""
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count","def iterate(initial_vectors: list[numpy.ndarray], steps: int) -> list[numpy.ndarray]:
    """"""
    Go through the number of iterations determined by the argument ""steps"".
    Be careful with high values (above 5) since the time to calculate increases
    exponentially.
    >>> iterate([numpy.array([0, 0]), numpy.array([1, 0])], 1)
    [array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]
    """"""
    vectors = initial_vectors
    for _ in range(steps):
        vectors = iteration_step(vectors)
    return vectors",0.605916,0.40225628
powerset,heaps,"powerset For a range of integers up to the length of the given list,
make all possible combinations and chain them together as one object.
From https://docs.python.org/3/library/itertools.html#itertools-recipes","heaps returning all permutations of a list.
>>> heaps([])
[()]
>>> heaps([0])
[(0,)]
>>> heaps([-1, 1])
[(-1, 1), (1, -1)]
>>> heaps([1, 2, 3])
[(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
>>> from itertools import permutations
>>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
True
>>> all(sorted(heaps(x)) == sorted(permutations(x))
...     for x in ([], [0], [-1, 1], [1, 2, 3]))
True","def powerset(iterable):
    """"""Calculate the powerset of any iterable.

    For a range of integers up to the length of the given list,
    make all possible combinations and chain them together as one object.
    From https://docs.python.org/3/library/itertools.html#itertools-recipes
    """"""
    'list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]'
    s = list(iterable)
    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))","def heaps(arr: list) -> list:
    """"""
    Pure python implementation of the iterative Heap's algorithm,
    returning all permutations of a list.
    >>> heaps([])
    [()]
    >>> heaps([0])
    [(0,)]
    >>> heaps([-1, 1])
    [(-1, 1), (1, -1)]
    >>> heaps([1, 2, 3])
    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
    >>> from itertools import permutations
    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
    True
    >>> all(sorted(heaps(x)) == sorted(permutations(x))
    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))
    True
    """"""
    if len(arr) <= 1:
        return [tuple(arr)]
    res = []

    def generate(n: int, arr: list):
        c = [0] * n
        res.append(tuple(arr))
        i = 0
        while i < n:
            if c[i] < i:
                if i % 2 == 0:
                    (arr[0], arr[i]) = (arr[i], arr[0])
                else:
                    (arr[c[i]], arr[i]) = (arr[i], arr[c[i]])
                res.append(tuple(arr))
                c[i] += 1
                i = 0
            else:
                c[i] = 0
                i += 1
    generate(len(arr), arr)
    return res",0.5044131,0.4516844
optimal_set_cover,max_sub_array_sum,optimal_set_cover Finds the minimum cost subcollection os S that covers all elements of U,max_sub_array_sum -3,"def optimal_set_cover(universe, subsets, costs):
    """""" Optimal algorithm - DONT USE ON BIG INPUTS - O(2^n) complexity!
    Finds the minimum cost subcollection os S that covers all elements of U

    Args:
        universe (list): Universe of elements
        subsets (dict): Subsets of U {S1:elements,S2:elements}
        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}
    """"""
    pset = powerset(subsets.keys())
    best_set = None
    best_cost = float('inf')
    for subset in pset:
        covered = set()
        cost = 0
        for s in subset:
            covered.update(subsets[s])
            cost += costs[s]
        if len(covered) == len(universe) and cost < best_cost:
            best_set = subset
            best_cost = cost
    return best_set","def max_sub_array_sum(a: list, size: int=0):
    """"""
    >>> max_sub_array_sum([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])
    -3
    """"""
    size = size or len(a)
    max_so_far = -maxsize - 1
    max_ending_here = 0
    for i in range(0, size):
        max_ending_here = max_ending_here + a[i]
        max_so_far = max(max_so_far, max_ending_here)
        max_ending_here = max(max_ending_here, 0)
    return max_so_far",0.53911406,0.9877685
greedy_set_cover,greedy_min_vertex_cover,greedy_set_cover inputs - though not an optimal solution.,"greedy_min_vertex_cover @input: graph (graph stored in an adjacency list where each vertex
        is represented with an integer)
@example:
>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}
>>> greedy_min_vertex_cover(graph)
{0, 1, 2, 4}","def greedy_set_cover(universe, subsets, costs):
    """"""Approximate greedy algorithm for set-covering. Can be used on large
    inputs - though not an optimal solution.

    Args:
        universe (list): Universe of elements
        subsets (dict): Subsets of U {S1:elements,S2:elements}
        costs (dict): Costs of each subset in S - {S1:cost, S2:cost...}
    """"""
    elements = set((e for s in subsets.keys() for e in subsets[s]))
    if elements != universe:
        return None
    covered = set()
    cover_sets = []
    while covered != universe:
        min_cost_elem_ratio = float('inf')
        min_set = None
        for (s, elements) in subsets.items():
            new_elements = len(elements - covered)
            if new_elements != 0:
                cost_elem_ratio = costs[s] / new_elements
                if cost_elem_ratio < min_cost_elem_ratio:
                    min_cost_elem_ratio = cost_elem_ratio
                    min_set = s
        cover_sets.append(min_set)
        covered |= subsets[min_set]
    return cover_sets","def greedy_min_vertex_cover(graph: dict) -> set[int]:
    """"""
    Greedy APX Algorithm for min Vertex Cover
    @input: graph (graph stored in an adjacency list where each vertex
            is represented with an integer)
    @example:
    >>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}
    >>> greedy_min_vertex_cover(graph)
    {0, 1, 2, 4}
    """"""
    queue: list[list] = []
    for (key, value) in graph.items():
        heapq.heappush(queue, [-1 * len(value), (key, value)])
    chosen_vertices = set()
    while queue and queue[0][0] != 0:
        argmax = heapq.heappop(queue)[1][0]
        chosen_vertices.add(argmax)
        for elem in queue:
            if elem[0] == 0:
                continue
            if argmax in elem[1][1]:
                index = elem[1][1].index(argmax)
                del elem[1][1][index]
                elem[0] += 1
        heapq.heapify(queue)
    return chosen_vertices",0.5035794,0.99364036
exchange_sort,exchange_sort,exchange_sort Complexity : O(n^2),"exchange_sort Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort
>>> exchange_sort([5, 4, 3, 2, 1])
[1, 2, 3, 4, 5]
>>> exchange_sort([-1, -2, -3])
[-3, -2, -1]
>>> exchange_sort([1, 2, 3, 4, 5])
[1, 2, 3, 4, 5]
>>> exchange_sort([0, 10, -2, 5, 3])
[-2, 0, 3, 5, 10]
>>> exchange_sort([])
[]","def exchange_sort(arr):
    """"""
    Reference : https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort
    Complexity : O(n^2)
    """"""
    arr_len = len(arr)
    for i in range(arr_len - 1):
        for j in range(i + 1, arr_len):
            if arr[i] > arr[j]:
                (arr[i], arr[j]) = (arr[j], arr[i])
    return arr","def exchange_sort(numbers: list[int]) -> list[int]:
    """"""
    Uses exchange sort to sort a list of numbers.
    Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort
    >>> exchange_sort([5, 4, 3, 2, 1])
    [1, 2, 3, 4, 5]
    >>> exchange_sort([-1, -2, -3])
    [-3, -2, -1]
    >>> exchange_sort([1, 2, 3, 4, 5])
    [1, 2, 3, 4, 5]
    >>> exchange_sort([0, 10, -2, 5, 3])
    [-2, 0, 3, 5, 10]
    >>> exchange_sort([])
    []
    """"""
    numbers_length = len(numbers)
    for i in range(numbers_length):
        for j in range(i + 1, numbers_length):
            if numbers[j] < numbers[i]:
                (numbers[i], numbers[j]) = (numbers[j], numbers[i])
    return numbers",0.6653551,0.9999918
merge_sort,merge_insertion_sort,merge_sort Complexity: O(n log(n)),merge_insertion_sort Pure implementation of merge-insertion sort algorithm in Python,"def merge_sort(arr):
    """""" Merge Sort
        Complexity: O(n log(n))
    """"""
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    (left, right) = (merge_sort(arr[:mid]), merge_sort(arr[mid:]))
    return merge(left, right, arr.copy())","def merge_insertion_sort(collection: list[int]) -> list[int]:
    """"""Pure implementation of merge-insertion sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> merge_insertion_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> merge_insertion_sort([99])
    [99]

    >>> merge_insertion_sort([-2, -5, -45])
    [-45, -5, -2]

    Testing with all permutations on range(0,5):
    >>> import itertools
    >>> permutations = list(itertools.permutations([0, 1, 2, 3, 4]))
    >>> all(merge_insertion_sort(p) == [0, 1, 2, 3, 4] for p in permutations)
    True
    """"""
    if len(collection) <= 1:
        return collection
    '\n    Group the items into two pairs, and leave one element if there is a last odd item.\n\n    Example: [999, 100, 75, 40, 10000]\n                -> [999, 100], [75, 40]. Leave 10000.\n    '
    two_paired_list = []
    has_last_odd_item = False
    for i in range(0, len(collection), 2):
        if i == len(collection) - 1:
            has_last_odd_item = True
        else:
            '\n            Sort two-pairs in each groups.\n\n            Example: [999, 100], [75, 40]\n                        -> [100, 999], [40, 75]\n            '
            if collection[i] < collection[i + 1]:
                two_paired_list.append([collection[i], collection[i + 1]])
            else:
                two_paired_list.append([collection[i + 1], collection[i]])
    '\n    Sort two_paired_list.\n\n    Example: [100, 999], [40, 75]\n                -> [40, 75], [100, 999]\n    '
    sorted_list_2d = sortlist_2d(two_paired_list)
    '\n    40 < 100 is sure because it has already been sorted.\n    Generate the sorted_list of them so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           40     100\n           75     999\n        ->\n           group0 group1\n           [40,   100]\n           75     999\n    '
    result = [i[0] for i in sorted_list_2d]
    '\n    100 < 999 is sure because it has already been sorted.\n    Put 999 in last of the sorted_list so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100]\n           75     999\n        ->\n           group0 group1\n           [40,   100,   999]\n           75\n    '
    result.append(sorted_list_2d[-1][1])
    '\n    Insert the last odd item left if there is.\n\n    Example:\n           group0 group1\n           [40,   100,   999]\n           75\n        ->\n           group0 group1\n           [40,   100,   999,   10000]\n           75\n    '
    if has_last_odd_item:
        pivot = collection[-1]
        result = binary_search_insertion(result, pivot)
    ""\n    Insert the remaining items.\n    In this case, 40 < 75 is sure because it has already been sorted.\n    Therefore, you only need to insert 75 into [100, 999, 10000],\n    so that you can avoid unnecessary comparison.\n\n    Example:\n           group0 group1\n           [40,   100,   999,   10000]\n            ^ You don't need to compare with this as 40 < 75 is already sure.\n           75\n        ->\n           [40,   75,    100,   999,   10000]\n    ""
    is_last_odd_item_inserted_before_this_index = False
    for i in range(len(sorted_list_2d) - 1):
        if result[i] == collection[-1] and has_last_odd_item:
            is_last_odd_item_inserted_before_this_index = True
        pivot = sorted_list_2d[i][1]
        if is_last_odd_item_inserted_before_this_index:
            result = result[:i + 2] + binary_search_insertion(result[i + 2:], pivot)
        else:
            result = result[:i + 1] + binary_search_insertion(result[i + 1:], pivot)
    return result",0.6718206,0.9875052
merge,combination_sum_iv_dp_array,merge Complexity: O(n),"combination_sum_iv_dp_array of possible combination in O(N^2) Time Complexity as we are using Dynamic
programming array here.

>>> combination_sum_iv_dp_array(3, [1,2,5], 5)
9","def merge(left, right, merged):
    """""" Merge helper
        Complexity: O(n)
    """"""
    (left_cursor, right_cursor) = (0, 0)
    while left_cursor < len(left) and right_cursor < len(right):
        if left[left_cursor] <= right[right_cursor]:
            merged[left_cursor + right_cursor] = left[left_cursor]
            left_cursor += 1
        else:
            merged[left_cursor + right_cursor] = right[right_cursor]
            right_cursor += 1
    for left_cursor in range(left_cursor, len(left)):
        merged[left_cursor + right_cursor] = left[left_cursor]
    for right_cursor in range(right_cursor, len(right)):
        merged[left_cursor + right_cursor] = right[right_cursor]
    return merged","def combination_sum_iv_dp_array(n: int, array: list[int], target: int) -> int:
    """"""
    Function checks the all possible combinations, and returns the count
    of possible combination in O(N^2) Time Complexity as we are using Dynamic
    programming array here.

    >>> combination_sum_iv_dp_array(3, [1,2,5], 5)
    9
    """"""

    def count_of_possible_combinations_with_dp_array(target: int, dp_array: list[int]) -> int:
        if target < 0:
            return 0
        if target == 0:
            return 1
        if dp_array[target] != -1:
            return dp_array[target]
        answer = sum((count_of_possible_combinations_with_dp_array(target - item, dp_array) for item in array))
        dp_array[target] = answer
        return answer
    dp_array = [-1] * (target + 1)
    return count_of_possible_combinations_with_dp_array(target, dp_array)",0.671991,0.41165847
cocktail_shaker_sort,cocktail_shaker_sort,"cocktail_shaker_sort Sorting a given array
mutation of bubble sort

reference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort

Worst-case performance: O(N^2)","cocktail_shaker_sort >>> cocktail_shaker_sort([4, 5, 2, 1, 2])
[1, 2, 2, 4, 5]

>>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])
[-4, 0, 1, 2, 5, 11]

>>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])
[-2.4, 0.1, 2.2, 4.4]

>>> cocktail_shaker_sort([1, 2, 3, 4, 5])
[1, 2, 3, 4, 5]

>>> cocktail_shaker_sort([-4, -5, -24, -7, -11])
[-24, -11, -7, -5, -4]","def cocktail_shaker_sort(arr):
    """"""
    Cocktail_shaker_sort
    Sorting a given array
    mutation of bubble sort

    reference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort
    
    Worst-case performance: O(N^2)
    """"""

    def swap(i, j):
        (arr[i], arr[j]) = (arr[j], arr[i])
    n = len(arr)
    swapped = True
    while swapped:
        swapped = False
        for i in range(1, n):
            if arr[i - 1] > arr[i]:
                swap(i - 1, i)
                swapped = True
        if swapped == False:
            return arr
        swapped = False
        for i in range(n - 1, 0, -1):
            if arr[i - 1] > arr[i]:
                swap(i - 1, i)
                swapped = True
    return arr","def cocktail_shaker_sort(unsorted: list) -> list:
    """"""
    Pure implementation of the cocktail shaker sort algorithm in Python.
    >>> cocktail_shaker_sort([4, 5, 2, 1, 2])
    [1, 2, 2, 4, 5]

    >>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])
    [-4, 0, 1, 2, 5, 11]

    >>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])
    [-2.4, 0.1, 2.2, 4.4]

    >>> cocktail_shaker_sort([1, 2, 3, 4, 5])
    [1, 2, 3, 4, 5]

    >>> cocktail_shaker_sort([-4, -5, -24, -7, -11])
    [-24, -11, -7, -5, -4]
    """"""
    for i in range(len(unsorted) - 1, 0, -1):
        swapped = False
        for j in range(i, 0, -1):
            if unsorted[j] < unsorted[j - 1]:
                (unsorted[j], unsorted[j - 1]) = (unsorted[j - 1], unsorted[j])
                swapped = True
        for j in range(i):
            if unsorted[j] > unsorted[j + 1]:
                (unsorted[j], unsorted[j + 1]) = (unsorted[j + 1], unsorted[j])
                swapped = True
        if not swapped:
            break
    return unsorted",0.7237555,0.99998796
shell_sort,shell_sort,shell_sort Complexity: O(n^2),shell_sort Implementation of shell sort algorithm in Python,"def shell_sort(arr):
    """""" Shell Sort
        Complexity: O(n^2)
    """"""
    n = len(arr)
    gap = n // 2
    while gap > 0:
        y_index = gap
        while y_index < len(arr):
            y = arr[y_index]
            x_index = y_index - gap
            while x_index >= 0 and y < arr[x_index]:
                arr[x_index + gap] = arr[x_index]
                x_index = x_index - gap
            arr[x_index + gap] = y
            y_index = y_index + 1
        gap = gap // 2
    return arr","def shell_sort(collection: list) -> list:
    """"""Implementation of shell sort algorithm in Python
    :param collection:  Some mutable ordered collection with heterogeneous
    comparable items inside
    :return:  the same collection ordered by ascending

    >>> shell_sort([3, 2, 1])
    [1, 2, 3]
    >>> shell_sort([])
    []
    >>> shell_sort([1])
    [1]
    """"""
    gap = len(collection)
    shrink = 1.3
    while gap > 1:
        gap = int(gap / shrink)
        for i in range(gap, len(collection)):
            temp = collection[i]
            j = i
            while j >= gap and collection[j - gap] > temp:
                collection[j] = collection[j - gap]
                j -= gap
            collection[j] = temp
    return collection",0.62496555,0.99982256
bogo_sort,bogo_sort,"bogo_sort Best Case Complexity: O(n)
Worst Case Complexity: O(âˆž)
Average Case Complexity: O(n(n-1)!)",bogo_sort Pure implementation of the bogosort algorithm in Python,"def bogo_sort(arr, simulation=False):
    """"""Bogo Sort
        Best Case Complexity: O(n)
        Worst Case Complexity: O(âˆž)
        Average Case Complexity: O(n(n-1)!)
    """"""
    iteration = 0
    if simulation:
        print('iteration', iteration, ':', *arr)

    def is_sorted(arr):
        i = 0
        arr_len = len(arr)
        while i + 1 < arr_len:
            if arr[i] > arr[i + 1]:
                return False
            i += 1
        return True
    while not is_sorted(arr):
        random.shuffle(arr)
        if simulation:
            iteration = iteration + 1
            print('iteration', iteration, ':', *arr)
    return arr","def bogo_sort(collection):
    """"""Pure implementation of the bogosort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> bogo_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> bogo_sort([])
    []
    >>> bogo_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""

    def is_sorted(collection):
        if len(collection) < 2:
            return True
        for i in range(len(collection) - 1):
            if collection[i] > collection[i + 1]:
                return False
        return True
    while not is_sorted(collection):
        random.shuffle(collection)
    return collection",0.540782,0.9999856
bitonic_sort,bitonic_sort,"bitonic_sort It can sort only array that sizes power of 2
It can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)

Worst-case in parallel: O(log(n)^2)
Worst-case in non-parallel: O(nlog(n)^2)

reference: https://en.wikipedia.org/wiki/Bitonic_sorter","bitonic_sort halves in opposite sorting orders, and then calls bitonic_merge to make them in the
same order.

>>> arr = [12, 34, 92, -23, 0, -121, -167, 145]
>>> bitonic_sort(arr, 0, 8, 1)
>>> arr
[-167, -121, -23, 0, 12, 34, 92, 145]

>>> bitonic_sort(arr, 0, 8, 0)
>>> arr
[145, 92, 34, 12, 0, -23, -121, -167]","def bitonic_sort(arr, reverse=False):
    """"""
    bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process
    It can sort only array that sizes power of 2
    It can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)
    
    Worst-case in parallel: O(log(n)^2)
    Worst-case in non-parallel: O(nlog(n)^2)
    
    reference: https://en.wikipedia.org/wiki/Bitonic_sorter
    """"""

    def compare(arr, reverse):
        n = len(arr) // 2
        for i in range(n):
            if reverse != (arr[i] > arr[i + n]):
                (arr[i], arr[i + n]) = (arr[i + n], arr[i])
        return arr

    def bitonic_merge(arr, reverse):
        n = len(arr)
        if n <= 1:
            return arr
        arr = compare(arr, reverse)
        left = bitonic_merge(arr[:n // 2], reverse)
        right = bitonic_merge(arr[n // 2:], reverse)
        return left + right
    n = len(arr)
    if n <= 1:
        return arr
    if not (n and (not n & n - 1)):
        raise ValueError('the size of input should be power of two')
    left = bitonic_sort(arr[:n // 2], True)
    right = bitonic_sort(arr[n // 2:], False)
    arr = bitonic_merge(left + right, reverse)
    return arr","def bitonic_sort(array: list[int], low: int, length: int, direction: int) -> None:
    """"""
    This function first produces a bitonic sequence by recursively sorting its two
    halves in opposite sorting orders, and then calls bitonic_merge to make them in the
    same order.

    >>> arr = [12, 34, 92, -23, 0, -121, -167, 145]
    >>> bitonic_sort(arr, 0, 8, 1)
    >>> arr
    [-167, -121, -23, 0, 12, 34, 92, 145]

    >>> bitonic_sort(arr, 0, 8, 0)
    >>> arr
    [145, 92, 34, 12, 0, -23, -121, -167]
    """"""
    if length > 1:
        middle = int(length / 2)
        bitonic_sort(array, low, middle, 1)
        bitonic_sort(array, low + middle, middle, 0)
        bitonic_merge(array, low, length, direction)",0.720608,0.9994573
pancake_sort,pancake_sort,"pancake_sort Sorting a given array
mutation of selection sort

reference: https://www.geeksforgeeks.org/pancake-sorting/

Overall time complexity : O(N^2)",pancake_sort Sort Array with Pancake Sort.,"def pancake_sort(arr):
    """"""
    Pancake_sort
    Sorting a given array
    mutation of selection sort

    reference: https://www.geeksforgeeks.org/pancake-sorting/
    
    Overall time complexity : O(N^2)
    """"""
    len_arr = len(arr)
    if len_arr <= 1:
        return arr
    for cur in range(len(arr), 1, -1):
        index_max = arr.index(max(arr[0:cur]))
        if index_max + 1 != cur:
            if index_max != 0:
                arr[:index_max + 1] = reversed(arr[:index_max + 1])
            arr[:cur] = reversed(arr[:cur])
    return arr","def pancake_sort(arr):
    """"""Sort Array with Pancake Sort.
    :param arr: Collection containing comparable items
    :return: Collection ordered in ascending order of items
    Examples:
    >>> pancake_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> pancake_sort([])
    []
    >>> pancake_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    cur = len(arr)
    while cur > 1:
        mi = arr.index(max(arr[0:cur]))
        arr = arr[mi::-1] + arr[mi + 1:len(arr)]
        arr = arr[cur - 1::-1] + arr[cur:len(arr)]
        cur -= 1
    return arr",0.7824373,0.9999274
counting_sort,counting_sort,"counting_sort Sorting a array which has no element greater than k
Creating a new temp_arr,where temp_arr[i] contain the number of
element less than or equal to i in the arr
Then placing the number i into a correct position in the result_arr
return the result_arr
Complexity: 0(n)",counting_sort Pure implementation of counting sort algorithm in Python,"def counting_sort(arr):
    """"""
    Counting_sort
    Sorting a array which has no element greater than k
    Creating a new temp_arr,where temp_arr[i] contain the number of
    element less than or equal to i in the arr
    Then placing the number i into a correct position in the result_arr
    return the result_arr
    Complexity: 0(n)
    """"""
    m = min(arr)
    different = 0
    if m < 0:
        different = -m
        for i in range(len(arr)):
            arr[i] += -m
    k = max(arr)
    temp_arr = [0] * (k + 1)
    for i in range(0, len(arr)):
        temp_arr[arr[i]] = temp_arr[arr[i]] + 1
    for i in range(1, k + 1):
        temp_arr[i] = temp_arr[i] + temp_arr[i - 1]
    result_arr = arr.copy()
    for i in range(len(arr) - 1, -1, -1):
        result_arr[temp_arr[arr[i]] - 1] = arr[i] - different
        temp_arr[arr[i]] = temp_arr[arr[i]] - 1
    return result_arr","def counting_sort(collection):
    """"""Pure implementation of counting sort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> counting_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> counting_sort([])
    []
    >>> counting_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    if collection == []:
        return []
    coll_len = len(collection)
    coll_max = max(collection)
    coll_min = min(collection)
    counting_arr_length = coll_max + 1 - coll_min
    counting_arr = [0] * counting_arr_length
    for number in collection:
        counting_arr[number - coll_min] += 1
    for i in range(1, counting_arr_length):
        counting_arr[i] = counting_arr[i] + counting_arr[i - 1]
    ordered = [0] * coll_len
    for i in reversed(range(0, coll_len)):
        ordered[counting_arr[collection[i] - coll_min] - 1] = collection[i]
        counting_arr[collection[i] - coll_min] -= 1
    return ordered",0.7420671,0.99998343
quick_sort,merge_sort,"quick_sort Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)",merge_sort Pure implementation of the fastest merge sort algorithm in Python,"def quick_sort(arr, simulation=False):
    """""" Quick sort
        Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)
    """"""
    iteration = 0
    if simulation:
        print('iteration', iteration, ':', *arr)
    (arr, _) = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)
    return arr","def merge_sort(collection):
    """"""Pure implementation of the fastest merge sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: a collection ordered by ascending

    Examples:
    >>> merge_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> merge_sort([])
    []

    >>> merge_sort([-2, -5, -45])
    [-45, -5, -2]
    """"""
    (start, end) = ([], [])
    while len(collection) > 1:
        (min_one, max_one) = (min(collection), max(collection))
        start.append(min_one)
        end.append(max_one)
        collection.remove(min_one)
        collection.remove(max_one)
    end.reverse()
    return start + collection + end",0.6127114,0.0026520742
max_heap_sort,intro_sort,max_heap_sort Complexity: O(n log(n)),"intro_sort >>> max_depth = 2 * math.ceil(math.log2(len(array)))

>>> intro_sort(array, 0, len(array), 16, max_depth)
[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]","def max_heap_sort(arr, simulation=False):
    """""" Heap Sort that uses a max heap to sort an array in ascending order
        Complexity: O(n log(n))
    """"""
    iteration = 0
    if simulation:
        print('iteration', iteration, ':', *arr)
    for i in range(len(arr) - 1, 0, -1):
        iteration = max_heapify(arr, i, simulation, iteration)
    if simulation:
        iteration = iteration + 1
        print('iteration', iteration, ':', *arr)
    return arr","def intro_sort(array: list, start: int, end: int, size_threshold: int, max_depth: int) -> list:
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]

    >>> max_depth = 2 * math.ceil(math.log2(len(array)))

    >>> intro_sort(array, 0, len(array), 16, max_depth)
    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
    """"""
    while end - start > size_threshold:
        if max_depth == 0:
            return heap_sort(array)
        max_depth -= 1
        pivot = median_of_3(array, start, start + (end - start) // 2 + 1, end - 1)
        p = partition(array, start, end, pivot)
        intro_sort(array, p, end, size_threshold, max_depth)
        end = p
    return insertion_sort(array, start, end)",0.65373397,0.0007065439
max_heapify,heap_sort,max_heapify Max heapify helper for max_heap_sort,"heap_sort >>> heap_sort(array)
[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]","def max_heapify(arr, end, simulation, iteration):
    """""" Max heapify helper for max_heap_sort
    """"""
    last_parent = (end - 1) // 2
    for parent in range(last_parent, -1, -1):
        current_parent = parent
        while current_parent <= last_parent:
            child = 2 * current_parent + 1
            if child + 1 <= end and arr[child] < arr[child + 1]:
                child = child + 1
            if arr[child] > arr[current_parent]:
                (arr[current_parent], arr[child]) = (arr[child], arr[current_parent])
                current_parent = child
                if simulation:
                    iteration = iteration + 1
                    print('iteration', iteration, ':', *arr)
            else:
                break
    (arr[0], arr[end]) = (arr[end], arr[0])
    return iteration","def heap_sort(array: list) -> list:
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]

    >>> heap_sort(array)
    [1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
    """"""
    n = len(array)
    for i in range(n // 2, -1, -1):
        heapify(array, i, n)
    for i in range(n - 1, 0, -1):
        (array[i], array[0]) = (array[0], array[i])
        heapify(array, 0, i)
    return array",0.6879559,0.97958964
min_heap_sort,natural_sort,min_heap_sort Complexity: O(n log(n)),"natural_sort The normal Python sort algorithm sorts lexicographically,
so you might not get the results that you expect...

>>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']
>>> sorted(example1)
['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']
>>> # The natural sort algorithm sort based on meaning and not computer code point.
>>> natural_sort(example1)
['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']

>>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
>>> sorted(example2)
['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
>>> natural_sort(example2)
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']","def min_heap_sort(arr, simulation=False):
    """""" Heap Sort that uses a min heap to sort an array in ascending order
        Complexity: O(n log(n))
    """"""
    iteration = 0
    if simulation:
        print('iteration', iteration, ':', *arr)
    for i in range(0, len(arr) - 1):
        iteration = min_heapify(arr, i, simulation, iteration)
    return arr","def natural_sort(input_list: list[str]) -> list[str]:
    """"""
    Sort the given list of strings in the way that humans expect.

    The normal Python sort algorithm sorts lexicographically,
    so you might not get the results that you expect...

    >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']
    >>> sorted(example1)
    ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']
    >>> # The natural sort algorithm sort based on meaning and not computer code point.
    >>> natural_sort(example1)
    ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']

    >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
    >>> sorted(example2)
    ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
    >>> natural_sort(example2)
    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
    """"""

    def alphanum_key(key):
        return [int(s) if s.isdigit() else s.lower() for s in re.split('([0-9]+)', key)]
    return sorted(input_list, key=alphanum_key)",0.6077674,2.7583263e-05
min_heapify,heapify,min_heapify Min heapify helper for min_heap_sort,"heapify >>> heapify(array, len(array) // 2 ,len(array))","def min_heapify(arr, start, simulation, iteration):
    """""" Min heapify helper for min_heap_sort
    """"""
    end = len(arr) - 1
    last_parent = (end - start - 1) // 2
    for parent in range(last_parent, -1, -1):
        current_parent = parent
        while current_parent <= last_parent:
            child = 2 * current_parent + 1
            if child + 1 <= end - start and arr[child + start] > arr[child + 1 + start]:
                child = child + 1
            if arr[child + start] < arr[current_parent + start]:
                (arr[current_parent + start], arr[child + start]) = (arr[child + start], arr[current_parent + start])
                current_parent = child
                if simulation:
                    iteration = iteration + 1
                    print('iteration', iteration, ':', *arr)
            else:
                break
    return iteration","def heapify(array: list, index: int, heap_size: int) -> None:
    """"""
    >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]

    >>> heapify(array, len(array) // 2 ,len(array))
    """"""
    largest = index
    left_index = 2 * index + 1
    right_index = 2 * index + 2
    if left_index < heap_size and array[largest] < array[left_index]:
        largest = left_index
    if right_index < heap_size and array[largest] < array[right_index]:
        largest = right_index
    if largest != index:
        (array[index], array[largest]) = (array[largest], array[index])
        heapify(array, largest, heap_size)",0.6420975,0.99374384
selection_sort,gnome_sort,selection_sort Complexity: O(n^2),"gnome_sort Take some mutable ordered collection with heterogeneous comparable items inside as
arguments, return the same collection ordered by ascending.

Examples:
>>> gnome_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]

>>> gnome_sort([])
[]

>>> gnome_sort([-2, -5, -45])
[-45, -5, -2]

>>> """".join(gnome_sort(list(set(""Gnomes are stupid!""))))
' !Gadeimnoprstu'","def selection_sort(arr, simulation=False):
    """""" Selection Sort
        Complexity: O(n^2)
    """"""
    iteration = 0
    if simulation:
        print('iteration', iteration, ':', *arr)
    for i in range(len(arr)):
        minimum = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[minimum]:
                minimum = j
        (arr[minimum], arr[i]) = (arr[i], arr[minimum])
        if simulation:
            iteration = iteration + 1
            print('iteration', iteration, ':', *arr)
    return arr","def gnome_sort(lst: list) -> list:
    """"""
    Pure implementation of the gnome sort algorithm in Python

    Take some mutable ordered collection with heterogeneous comparable items inside as
    arguments, return the same collection ordered by ascending.

    Examples:
    >>> gnome_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]

    >>> gnome_sort([])
    []

    >>> gnome_sort([-2, -5, -45])
    [-45, -5, -2]

    >>> """".join(gnome_sort(list(set(""Gnomes are stupid!""))))
    ' !Gadeimnoprstu'
    """"""
    if len(lst) <= 1:
        return lst
    i = 1
    while i < len(lst):
        if lst[i - 1] <= lst[i]:
            i += 1
        else:
            (lst[i - 1], lst[i]) = (lst[i], lst[i - 1])
            i -= 1
            if i == 0:
                i = 1
    return lst",0.63224465,0.98320526
bucket_sort,bucket_sort,"bucket_sort Complexity: O(n^2)
The complexity is dominated by nextSort","bucket_sort >>> bucket_sort(data) == sorted(data)
True
>>> data = [9, 8, 7, 6, -12]
>>> bucket_sort(data) == sorted(data)
True
>>> data = [.4, 1.2, .1, .2, -.9]
>>> bucket_sort(data) == sorted(data)
True
>>> bucket_sort([]) == sorted([])
True
>>> import random
>>> collection = random.sample(range(-50, 50), 50)
>>> bucket_sort(collection) == sorted(collection)
True","def bucket_sort(arr):
    """""" Bucket Sort
        Complexity: O(n^2)
        The complexity is dominated by nextSort
    """"""
    num_buckets = len(arr)
    buckets = [[] for bucket in range(num_buckets)]
    for value in arr:
        index = value * num_buckets // (max(arr) + 1)
        buckets[index].append(value)
    sorted_list = []
    for i in range(num_buckets):
        sorted_list.extend(next_sort(buckets[i]))
    return sorted_list","def bucket_sort(my_list: list) -> list:
    """"""
    >>> data = [-1, 2, -5, 0]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [9, 8, 7, 6, -12]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> data = [.4, 1.2, .1, .2, -.9]
    >>> bucket_sort(data) == sorted(data)
    True
    >>> bucket_sort([]) == sorted([])
    True
    >>> import random
    >>> collection = random.sample(range(-50, 50), 50)
    >>> bucket_sort(collection) == sorted(collection)
    True
    """"""
    if len(my_list) == 0:
        return []
    (min_value, max_value) = (min(my_list), max(my_list))
    bucket_count = int(max_value - min_value) + 1
    buckets: list[list] = [[] for _ in range(bucket_count)]
    for i in my_list:
        buckets[int(i - min_value)].append(i)
    return [v for bucket in buckets for v in sorted(bucket)]",0.5982901,0.9942854
cycle_sort,cycle_sort,"cycle_sort This is based on the idea that the permutations to be sorted
can be decomposed into cycles,
and the results can be individually sorted by cycling.

reference: https://en.wikipedia.org/wiki/Cycle_sort

Average time complexity : O(N^2)
Worst case time complexity : O(N^2)","cycle_sort [1, 2, 3, 4]

>>> cycle_sort([-4, 20, 0, -50, 100, -1])
[-50, -4, -1, 0, 20, 100]

>>> cycle_sort([-.1, -.2, 1.3, -.8])
[-0.8, -0.2, -0.1, 1.3]

>>> cycle_sort([])
[]","def cycle_sort(arr):
    """"""
    cycle_sort
    This is based on the idea that the permutations to be sorted
    can be decomposed into cycles,
    and the results can be individually sorted by cycling.
    
    reference: https://en.wikipedia.org/wiki/Cycle_sort
    
    Average time complexity : O(N^2)
    Worst case time complexity : O(N^2)
    """"""
    len_arr = len(arr)
    for cur in range(len_arr - 1):
        item = arr[cur]
        index = cur
        for i in range(cur + 1, len_arr):
            if arr[i] < item:
                index += 1
        if index == cur:
            continue
        while item == arr[index]:
            index += 1
        (arr[index], item) = (item, arr[index])
        while index != cur:
            index = cur
            for i in range(cur + 1, len_arr):
                if arr[i] < item:
                    index += 1
            while item == arr[index]:
                index += 1
            (arr[index], item) = (item, arr[index])
    return arr","def cycle_sort(array: list) -> list:
    """"""
    >>> cycle_sort([4, 3, 2, 1])
    [1, 2, 3, 4]

    >>> cycle_sort([-4, 20, 0, -50, 100, -1])
    [-50, -4, -1, 0, 20, 100]

    >>> cycle_sort([-.1, -.2, 1.3, -.8])
    [-0.8, -0.2, -0.1, 1.3]

    >>> cycle_sort([])
    []
    """"""
    array_len = len(array)
    for cycle_start in range(0, array_len - 1):
        item = array[cycle_start]
        pos = cycle_start
        for i in range(cycle_start + 1, array_len):
            if array[i] < item:
                pos += 1
        if pos == cycle_start:
            continue
        while item == array[pos]:
            pos += 1
        (array[pos], item) = (item, array[pos])
        while pos != cycle_start:
            pos = cycle_start
            for i in range(cycle_start + 1, array_len):
                if array[i] < item:
                    pos += 1
            while item == array[pos]:
                pos += 1
            (array[pos], item) = (item, array[pos])
    return array",0.7435467,0.9999925
top_sort_recursive,tim_sort,top_sort_recursive Space complexity: O(V),"tim_sort ['P', 'h', 'n', 'o', 't', 'y']
>>> tim_sort((1.1, 1, 0, -1, -1.1))
[-1.1, -1, 0, 1, 1.1]
>>> tim_sort(list(reversed(list(range(7)))))
[0, 1, 2, 3, 4, 5, 6]
>>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])
True
>>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])
True","def top_sort_recursive(graph):
    """""" Time complexity is the same as DFS, which is O(V + E)
        Space complexity: O(V)
    """"""
    (order, enter, state) = ([], set(graph), {})

    def dfs(node):
        state[node] = GRAY
        for k in graph.get(node, ()):
            sk = state.get(k, None)
            if sk == GRAY:
                raise ValueError('cycle')
            if sk == BLACK:
                continue
            enter.discard(k)
            dfs(k)
        order.append(node)
        state[node] = BLACK
    while enter:
        dfs(enter.pop())
    return order","def tim_sort(lst):
    """"""
    >>> tim_sort(""Python"")
    ['P', 'h', 'n', 'o', 't', 'y']
    >>> tim_sort((1.1, 1, 0, -1, -1.1))
    [-1.1, -1, 0, 1, 1.1]
    >>> tim_sort(list(reversed(list(range(7)))))
    [0, 1, 2, 3, 4, 5, 6]
    >>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])
    True
    >>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])
    True
    """"""
    length = len(lst)
    (runs, sorted_runs) = ([], [])
    new_run = [lst[0]]
    sorted_array = []
    i = 1
    while i < length:
        if lst[i] < lst[i - 1]:
            runs.append(new_run)
            new_run = [lst[i]]
        else:
            new_run.append(lst[i])
        i += 1
    runs.append(new_run)
    for run in runs:
        sorted_runs.append(insertion_sort(run))
    for run in sorted_runs:
        sorted_array = merge(sorted_array, run)
    return sorted_array",0.6067095,0.84393597
top_sort,largest_square_area_in_matrix_bottom_up_space_optimization,top_sort Space complexity: O(V),"largest_square_area_in_matrix_bottom_up_space_optimization approach. with space optimization.

>>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])
0","def top_sort(graph):
    """""" Time complexity is the same as DFS, which is O(V + E)
        Space complexity: O(V)
    """"""
    (order, enter, state) = ([], set(graph), {})

    def is_ready(node):
        lst = graph.get(node, ())
        if len(lst) == 0:
            return True
        for k in lst:
            sk = state.get(k, None)
            if sk == GRAY:
                raise ValueError('cycle')
            if sk != BLACK:
                return False
        return True
    while enter:
        node = enter.pop()
        stack = []
        while True:
            state[node] = GRAY
            stack.append(node)
            for k in graph.get(node, ()):
                sk = state.get(k, None)
                if sk == GRAY:
                    raise ValueError('cycle')
                if sk == BLACK:
                    continue
                enter.discard(k)
                stack.append(k)
            while stack and is_ready(stack[-1]):
                node = stack.pop()
                order.append(node)
                state[node] = BLACK
            if len(stack) == 0:
                break
            node = stack.pop()
    return order","def largest_square_area_in_matrix_bottom_up_space_optimization(rows: int, cols: int, mat: list[list[int]]) -> int:
    """"""
    Function updates the largest_square_area, using bottom up
    approach. with space optimization.

    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])
    2
    >>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])
    0
    """"""
    current_row = [0] * (cols + 1)
    next_row = [0] * (cols + 1)
    largest_square_area = 0
    for row in range(rows - 1, -1, -1):
        for col in range(cols - 1, -1, -1):
            right = current_row[col + 1]
            diagonal = next_row[col + 1]
            bottom = next_row[col]
            if mat[row][col] == 1:
                current_row[col] = 1 + min(right, diagonal, bottom)
                largest_square_area = max(current_row[col], largest_square_area)
            else:
                current_row[col] = 0
        next_row = current_row
    return largest_square_area",0.59336567,0.0020993594
insertion_sort,combination_sum_iv_bottom_up,insertion_sort Complexity: O(n^2),"combination_sum_iv_bottom_up and returns the count of possible combination in O(N^2) Time Complexity
as we are using Dynamic programming array here.

>>> combination_sum_iv_bottom_up(3, [1,2,5], 5)
9","def insertion_sort(arr, simulation=False):
    """""" Insertion Sort
        Complexity: O(n^2)
    """"""
    iteration = 0
    if simulation:
        print('iteration', iteration, ':', *arr)
    for i in range(len(arr)):
        cursor = arr[i]
        pos = i
        while pos > 0 and arr[pos - 1] > cursor:
            arr[pos] = arr[pos - 1]
            pos = pos - 1
        arr[pos] = cursor
        if simulation:
            iteration = iteration + 1
            print('iteration', iteration, ':', *arr)
    return arr","def combination_sum_iv_bottom_up(n: int, array: list[int], target: int) -> int:
    """"""
    Function checks the all possible combinations with using bottom up approach,
    and returns the count of possible combination in O(N^2) Time Complexity
    as we are using Dynamic programming array here.

    >>> combination_sum_iv_bottom_up(3, [1,2,5], 5)
    9
    """"""
    dp_array = [0] * (target + 1)
    dp_array[0] = 1
    for i in range(1, target + 1):
        for j in range(n):
            if i - array[j] >= 0:
                dp_array[i] += dp_array[i - array[j]]
    return dp_array[target]",0.6494902,6.705936e-05
encode_rle,run_length_encode,encode_rle under a Run-Length Encoding.,"run_length_encode >>> run_length_encode(""AAAABBBCCDAA"")
[('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]
>>> run_length_encode(""A"")
[('A', 1)]
>>> run_length_encode(""AA"")
[('A', 2)]
>>> run_length_encode(""AAADDDDDDFFFCCCAAVVVV"")
[('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]","def encode_rle(input):
    """"""
    Gets a stream of data and compresses it
    under a Run-Length Encoding.
    :param input: The data to be encoded.
    :return: The encoded string.
    """"""
    if not input:
        return ''
    encoded_str = ''
    prev_ch = ''
    count = 1
    for ch in input:
        if ch != prev_ch:
            if prev_ch:
                encoded_str += str(count) + prev_ch
            count = 1
            prev_ch = ch
        else:
            count += 1
    else:
        return encoded_str + (str(count) + prev_ch)","def run_length_encode(text: str) -> list:
    """"""
    Performs Run Length Encoding
    >>> run_length_encode(""AAAABBBCCDAA"")
    [('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]
    >>> run_length_encode(""A"")
    [('A', 1)]
    >>> run_length_encode(""AA"")
    [('A', 2)]
    >>> run_length_encode(""AAADDDDDDFFFCCCAAVVVV"")
    [('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]
    """"""
    encoded = []
    count = 1
    for i in range(len(text)):
        if i + 1 < len(text) and text[i] == text[i + 1]:
            count += 1
        else:
            encoded.append((text[i], count))
            count = 1
    return encoded",0.66510963,0.9994018
decode_rle,run_length_decode,decode_rle under a Run-Length Decoding.,"run_length_decode >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])
'AAAABBBCCDAA'
>>> run_length_decode([('A', 1)])
'A'
>>> run_length_decode([('A', 2)])
'AA'
>>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])
'AAADDDDDDFFFCCCAAVVVV'","def decode_rle(input):
    """"""
    Gets a stream of data and decompresses it
    under a Run-Length Decoding.
    :param input: The data to be decoded.
    :return: The decoded string.
    """"""
    decode_str = ''
    count = ''
    for ch in input:
        if not ch.isdigit():
            decode_str += ch * int(count)
            count = ''
        else:
            count += ch
    return decode_str","def run_length_decode(encoded: list) -> str:
    """"""
    Performs Run Length Decoding
    >>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])
    'AAAABBBCCDAA'
    >>> run_length_decode([('A', 1)])
    'A'
    >>> run_length_decode([('A', 2)])
    'AA'
    >>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])
    'AAADDDDDDFFFCCCAAVVVV'
    """"""
    return ''.join((char * length for (char, length) in encoded))",0.7227905,0.98854876
elias_generic,inverse,"elias_generic The first part is the unary number of 1 + âŒŠlog2(x)âŒ‹.
The second part is the binary number of x - 2^(âŒŠlog2(x)âŒ‹).
For the final result we add these two parts.","inverse [[-2.0, 1.0], [1.5, -0.5]]
>>> inverse([[1, 1], [1, 1]])","def elias_generic(lencoding, x):
    """"""
	The compressed data is calculated in two parts.
	The first part is the unary number of 1 + âŒŠlog2(x)âŒ‹.
	The second part is the binary number of x - 2^(âŒŠlog2(x)âŒ‹).
	For the final result we add these two parts.
	""""""
    if x == 0:
        return '0'
    first_part = 1 + int(log2(x))
    a = x - 2 ** int(log2(x))
    k = int(log2(x))
    return lencoding(first_part) + binary(a, k)","def inverse(matrix: list[list[int]]) -> list[list[float]] | None:
    """"""
    >>> inverse([[1, 2], [3, 4]])
    [[-2.0, 1.0], [1.5, -0.5]]
    >>> inverse([[1, 1], [1, 1]])
    """"""
    det = determinant(matrix)
    if det == 0:
        return None
    matrix_minor = [[determinant(minor(matrix, i, j)) for j in range(len(matrix))] for i in range(len(matrix))]
    cofactors = [[x * (-1) ** (row + col) for (col, x) in enumerate(matrix_minor[row])] for row in range(len(matrix))]
    adjugate = list(transpose(cofactors))
    return scalar_multiply(adjugate, 1 / det)",0.57619524,0.004755967
elias_gamma,test_gamma,elias_gamma For the first part we put the unary number of x.,test_gamma >>> test_gamma(),"def elias_gamma(x):
    """"""
	For the first part we put the unary number of x.
	""""""
    return elias_generic(unary, x)","def test_gamma() -> None:
    """"""
    >>> test_gamma()
    """"""
    assert gamma(0.5) == sqrt(pi)
    assert gamma(1) == 1.0
    assert gamma(2) == 1.0",0.5575672,0.51792705
elias_delta,ucal,elias_delta For the first part we put the elias_g of the number.,"ucal 0
>>> ucal(1.1, 2)
0.11000000000000011
>>> ucal(1.2, 2)
0.23999999999999994","def elias_delta(x):
    """"""
	For the first part we put the elias_g of the number.
	""""""
    return elias_generic(elias_gamma, x)","def ucal(u: float, p: int) -> float:
    """"""
    >>> ucal(1, 2)
    0
    >>> ucal(1.1, 2)
    0.11000000000000011
    >>> ucal(1.2, 2)
    0.23999999999999994
    """"""
    temp = u
    for i in range(1, p):
        temp = temp * (u - i)
    return temp",0.48411277,0.37050226
get_histogram,hexagonal_num,get_histogram Get histogram representation,"hexagonal_num >>> hexagonal_num(143)
40755
>>> hexagonal_num(21)
861
>>> hexagonal_num(10)
190","def get_histogram(input_list: list) -> dict:
    """"""
    Get histogram representation
    :param input_list: list with different and unordered values
    :return histogram: dict with histogram of input_list
    """"""
    histogram = {}
    for i in input_list:
        histogram[i] = histogram.get(i, 0) + 1
    return histogram","def hexagonal_num(n: int) -> int:
    """"""
    Returns nth hexagonal number
    >>> hexagonal_num(143)
    40755
    >>> hexagonal_num(21)
    861
    >>> hexagonal_num(10)
    190
    """"""
    return n * (2 * n - 1)",0.49890167,0.00083847134
encode,encipher,encode Encodes a list of strings to a single string.,encipher Enciphers a message given a cipher map.,"def encode(strs):
    """"""Encodes a list of strings to a single string.
    :type strs: List[str]
    :rtype: str
    """"""
    res = ''
    for string in strs.split():
        res += str(len(string)) + ':' + string
    return res","def encipher(message: str, cipher_map: dict[str, str]) -> str:
    """"""
    Enciphers a message given a cipher map.
    :param message: Message to encipher
    :param cipher_map: Cipher map
    :return: enciphered string
    >>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))
    'CYJJM VMQJB!!'
    """"""
    return ''.join((cipher_map.get(ch, ch) for ch in message.upper()))",0.5966933,4.5715573e-05
decode,decompress_data,decode Decodes a single string to a list of strings.,decompress_data and returns the result as a string,"def decode(s):
    """"""Decodes a single string to a list of strings.
    :type s: str
    :rtype: List[str]
    """"""
    strs = []
    i = 0
    while i < len(s):
        index = s.find(':', i)
        size = int(s[i:index])
        strs.append(s[index + 1:index + 1 + size])
        i = index + 1 + size
    return strs","def decompress_data(data_bits: str) -> str:
    """"""
    Decompresses given data_bits using Lempelâ€“Zivâ€“Welch compression algorithm
    and returns the result as a string
    """"""
    lexicon = {'0': '0', '1': '1'}
    (result, curr_string) = ('', '')
    index = len(lexicon)
    for i in range(len(data_bits)):
        curr_string += data_bits[i]
        if curr_string not in lexicon:
            continue
        last_match_id = lexicon[curr_string]
        result += last_match_id
        lexicon[curr_string] = last_match_id + '0'
        if math.log2(index).is_integer():
            new_lex = {}
            for curr_key in list(lexicon):
                new_lex['0' + curr_key] = lexicon.pop(curr_key)
            lexicon = new_lex
        lexicon[bin(index)[2:]] = last_match_id + '1'
        index += 1
        curr_string = ''
    return result",0.7816181,0.5069054
remove_punctuation,remove_prefix,"remove_punctuation Remove punctuation, case sensitivity and spaces",remove_prefix Returns the result,"def remove_punctuation(s):
    """"""
    Remove punctuation, case sensitivity and spaces
    """"""
    return ''.join((i.lower() for i in s if i in ascii_letters))","def remove_prefix(data_bits: str) -> str:
    """"""
    Removes size prefix, that compressed file should have
    Returns the result
    """"""
    counter = 0
    for letter in data_bits:
        if letter == '1':
            break
        counter += 1
    data_bits = data_bits[counter:]
    data_bits = data_bits[counter + 1:]
    return data_bits",0.492866,0.4546265
knuth_morris_pratt,get_set_bits_count_using_brian_kernighans_algorithm,knuth_morris_pratt using knuth_morris_pratt algorithm.,"get_set_bits_count_using_brian_kernighans_algorithm >>> get_set_bits_count_using_brian_kernighans_algorithm(25)
3
>>> get_set_bits_count_using_brian_kernighans_algorithm(37)
3
>>> get_set_bits_count_using_brian_kernighans_algorithm(21)
3
>>> get_set_bits_count_using_brian_kernighans_algorithm(58)
4
>>> get_set_bits_count_using_brian_kernighans_algorithm(0)
0
>>> get_set_bits_count_using_brian_kernighans_algorithm(256)
1
>>> get_set_bits_count_using_brian_kernighans_algorithm(-1)
Traceback (most recent call last):
    ...
ValueError: the value of input must not be negative","def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]:
    """"""
    Given two strings text and pattern, return the list of start indexes in text that matches with the pattern
    using knuth_morris_pratt algorithm.

    Args:
        text: Text to search
        pattern: Pattern to search in the text
    Returns:
        List of indices of patterns found

    Example:
        >>> knuth_morris_pratt('hello there hero!', 'he')
        [0, 7, 12]

    If idx is in the list, text[idx : idx + M] matches with pattern.
    Time complexity of the algorithm is O(N+M), with N and M the length of text and pattern, respectively.
    """"""
    n = len(text)
    m = len(pattern)
    pi = [0 for i in range(m)]
    i = 0
    j = 0
    for i in range(1, m):
        while j and pattern[i] != pattern[j]:
            j = pi[j - 1]
        if pattern[i] == pattern[j]:
            j += 1
            pi[i] = j
    j = 0
    ret = []
    for i in range(n):
        while j and text[i] != pattern[j]:
            j = pi[j - 1]
        if text[i] == pattern[j]:
            j += 1
            if j == m:
                ret.append(i - m + 1)
                j = pi[j - 1]
    return ret","def get_set_bits_count_using_brian_kernighans_algorithm(number: int) -> int:
    """"""
    Count the number of set bits in a 32 bit integer
    >>> get_set_bits_count_using_brian_kernighans_algorithm(25)
    3
    >>> get_set_bits_count_using_brian_kernighans_algorithm(37)
    3
    >>> get_set_bits_count_using_brian_kernighans_algorithm(21)
    3
    >>> get_set_bits_count_using_brian_kernighans_algorithm(58)
    4
    >>> get_set_bits_count_using_brian_kernighans_algorithm(0)
    0
    >>> get_set_bits_count_using_brian_kernighans_algorithm(256)
    1
    >>> get_set_bits_count_using_brian_kernighans_algorithm(-1)
    Traceback (most recent call last):
        ...
    ValueError: the value of input must not be negative
    """"""
    if number < 0:
        raise ValueError('the value of input must not be negative')
    result = 0
    while number:
        number &= number - 1
        result += 1
    return result",0.516927,0.9701304
lcs,longest_common_subsequence,lcs The length of longest common subsequence among the two given strings s1 and s2,longest_common_subsequence The subsequence found,"def lcs(s1, s2, i, j):
    """"""
    The length of longest common subsequence among the two given strings s1 and s2
    """"""
    if i == 0 or j == 0:
        return 0
    elif s1[i - 1] == s2[j - 1]:
        return 1 + lcs(s1, s2, i - 1, j - 1)
    else:
        return max(lcs(s1, s2, i - 1, j), lcs(s1, s2, i, j - 1))","def longest_common_subsequence(x: str, y: str):
    """"""
    Finds the longest common subsequence between two strings. Also returns the
    The subsequence found

    Parameters
    ----------

    x: str, one of the strings
    y: str, the other string

    Returns
    -------
    L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)
    Seq: str, the subsequence found

    >>> longest_common_subsequence(""programming"", ""gaming"")
    (6, 'gaming')
    >>> longest_common_subsequence(""physics"", ""smartphone"")
    (2, 'ph')
    >>> longest_common_subsequence(""computer"", ""food"")
    (1, 'o')
    """"""
    assert x is not None
    assert y is not None
    m = len(x)
    n = len(y)
    l = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if x[i - 1] == y[j - 1]:
                match = 1
            else:
                match = 0
            l[i][j] = max(l[i - 1][j], l[i][j - 1], l[i - 1][j - 1] + match)
    seq = ''
    (i, j) = (m, n)
    while i > 0 and j > 0:
        if x[i - 1] == y[j - 1]:
            match = 1
        else:
            match = 0
        if l[i][j] == l[i - 1][j - 1] + match:
            if match == 1:
                seq = x[i - 1] + seq
            i -= 1
            j -= 1
        elif l[i][j] == l[i - 1][j]:
            i -= 1
        else:
            j -= 1
    return (l[m][n], seq)",0.72509503,0.9998857
panagram,is_9_pandigital,panagram Returns whether the input string is an English panagram or not.,"is_9_pandigital >>> is_9_pandigital(12345)
False
>>> is_9_pandigital(156284973)
True
>>> is_9_pandigital(1562849733)
False","def panagram(string):
    """"""
    Returns whether the input string is an English panagram or not.

        Parameters:
            string (str): A sentence in the form of a string.

        Returns:
            A boolean with the result.
    """"""
    letters = set(ascii_lowercase)
    for c in string:
        try:
            letters.remove(c.lower())
        except:
            pass
    return len(letters) == 0","def is_9_pandigital(n: int) -> bool:
    """"""
    Checks whether n is a 9-digit 1 to 9 pandigital number.
    >>> is_9_pandigital(12345)
    False
    >>> is_9_pandigital(156284973)
    True
    >>> is_9_pandigital(1562849733)
    False
    """"""
    s = str(n)
    return len(s) == 9 and set(s) == set('123456789')",0.49485242,0.9959299
common_prefix,alternative_string_arrange,common_prefix Return prefix common of 2 strings,alternative_string_arrange Return the alternative arrangements of the two strings.,"def common_prefix(s1, s2):
    """"""Return prefix common of 2 strings""""""
    if not s1 or not s2:
        return ''
    k = 0
    while s1[k] == s2[k]:
        k = k + 1
        if k >= len(s1) or k >= len(s2):
            return s1[0:k]
    return s1[0:k]","def alternative_string_arrange(first_str: str, second_str: str) -> str:
    """"""
    Return the alternative arrangements of the two strings.
    :param first_str:
    :param second_str:
    :return: String
    >>> alternative_string_arrange(""ABCD"", ""XY"")
    'AXBYCD'
    >>> alternative_string_arrange(""XY"", ""ABCD"")
    'XAYBCD'
    >>> alternative_string_arrange(""AB"", ""XYZ"")
    'AXBYZ'
    >>> alternative_string_arrange(""ABC"", """")
    'ABC'
    """"""
    first_str_length: int = len(first_str)
    second_str_length: int = len(second_str)
    abs_length: int = first_str_length if first_str_length > second_str_length else second_str_length
    output_list: list = []
    for char_count in range(abs_length):
        if char_count < first_str_length:
            output_list.append(first_str[char_count])
        if char_count < second_str_length:
            output_list.append(second_str[char_count])
    return ''.join(output_list)",0.4771857,0.998741
